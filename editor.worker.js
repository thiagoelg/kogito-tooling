/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayQueue": () => (/* binding */ ArrayQueue),
/* harmony export */   "arrayInsert": () => (/* binding */ arrayInsert),
/* harmony export */   "asArray": () => (/* binding */ asArray),
/* harmony export */   "binarySearch": () => (/* binding */ binarySearch),
/* harmony export */   "coalesce": () => (/* binding */ coalesce),
/* harmony export */   "compareBy": () => (/* binding */ compareBy),
/* harmony export */   "distinct": () => (/* binding */ distinct),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "findFirstInSorted": () => (/* binding */ findFirstInSorted),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "findLastMaxBy": () => (/* binding */ findLastMaxBy),
/* harmony export */   "findMaxBy": () => (/* binding */ findMaxBy),
/* harmony export */   "findMinBy": () => (/* binding */ findMinBy),
/* harmony export */   "firstOrDefault": () => (/* binding */ firstOrDefault),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "insertInto": () => (/* binding */ insertInto),
/* harmony export */   "isFalsyOrEmpty": () => (/* binding */ isFalsyOrEmpty),
/* harmony export */   "isNonEmptyArray": () => (/* binding */ isNonEmptyArray),
/* harmony export */   "lastIndex": () => (/* binding */ lastIndex),
/* harmony export */   "numberComparator": () => (/* binding */ numberComparator),
/* harmony export */   "pushToEnd": () => (/* binding */ pushToEnd),
/* harmony export */   "pushToStart": () => (/* binding */ pushToStart),
/* harmony export */   "quickSelect": () => (/* binding */ quickSelect),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "splice": () => (/* binding */ splice),
/* harmony export */   "tail": () => (/* binding */ tail),
/* harmony export */   "tail2": () => (/* binding */ tail2)
/* harmony export */ });
/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function tail(array, n = 0) {
    return array[array.length - (1 + n)];
}
function tail2(arr) {
    if (arr.length === 0) {
        throw new Error('Invalid tail call');
    }
    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
        return true;
    }
    if (!one || !other) {
        return false;
    }
    if (one.length !== other.length) {
        return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
function binarySearch(array, key, comparator) {
    let low = 0, high = array.length - 1;
    while (low <= high) {
        const mid = ((low + high) / 2) | 0;
        const comp = comparator(array[mid], key);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
function findFirstInSorted(array, p) {
    let low = 0, high = array.length;
    if (high === 0) {
        return 0; // no children
    }
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (p(array[mid])) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    return low;
}
function quickSelect(nth, data, compare) {
    nth = nth | 0;
    if (nth >= data.length) {
        throw new TypeError('invalid index');
    }
    let pivotValue = data[Math.floor(data.length * Math.random())];
    let lower = [];
    let higher = [];
    let pivots = [];
    for (let value of data) {
        const val = compare(value, pivotValue);
        if (val < 0) {
            lower.push(value);
        }
        else if (val > 0) {
            higher.push(value);
        }
        else {
            pivots.push(value);
        }
    }
    if (nth < lower.length) {
        return quickSelect(nth, lower, compare);
    }
    else if (nth < lower.length + pivots.length) {
        return pivots[0];
    }
    else {
        return quickSelect(nth - (lower.length + pivots.length), higher, compare);
    }
}
function groupBy(data, compare) {
    const result = [];
    let currentGroup = undefined;
    for (const element of data.slice(0).sort(compare)) {
        if (!currentGroup || compare(currentGroup[0], element) !== 0) {
            currentGroup = [element];
            result.push(currentGroup);
        }
        else {
            currentGroup.push(element);
        }
    }
    return result;
}
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
function coalesce(array) {
    return array.filter(e => !!e);
}
/**
 * @returns false if the provided object is an array and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equality by returning an alternate value for each.
 */
function distinct(array, keyFn = value => value) {
    const seen = new Set();
    return array.filter(element => {
        const key = keyFn(element);
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}
function findLast(arr, predicate) {
    const idx = lastIndex(arr, predicate);
    if (idx === -1) {
        return undefined;
    }
    return arr[idx];
}
function lastIndex(array, fn) {
    for (let i = array.length - 1; i >= 0; i--) {
        const element = array[i];
        if (fn(element)) {
            return i;
        }
    }
    return -1;
}
function firstOrDefault(array, notFoundValue) {
    return array.length > 0 ? array[0] : notFoundValue;
}
function flatten(arr) {
    return [].concat(...arr);
}
function range(arg, to) {
    let from = typeof to === 'number' ? arg : 0;
    if (typeof to === 'number') {
        from = arg;
    }
    else {
        from = 0;
        to = arg;
    }
    const result = [];
    if (from <= to) {
        for (let i = from; i < to; i++) {
            result.push(i);
        }
    }
    else {
        for (let i = from; i > to; i--) {
            result.push(i);
        }
    }
    return result;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */
function arrayInsert(target, insertIndex, insertArr) {
    const before = target.slice(0, insertIndex);
    const after = target.slice(insertIndex);
    return before.concat(insertArr, after);
}
/**
 * Pushes an element to the start of the array, if found.
 */
function pushToStart(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.unshift(value);
    }
}
/**
 * Pushes an element to the end of the array, if found.
 */
function pushToEnd(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.push(value);
    }
}
function asArray(x) {
    return Array.isArray(x) ? x : [x];
}
/**
 * Insert the new items in the array.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start inserting elements.
 * @param newItems The items to be inserted
 */
function insertInto(array, start, newItems) {
    const startIdx = getActualStartIndex(array, start);
    const originalLength = array.length;
    const newItemsLength = newItems.length;
    array.length = originalLength + newItemsLength;
    // Move the items after the start index, start from the end so that we don't overwrite any value.
    for (let i = originalLength - 1; i >= startIdx; i--) {
        array[i + newItemsLength] = array[i];
    }
    for (let i = 0; i < newItemsLength; i++) {
        array[i + startIdx] = newItems[i];
    }
}
/**
 * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it
 * can only support limited number of items due to the maximum call stack size limit.
 * @param array The original array.
 * @param start The zero-based location in the array from which to start removing elements.
 * @param deleteCount The number of elements to remove.
 * @returns An array containing the elements that were deleted.
 */
function splice(array, start, deleteCount, newItems) {
    const index = getActualStartIndex(array, start);
    const result = array.splice(index, deleteCount);
    insertInto(array, index, newItems);
    return result;
}
/**
 * Determine the actual start index (same logic as the native splice() or slice())
 * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.
 * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.
 * @param array The target array.
 * @param start The operation index.
 */
function getActualStartIndex(array, start) {
    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);
}
function compareBy(selector, comparator) {
    return (a, b) => comparator(selector(a), selector(b));
}
/**
 * The natural order on numbers.
*/
const numberComparator = (a, b) => a - b;
/**
 * Returns the first item that is equal to or greater than every other item.
*/
function findMaxBy(items, comparator) {
    if (items.length === 0) {
        return undefined;
    }
    let max = items[0];
    for (let i = 1; i < items.length; i++) {
        const item = items[i];
        if (comparator(item, max) > 0) {
            max = item;
        }
    }
    return max;
}
/**
 * Returns the last item that is equal to or greater than every other item.
*/
function findLastMaxBy(items, comparator) {
    if (items.length === 0) {
        return undefined;
    }
    let max = items[0];
    for (let i = 1; i < items.length; i++) {
        const item = items[i];
        if (comparator(item, max) >= 0) {
            max = item;
        }
    }
    return max;
}
/**
 * Returns the first item that is equal to or less than every other item.
*/
function findMinBy(items, comparator) {
    return findMaxBy(items, (a, b) => -comparator(a, b));
}
class ArrayQueue {
    /**
     * Constructs a queue that is backed by the given array. Runtime is O(1).
    */
    constructor(items) {
        this.items = items;
        this.firstIdx = 0;
        this.lastIdx = this.items.length - 1;
    }
    /**
     * Consumes elements from the beginning of the queue as long as the predicate returns true.
     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
    */
    takeWhile(predicate) {
        // P(k) := k <= this.lastIdx && predicate(this.items[k])
        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)
        let startIdx = this.firstIdx;
        while (startIdx < this.items.length && predicate(this.items[startIdx])) {
            startIdx++;
        }
        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);
        this.firstIdx = startIdx;
        return result;
    }
    /**
     * Consumes elements from the end of the queue as long as the predicate returns true.
     * If no elements were consumed, `null` is returned.
     * The result has the same order as the underlying array!
    */
    takeFromEndWhile(predicate) {
        // P(k) := this.firstIdx >= k && predicate(this.items[k])
        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]
        let endIdx = this.lastIdx;
        while (endIdx >= 0 && predicate(this.items[endIdx])) {
            endIdx--;
        }
        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);
        this.lastIdx = endIdx;
        return result;
    }
    peek() {
        return this.items[this.firstIdx];
    }
    dequeue() {
        const result = this.items[this.firstIdx];
        this.firstIdx++;
        return result;
    }
    takeCount(count) {
        const result = this.items.slice(this.firstIdx, this.firstIdx + count);
        this.firstIdx += count;
        return result;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LRUCachedComputed": () => (/* binding */ LRUCachedComputed)
/* harmony export */ });
/**
 * Uses a LRU cache to make a given parametrized function cached.
 * Caches just the last value.
 * The key must be JSON serializable.
*/
class LRUCachedComputed {
    constructor(computeFn) {
        this.computeFn = computeFn;
        this.lastCache = undefined;
        this.lastArgKey = undefined;
    }
    get(arg) {
        const key = JSON.stringify(arg);
        if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this.computeFn(arg);
        }
        return this.lastCache;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancellationToken": () => (/* binding */ CancellationToken),
/* harmony export */   "CancellationTokenSource": () => (/* binding */ CancellationTokenSource)
/* harmony export */ });
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
var CancellationToken;
(function (CancellationToken) {
    function isCancellationToken(thing) {
        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
            return true;
        }
        if (thing instanceof MutableToken) {
            return true;
        }
        if (!thing || typeof thing !== 'object') {
            return false;
        }
        return typeof thing.isCancellationRequested === 'boolean'
            && typeof thing.onCancellationRequested === 'function';
    }
    CancellationToken.isCancellationToken = isCancellationToken;
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: _event_js__WEBPACK_IMPORTED_MODULE_0__.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
    });
})(CancellationToken || (CancellationToken = {}));
class MutableToken {
    constructor() {
        this._isCancelled = false;
        this._emitter = null;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new _event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
        }
    }
}
class CancellationTokenSource {
    constructor(parent) {
        this._token = undefined;
        this._parentListener = undefined;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else if (this._token instanceof MutableToken) {
            // actually cancel
            this._token.cancel();
        }
    }
    dispose(cancel = false) {
        if (cancel) {
            this.cancel();
        }
        if (this._parentListener) {
            this._parentListener.dispose();
        }
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSIcon": () => (/* binding */ CSSIcon),
/* harmony export */   "Codicon": () => (/* binding */ Codicon),
/* harmony export */   "getCodiconAriaLabel": () => (/* binding */ getCodiconAriaLabel)
/* harmony export */ });
// Selects all codicon names encapsulated in the `$()` syntax and wraps the
// results with spaces so that screen readers can read the text better.
function getCodiconAriaLabel(text) {
    if (!text) {
        return '';
    }
    return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
}
/**
 * The Codicon library is a set of default icons that are built-in in VS Code.
 *
 * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code
 * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.
 * In that call a Codicon can be named as default.
 */
class Codicon {
    constructor(id, definition, description) {
        this.id = id;
        this.definition = definition;
        this.description = description;
        Codicon._allCodicons.push(this);
    }
    get classNames() { return 'codicon codicon-' + this.id; }
    // classNamesArray is useful for migrating to ES6 classlist
    get classNamesArray() { return ['codicon', 'codicon-' + this.id]; }
    get cssSelector() { return '.codicon.codicon-' + this.id; }
    /**
     * @returns Returns all default icons covered by the codicon font. Only to be used by the icon registry in platform.
     */
    static getAll() {
        return Codicon._allCodicons;
    }
}
// registry
Codicon._allCodicons = [];
// built-in icons, with image name
Codicon.add = new Codicon('add', { fontCharacter: '\\ea60' });
Codicon.plus = new Codicon('plus', Codicon.add.definition);
Codicon.gistNew = new Codicon('gist-new', Codicon.add.definition);
Codicon.repoCreate = new Codicon('repo-create', Codicon.add.definition);
Codicon.lightbulb = new Codicon('lightbulb', { fontCharacter: '\\ea61' });
Codicon.lightBulb = new Codicon('light-bulb', { fontCharacter: '\\ea61' });
Codicon.repo = new Codicon('repo', { fontCharacter: '\\ea62' });
Codicon.repoDelete = new Codicon('repo-delete', { fontCharacter: '\\ea62' });
Codicon.gistFork = new Codicon('gist-fork', { fontCharacter: '\\ea63' });
Codicon.repoForked = new Codicon('repo-forked', { fontCharacter: '\\ea63' });
Codicon.gitPullRequest = new Codicon('git-pull-request', { fontCharacter: '\\ea64' });
Codicon.gitPullRequestAbandoned = new Codicon('git-pull-request-abandoned', { fontCharacter: '\\ea64' });
Codicon.recordKeys = new Codicon('record-keys', { fontCharacter: '\\ea65' });
Codicon.keyboard = new Codicon('keyboard', { fontCharacter: '\\ea65' });
Codicon.tag = new Codicon('tag', { fontCharacter: '\\ea66' });
Codicon.tagAdd = new Codicon('tag-add', { fontCharacter: '\\ea66' });
Codicon.tagRemove = new Codicon('tag-remove', { fontCharacter: '\\ea66' });
Codicon.person = new Codicon('person', { fontCharacter: '\\ea67' });
Codicon.personFollow = new Codicon('person-follow', { fontCharacter: '\\ea67' });
Codicon.personOutline = new Codicon('person-outline', { fontCharacter: '\\ea67' });
Codicon.personFilled = new Codicon('person-filled', { fontCharacter: '\\ea67' });
Codicon.gitBranch = new Codicon('git-branch', { fontCharacter: '\\ea68' });
Codicon.gitBranchCreate = new Codicon('git-branch-create', { fontCharacter: '\\ea68' });
Codicon.gitBranchDelete = new Codicon('git-branch-delete', { fontCharacter: '\\ea68' });
Codicon.sourceControl = new Codicon('source-control', { fontCharacter: '\\ea68' });
Codicon.mirror = new Codicon('mirror', { fontCharacter: '\\ea69' });
Codicon.mirrorPublic = new Codicon('mirror-public', { fontCharacter: '\\ea69' });
Codicon.star = new Codicon('star', { fontCharacter: '\\ea6a' });
Codicon.starAdd = new Codicon('star-add', { fontCharacter: '\\ea6a' });
Codicon.starDelete = new Codicon('star-delete', { fontCharacter: '\\ea6a' });
Codicon.starEmpty = new Codicon('star-empty', { fontCharacter: '\\ea6a' });
Codicon.comment = new Codicon('comment', { fontCharacter: '\\ea6b' });
Codicon.commentAdd = new Codicon('comment-add', { fontCharacter: '\\ea6b' });
Codicon.alert = new Codicon('alert', { fontCharacter: '\\ea6c' });
Codicon.warning = new Codicon('warning', { fontCharacter: '\\ea6c' });
Codicon.search = new Codicon('search', { fontCharacter: '\\ea6d' });
Codicon.searchSave = new Codicon('search-save', { fontCharacter: '\\ea6d' });
Codicon.logOut = new Codicon('log-out', { fontCharacter: '\\ea6e' });
Codicon.signOut = new Codicon('sign-out', { fontCharacter: '\\ea6e' });
Codicon.logIn = new Codicon('log-in', { fontCharacter: '\\ea6f' });
Codicon.signIn = new Codicon('sign-in', { fontCharacter: '\\ea6f' });
Codicon.eye = new Codicon('eye', { fontCharacter: '\\ea70' });
Codicon.eyeUnwatch = new Codicon('eye-unwatch', { fontCharacter: '\\ea70' });
Codicon.eyeWatch = new Codicon('eye-watch', { fontCharacter: '\\ea70' });
Codicon.circleFilled = new Codicon('circle-filled', { fontCharacter: '\\ea71' });
Codicon.primitiveDot = new Codicon('primitive-dot', { fontCharacter: '\\ea71' });
Codicon.closeDirty = new Codicon('close-dirty', { fontCharacter: '\\ea71' });
Codicon.debugBreakpoint = new Codicon('debug-breakpoint', { fontCharacter: '\\ea71' });
Codicon.debugBreakpointDisabled = new Codicon('debug-breakpoint-disabled', { fontCharacter: '\\ea71' });
Codicon.debugHint = new Codicon('debug-hint', { fontCharacter: '\\ea71' });
Codicon.primitiveSquare = new Codicon('primitive-square', { fontCharacter: '\\ea72' });
Codicon.edit = new Codicon('edit', { fontCharacter: '\\ea73' });
Codicon.pencil = new Codicon('pencil', { fontCharacter: '\\ea73' });
Codicon.info = new Codicon('info', { fontCharacter: '\\ea74' });
Codicon.issueOpened = new Codicon('issue-opened', { fontCharacter: '\\ea74' });
Codicon.gistPrivate = new Codicon('gist-private', { fontCharacter: '\\ea75' });
Codicon.gitForkPrivate = new Codicon('git-fork-private', { fontCharacter: '\\ea75' });
Codicon.lock = new Codicon('lock', { fontCharacter: '\\ea75' });
Codicon.mirrorPrivate = new Codicon('mirror-private', { fontCharacter: '\\ea75' });
Codicon.close = new Codicon('close', { fontCharacter: '\\ea76' });
Codicon.removeClose = new Codicon('remove-close', { fontCharacter: '\\ea76' });
Codicon.x = new Codicon('x', { fontCharacter: '\\ea76' });
Codicon.repoSync = new Codicon('repo-sync', { fontCharacter: '\\ea77' });
Codicon.sync = new Codicon('sync', { fontCharacter: '\\ea77' });
Codicon.clone = new Codicon('clone', { fontCharacter: '\\ea78' });
Codicon.desktopDownload = new Codicon('desktop-download', { fontCharacter: '\\ea78' });
Codicon.beaker = new Codicon('beaker', { fontCharacter: '\\ea79' });
Codicon.microscope = new Codicon('microscope', { fontCharacter: '\\ea79' });
Codicon.vm = new Codicon('vm', { fontCharacter: '\\ea7a' });
Codicon.deviceDesktop = new Codicon('device-desktop', { fontCharacter: '\\ea7a' });
Codicon.file = new Codicon('file', { fontCharacter: '\\ea7b' });
Codicon.fileText = new Codicon('file-text', { fontCharacter: '\\ea7b' });
Codicon.more = new Codicon('more', { fontCharacter: '\\ea7c' });
Codicon.ellipsis = new Codicon('ellipsis', { fontCharacter: '\\ea7c' });
Codicon.kebabHorizontal = new Codicon('kebab-horizontal', { fontCharacter: '\\ea7c' });
Codicon.mailReply = new Codicon('mail-reply', { fontCharacter: '\\ea7d' });
Codicon.reply = new Codicon('reply', { fontCharacter: '\\ea7d' });
Codicon.organization = new Codicon('organization', { fontCharacter: '\\ea7e' });
Codicon.organizationFilled = new Codicon('organization-filled', { fontCharacter: '\\ea7e' });
Codicon.organizationOutline = new Codicon('organization-outline', { fontCharacter: '\\ea7e' });
Codicon.newFile = new Codicon('new-file', { fontCharacter: '\\ea7f' });
Codicon.fileAdd = new Codicon('file-add', { fontCharacter: '\\ea7f' });
Codicon.newFolder = new Codicon('new-folder', { fontCharacter: '\\ea80' });
Codicon.fileDirectoryCreate = new Codicon('file-directory-create', { fontCharacter: '\\ea80' });
Codicon.trash = new Codicon('trash', { fontCharacter: '\\ea81' });
Codicon.trashcan = new Codicon('trashcan', { fontCharacter: '\\ea81' });
Codicon.history = new Codicon('history', { fontCharacter: '\\ea82' });
Codicon.clock = new Codicon('clock', { fontCharacter: '\\ea82' });
Codicon.folder = new Codicon('folder', { fontCharacter: '\\ea83' });
Codicon.fileDirectory = new Codicon('file-directory', { fontCharacter: '\\ea83' });
Codicon.symbolFolder = new Codicon('symbol-folder', { fontCharacter: '\\ea83' });
Codicon.logoGithub = new Codicon('logo-github', { fontCharacter: '\\ea84' });
Codicon.markGithub = new Codicon('mark-github', { fontCharacter: '\\ea84' });
Codicon.github = new Codicon('github', { fontCharacter: '\\ea84' });
Codicon.terminal = new Codicon('terminal', { fontCharacter: '\\ea85' });
Codicon.console = new Codicon('console', { fontCharacter: '\\ea85' });
Codicon.repl = new Codicon('repl', { fontCharacter: '\\ea85' });
Codicon.zap = new Codicon('zap', { fontCharacter: '\\ea86' });
Codicon.symbolEvent = new Codicon('symbol-event', { fontCharacter: '\\ea86' });
Codicon.error = new Codicon('error', { fontCharacter: '\\ea87' });
Codicon.stop = new Codicon('stop', { fontCharacter: '\\ea87' });
Codicon.variable = new Codicon('variable', { fontCharacter: '\\ea88' });
Codicon.symbolVariable = new Codicon('symbol-variable', { fontCharacter: '\\ea88' });
Codicon.array = new Codicon('array', { fontCharacter: '\\ea8a' });
Codicon.symbolArray = new Codicon('symbol-array', { fontCharacter: '\\ea8a' });
Codicon.symbolModule = new Codicon('symbol-module', { fontCharacter: '\\ea8b' });
Codicon.symbolPackage = new Codicon('symbol-package', { fontCharacter: '\\ea8b' });
Codicon.symbolNamespace = new Codicon('symbol-namespace', { fontCharacter: '\\ea8b' });
Codicon.symbolObject = new Codicon('symbol-object', { fontCharacter: '\\ea8b' });
Codicon.symbolMethod = new Codicon('symbol-method', { fontCharacter: '\\ea8c' });
Codicon.symbolFunction = new Codicon('symbol-function', { fontCharacter: '\\ea8c' });
Codicon.symbolConstructor = new Codicon('symbol-constructor', { fontCharacter: '\\ea8c' });
Codicon.symbolBoolean = new Codicon('symbol-boolean', { fontCharacter: '\\ea8f' });
Codicon.symbolNull = new Codicon('symbol-null', { fontCharacter: '\\ea8f' });
Codicon.symbolNumeric = new Codicon('symbol-numeric', { fontCharacter: '\\ea90' });
Codicon.symbolNumber = new Codicon('symbol-number', { fontCharacter: '\\ea90' });
Codicon.symbolStructure = new Codicon('symbol-structure', { fontCharacter: '\\ea91' });
Codicon.symbolStruct = new Codicon('symbol-struct', { fontCharacter: '\\ea91' });
Codicon.symbolParameter = new Codicon('symbol-parameter', { fontCharacter: '\\ea92' });
Codicon.symbolTypeParameter = new Codicon('symbol-type-parameter', { fontCharacter: '\\ea92' });
Codicon.symbolKey = new Codicon('symbol-key', { fontCharacter: '\\ea93' });
Codicon.symbolText = new Codicon('symbol-text', { fontCharacter: '\\ea93' });
Codicon.symbolReference = new Codicon('symbol-reference', { fontCharacter: '\\ea94' });
Codicon.goToFile = new Codicon('go-to-file', { fontCharacter: '\\ea94' });
Codicon.symbolEnum = new Codicon('symbol-enum', { fontCharacter: '\\ea95' });
Codicon.symbolValue = new Codicon('symbol-value', { fontCharacter: '\\ea95' });
Codicon.symbolRuler = new Codicon('symbol-ruler', { fontCharacter: '\\ea96' });
Codicon.symbolUnit = new Codicon('symbol-unit', { fontCharacter: '\\ea96' });
Codicon.activateBreakpoints = new Codicon('activate-breakpoints', { fontCharacter: '\\ea97' });
Codicon.archive = new Codicon('archive', { fontCharacter: '\\ea98' });
Codicon.arrowBoth = new Codicon('arrow-both', { fontCharacter: '\\ea99' });
Codicon.arrowDown = new Codicon('arrow-down', { fontCharacter: '\\ea9a' });
Codicon.arrowLeft = new Codicon('arrow-left', { fontCharacter: '\\ea9b' });
Codicon.arrowRight = new Codicon('arrow-right', { fontCharacter: '\\ea9c' });
Codicon.arrowSmallDown = new Codicon('arrow-small-down', { fontCharacter: '\\ea9d' });
Codicon.arrowSmallLeft = new Codicon('arrow-small-left', { fontCharacter: '\\ea9e' });
Codicon.arrowSmallRight = new Codicon('arrow-small-right', { fontCharacter: '\\ea9f' });
Codicon.arrowSmallUp = new Codicon('arrow-small-up', { fontCharacter: '\\eaa0' });
Codicon.arrowUp = new Codicon('arrow-up', { fontCharacter: '\\eaa1' });
Codicon.bell = new Codicon('bell', { fontCharacter: '\\eaa2' });
Codicon.bold = new Codicon('bold', { fontCharacter: '\\eaa3' });
Codicon.book = new Codicon('book', { fontCharacter: '\\eaa4' });
Codicon.bookmark = new Codicon('bookmark', { fontCharacter: '\\eaa5' });
Codicon.debugBreakpointConditionalUnverified = new Codicon('debug-breakpoint-conditional-unverified', { fontCharacter: '\\eaa6' });
Codicon.debugBreakpointConditional = new Codicon('debug-breakpoint-conditional', { fontCharacter: '\\eaa7' });
Codicon.debugBreakpointConditionalDisabled = new Codicon('debug-breakpoint-conditional-disabled', { fontCharacter: '\\eaa7' });
Codicon.debugBreakpointDataUnverified = new Codicon('debug-breakpoint-data-unverified', { fontCharacter: '\\eaa8' });
Codicon.debugBreakpointData = new Codicon('debug-breakpoint-data', { fontCharacter: '\\eaa9' });
Codicon.debugBreakpointDataDisabled = new Codicon('debug-breakpoint-data-disabled', { fontCharacter: '\\eaa9' });
Codicon.debugBreakpointLogUnverified = new Codicon('debug-breakpoint-log-unverified', { fontCharacter: '\\eaaa' });
Codicon.debugBreakpointLog = new Codicon('debug-breakpoint-log', { fontCharacter: '\\eaab' });
Codicon.debugBreakpointLogDisabled = new Codicon('debug-breakpoint-log-disabled', { fontCharacter: '\\eaab' });
Codicon.briefcase = new Codicon('briefcase', { fontCharacter: '\\eaac' });
Codicon.broadcast = new Codicon('broadcast', { fontCharacter: '\\eaad' });
Codicon.browser = new Codicon('browser', { fontCharacter: '\\eaae' });
Codicon.bug = new Codicon('bug', { fontCharacter: '\\eaaf' });
Codicon.calendar = new Codicon('calendar', { fontCharacter: '\\eab0' });
Codicon.caseSensitive = new Codicon('case-sensitive', { fontCharacter: '\\eab1' });
Codicon.check = new Codicon('check', { fontCharacter: '\\eab2' });
Codicon.checklist = new Codicon('checklist', { fontCharacter: '\\eab3' });
Codicon.chevronDown = new Codicon('chevron-down', { fontCharacter: '\\eab4' });
Codicon.dropDownButton = new Codicon('drop-down-button', Codicon.chevronDown.definition);
Codicon.chevronLeft = new Codicon('chevron-left', { fontCharacter: '\\eab5' });
Codicon.chevronRight = new Codicon('chevron-right', { fontCharacter: '\\eab6' });
Codicon.chevronUp = new Codicon('chevron-up', { fontCharacter: '\\eab7' });
Codicon.chromeClose = new Codicon('chrome-close', { fontCharacter: '\\eab8' });
Codicon.chromeMaximize = new Codicon('chrome-maximize', { fontCharacter: '\\eab9' });
Codicon.chromeMinimize = new Codicon('chrome-minimize', { fontCharacter: '\\eaba' });
Codicon.chromeRestore = new Codicon('chrome-restore', { fontCharacter: '\\eabb' });
Codicon.circleOutline = new Codicon('circle-outline', { fontCharacter: '\\eabc' });
Codicon.debugBreakpointUnverified = new Codicon('debug-breakpoint-unverified', { fontCharacter: '\\eabc' });
Codicon.circleSlash = new Codicon('circle-slash', { fontCharacter: '\\eabd' });
Codicon.circuitBoard = new Codicon('circuit-board', { fontCharacter: '\\eabe' });
Codicon.clearAll = new Codicon('clear-all', { fontCharacter: '\\eabf' });
Codicon.clippy = new Codicon('clippy', { fontCharacter: '\\eac0' });
Codicon.closeAll = new Codicon('close-all', { fontCharacter: '\\eac1' });
Codicon.cloudDownload = new Codicon('cloud-download', { fontCharacter: '\\eac2' });
Codicon.cloudUpload = new Codicon('cloud-upload', { fontCharacter: '\\eac3' });
Codicon.code = new Codicon('code', { fontCharacter: '\\eac4' });
Codicon.collapseAll = new Codicon('collapse-all', { fontCharacter: '\\eac5' });
Codicon.colorMode = new Codicon('color-mode', { fontCharacter: '\\eac6' });
Codicon.commentDiscussion = new Codicon('comment-discussion', { fontCharacter: '\\eac7' });
Codicon.compareChanges = new Codicon('compare-changes', { fontCharacter: '\\eafd' });
Codicon.creditCard = new Codicon('credit-card', { fontCharacter: '\\eac9' });
Codicon.dash = new Codicon('dash', { fontCharacter: '\\eacc' });
Codicon.dashboard = new Codicon('dashboard', { fontCharacter: '\\eacd' });
Codicon.database = new Codicon('database', { fontCharacter: '\\eace' });
Codicon.debugContinue = new Codicon('debug-continue', { fontCharacter: '\\eacf' });
Codicon.debugDisconnect = new Codicon('debug-disconnect', { fontCharacter: '\\ead0' });
Codicon.debugPause = new Codicon('debug-pause', { fontCharacter: '\\ead1' });
Codicon.debugRestart = new Codicon('debug-restart', { fontCharacter: '\\ead2' });
Codicon.debugStart = new Codicon('debug-start', { fontCharacter: '\\ead3' });
Codicon.debugStepInto = new Codicon('debug-step-into', { fontCharacter: '\\ead4' });
Codicon.debugStepOut = new Codicon('debug-step-out', { fontCharacter: '\\ead5' });
Codicon.debugStepOver = new Codicon('debug-step-over', { fontCharacter: '\\ead6' });
Codicon.debugStop = new Codicon('debug-stop', { fontCharacter: '\\ead7' });
Codicon.debug = new Codicon('debug', { fontCharacter: '\\ead8' });
Codicon.deviceCameraVideo = new Codicon('device-camera-video', { fontCharacter: '\\ead9' });
Codicon.deviceCamera = new Codicon('device-camera', { fontCharacter: '\\eada' });
Codicon.deviceMobile = new Codicon('device-mobile', { fontCharacter: '\\eadb' });
Codicon.diffAdded = new Codicon('diff-added', { fontCharacter: '\\eadc' });
Codicon.diffIgnored = new Codicon('diff-ignored', { fontCharacter: '\\eadd' });
Codicon.diffModified = new Codicon('diff-modified', { fontCharacter: '\\eade' });
Codicon.diffRemoved = new Codicon('diff-removed', { fontCharacter: '\\eadf' });
Codicon.diffRenamed = new Codicon('diff-renamed', { fontCharacter: '\\eae0' });
Codicon.diff = new Codicon('diff', { fontCharacter: '\\eae1' });
Codicon.discard = new Codicon('discard', { fontCharacter: '\\eae2' });
Codicon.editorLayout = new Codicon('editor-layout', { fontCharacter: '\\eae3' });
Codicon.emptyWindow = new Codicon('empty-window', { fontCharacter: '\\eae4' });
Codicon.exclude = new Codicon('exclude', { fontCharacter: '\\eae5' });
Codicon.extensions = new Codicon('extensions', { fontCharacter: '\\eae6' });
Codicon.eyeClosed = new Codicon('eye-closed', { fontCharacter: '\\eae7' });
Codicon.fileBinary = new Codicon('file-binary', { fontCharacter: '\\eae8' });
Codicon.fileCode = new Codicon('file-code', { fontCharacter: '\\eae9' });
Codicon.fileMedia = new Codicon('file-media', { fontCharacter: '\\eaea' });
Codicon.filePdf = new Codicon('file-pdf', { fontCharacter: '\\eaeb' });
Codicon.fileSubmodule = new Codicon('file-submodule', { fontCharacter: '\\eaec' });
Codicon.fileSymlinkDirectory = new Codicon('file-symlink-directory', { fontCharacter: '\\eaed' });
Codicon.fileSymlinkFile = new Codicon('file-symlink-file', { fontCharacter: '\\eaee' });
Codicon.fileZip = new Codicon('file-zip', { fontCharacter: '\\eaef' });
Codicon.files = new Codicon('files', { fontCharacter: '\\eaf0' });
Codicon.filter = new Codicon('filter', { fontCharacter: '\\eaf1' });
Codicon.flame = new Codicon('flame', { fontCharacter: '\\eaf2' });
Codicon.foldDown = new Codicon('fold-down', { fontCharacter: '\\eaf3' });
Codicon.foldUp = new Codicon('fold-up', { fontCharacter: '\\eaf4' });
Codicon.fold = new Codicon('fold', { fontCharacter: '\\eaf5' });
Codicon.folderActive = new Codicon('folder-active', { fontCharacter: '\\eaf6' });
Codicon.folderOpened = new Codicon('folder-opened', { fontCharacter: '\\eaf7' });
Codicon.gear = new Codicon('gear', { fontCharacter: '\\eaf8' });
Codicon.gift = new Codicon('gift', { fontCharacter: '\\eaf9' });
Codicon.gistSecret = new Codicon('gist-secret', { fontCharacter: '\\eafa' });
Codicon.gist = new Codicon('gist', { fontCharacter: '\\eafb' });
Codicon.gitCommit = new Codicon('git-commit', { fontCharacter: '\\eafc' });
Codicon.gitCompare = new Codicon('git-compare', { fontCharacter: '\\eafd' });
Codicon.gitMerge = new Codicon('git-merge', { fontCharacter: '\\eafe' });
Codicon.githubAction = new Codicon('github-action', { fontCharacter: '\\eaff' });
Codicon.githubAlt = new Codicon('github-alt', { fontCharacter: '\\eb00' });
Codicon.globe = new Codicon('globe', { fontCharacter: '\\eb01' });
Codicon.grabber = new Codicon('grabber', { fontCharacter: '\\eb02' });
Codicon.graph = new Codicon('graph', { fontCharacter: '\\eb03' });
Codicon.gripper = new Codicon('gripper', { fontCharacter: '\\eb04' });
Codicon.heart = new Codicon('heart', { fontCharacter: '\\eb05' });
Codicon.home = new Codicon('home', { fontCharacter: '\\eb06' });
Codicon.horizontalRule = new Codicon('horizontal-rule', { fontCharacter: '\\eb07' });
Codicon.hubot = new Codicon('hubot', { fontCharacter: '\\eb08' });
Codicon.inbox = new Codicon('inbox', { fontCharacter: '\\eb09' });
Codicon.issueClosed = new Codicon('issue-closed', { fontCharacter: '\\eba4' });
Codicon.issueReopened = new Codicon('issue-reopened', { fontCharacter: '\\eb0b' });
Codicon.issues = new Codicon('issues', { fontCharacter: '\\eb0c' });
Codicon.italic = new Codicon('italic', { fontCharacter: '\\eb0d' });
Codicon.jersey = new Codicon('jersey', { fontCharacter: '\\eb0e' });
Codicon.json = new Codicon('json', { fontCharacter: '\\eb0f' });
Codicon.kebabVertical = new Codicon('kebab-vertical', { fontCharacter: '\\eb10' });
Codicon.key = new Codicon('key', { fontCharacter: '\\eb11' });
Codicon.law = new Codicon('law', { fontCharacter: '\\eb12' });
Codicon.lightbulbAutofix = new Codicon('lightbulb-autofix', { fontCharacter: '\\eb13' });
Codicon.linkExternal = new Codicon('link-external', { fontCharacter: '\\eb14' });
Codicon.link = new Codicon('link', { fontCharacter: '\\eb15' });
Codicon.listOrdered = new Codicon('list-ordered', { fontCharacter: '\\eb16' });
Codicon.listUnordered = new Codicon('list-unordered', { fontCharacter: '\\eb17' });
Codicon.liveShare = new Codicon('live-share', { fontCharacter: '\\eb18' });
Codicon.loading = new Codicon('loading', { fontCharacter: '\\eb19' });
Codicon.location = new Codicon('location', { fontCharacter: '\\eb1a' });
Codicon.mailRead = new Codicon('mail-read', { fontCharacter: '\\eb1b' });
Codicon.mail = new Codicon('mail', { fontCharacter: '\\eb1c' });
Codicon.markdown = new Codicon('markdown', { fontCharacter: '\\eb1d' });
Codicon.megaphone = new Codicon('megaphone', { fontCharacter: '\\eb1e' });
Codicon.mention = new Codicon('mention', { fontCharacter: '\\eb1f' });
Codicon.milestone = new Codicon('milestone', { fontCharacter: '\\eb20' });
Codicon.mortarBoard = new Codicon('mortar-board', { fontCharacter: '\\eb21' });
Codicon.move = new Codicon('move', { fontCharacter: '\\eb22' });
Codicon.multipleWindows = new Codicon('multiple-windows', { fontCharacter: '\\eb23' });
Codicon.mute = new Codicon('mute', { fontCharacter: '\\eb24' });
Codicon.noNewline = new Codicon('no-newline', { fontCharacter: '\\eb25' });
Codicon.note = new Codicon('note', { fontCharacter: '\\eb26' });
Codicon.octoface = new Codicon('octoface', { fontCharacter: '\\eb27' });
Codicon.openPreview = new Codicon('open-preview', { fontCharacter: '\\eb28' });
Codicon.package_ = new Codicon('package', { fontCharacter: '\\eb29' });
Codicon.paintcan = new Codicon('paintcan', { fontCharacter: '\\eb2a' });
Codicon.pin = new Codicon('pin', { fontCharacter: '\\eb2b' });
Codicon.play = new Codicon('play', { fontCharacter: '\\eb2c' });
Codicon.run = new Codicon('run', { fontCharacter: '\\eb2c' });
Codicon.plug = new Codicon('plug', { fontCharacter: '\\eb2d' });
Codicon.preserveCase = new Codicon('preserve-case', { fontCharacter: '\\eb2e' });
Codicon.preview = new Codicon('preview', { fontCharacter: '\\eb2f' });
Codicon.project = new Codicon('project', { fontCharacter: '\\eb30' });
Codicon.pulse = new Codicon('pulse', { fontCharacter: '\\eb31' });
Codicon.question = new Codicon('question', { fontCharacter: '\\eb32' });
Codicon.quote = new Codicon('quote', { fontCharacter: '\\eb33' });
Codicon.radioTower = new Codicon('radio-tower', { fontCharacter: '\\eb34' });
Codicon.reactions = new Codicon('reactions', { fontCharacter: '\\eb35' });
Codicon.references = new Codicon('references', { fontCharacter: '\\eb36' });
Codicon.refresh = new Codicon('refresh', { fontCharacter: '\\eb37' });
Codicon.regex = new Codicon('regex', { fontCharacter: '\\eb38' });
Codicon.remoteExplorer = new Codicon('remote-explorer', { fontCharacter: '\\eb39' });
Codicon.remote = new Codicon('remote', { fontCharacter: '\\eb3a' });
Codicon.remove = new Codicon('remove', { fontCharacter: '\\eb3b' });
Codicon.replaceAll = new Codicon('replace-all', { fontCharacter: '\\eb3c' });
Codicon.replace = new Codicon('replace', { fontCharacter: '\\eb3d' });
Codicon.repoClone = new Codicon('repo-clone', { fontCharacter: '\\eb3e' });
Codicon.repoForcePush = new Codicon('repo-force-push', { fontCharacter: '\\eb3f' });
Codicon.repoPull = new Codicon('repo-pull', { fontCharacter: '\\eb40' });
Codicon.repoPush = new Codicon('repo-push', { fontCharacter: '\\eb41' });
Codicon.report = new Codicon('report', { fontCharacter: '\\eb42' });
Codicon.requestChanges = new Codicon('request-changes', { fontCharacter: '\\eb43' });
Codicon.rocket = new Codicon('rocket', { fontCharacter: '\\eb44' });
Codicon.rootFolderOpened = new Codicon('root-folder-opened', { fontCharacter: '\\eb45' });
Codicon.rootFolder = new Codicon('root-folder', { fontCharacter: '\\eb46' });
Codicon.rss = new Codicon('rss', { fontCharacter: '\\eb47' });
Codicon.ruby = new Codicon('ruby', { fontCharacter: '\\eb48' });
Codicon.saveAll = new Codicon('save-all', { fontCharacter: '\\eb49' });
Codicon.saveAs = new Codicon('save-as', { fontCharacter: '\\eb4a' });
Codicon.save = new Codicon('save', { fontCharacter: '\\eb4b' });
Codicon.screenFull = new Codicon('screen-full', { fontCharacter: '\\eb4c' });
Codicon.screenNormal = new Codicon('screen-normal', { fontCharacter: '\\eb4d' });
Codicon.searchStop = new Codicon('search-stop', { fontCharacter: '\\eb4e' });
Codicon.server = new Codicon('server', { fontCharacter: '\\eb50' });
Codicon.settingsGear = new Codicon('settings-gear', { fontCharacter: '\\eb51' });
Codicon.settings = new Codicon('settings', { fontCharacter: '\\eb52' });
Codicon.shield = new Codicon('shield', { fontCharacter: '\\eb53' });
Codicon.smiley = new Codicon('smiley', { fontCharacter: '\\eb54' });
Codicon.sortPrecedence = new Codicon('sort-precedence', { fontCharacter: '\\eb55' });
Codicon.splitHorizontal = new Codicon('split-horizontal', { fontCharacter: '\\eb56' });
Codicon.splitVertical = new Codicon('split-vertical', { fontCharacter: '\\eb57' });
Codicon.squirrel = new Codicon('squirrel', { fontCharacter: '\\eb58' });
Codicon.starFull = new Codicon('star-full', { fontCharacter: '\\eb59' });
Codicon.starHalf = new Codicon('star-half', { fontCharacter: '\\eb5a' });
Codicon.symbolClass = new Codicon('symbol-class', { fontCharacter: '\\eb5b' });
Codicon.symbolColor = new Codicon('symbol-color', { fontCharacter: '\\eb5c' });
Codicon.symbolCustomColor = new Codicon('symbol-customcolor', { fontCharacter: '\\eb5c' });
Codicon.symbolConstant = new Codicon('symbol-constant', { fontCharacter: '\\eb5d' });
Codicon.symbolEnumMember = new Codicon('symbol-enum-member', { fontCharacter: '\\eb5e' });
Codicon.symbolField = new Codicon('symbol-field', { fontCharacter: '\\eb5f' });
Codicon.symbolFile = new Codicon('symbol-file', { fontCharacter: '\\eb60' });
Codicon.symbolInterface = new Codicon('symbol-interface', { fontCharacter: '\\eb61' });
Codicon.symbolKeyword = new Codicon('symbol-keyword', { fontCharacter: '\\eb62' });
Codicon.symbolMisc = new Codicon('symbol-misc', { fontCharacter: '\\eb63' });
Codicon.symbolOperator = new Codicon('symbol-operator', { fontCharacter: '\\eb64' });
Codicon.symbolProperty = new Codicon('symbol-property', { fontCharacter: '\\eb65' });
Codicon.wrench = new Codicon('wrench', { fontCharacter: '\\eb65' });
Codicon.wrenchSubaction = new Codicon('wrench-subaction', { fontCharacter: '\\eb65' });
Codicon.symbolSnippet = new Codicon('symbol-snippet', { fontCharacter: '\\eb66' });
Codicon.tasklist = new Codicon('tasklist', { fontCharacter: '\\eb67' });
Codicon.telescope = new Codicon('telescope', { fontCharacter: '\\eb68' });
Codicon.textSize = new Codicon('text-size', { fontCharacter: '\\eb69' });
Codicon.threeBars = new Codicon('three-bars', { fontCharacter: '\\eb6a' });
Codicon.thumbsdown = new Codicon('thumbsdown', { fontCharacter: '\\eb6b' });
Codicon.thumbsup = new Codicon('thumbsup', { fontCharacter: '\\eb6c' });
Codicon.tools = new Codicon('tools', { fontCharacter: '\\eb6d' });
Codicon.triangleDown = new Codicon('triangle-down', { fontCharacter: '\\eb6e' });
Codicon.triangleLeft = new Codicon('triangle-left', { fontCharacter: '\\eb6f' });
Codicon.triangleRight = new Codicon('triangle-right', { fontCharacter: '\\eb70' });
Codicon.triangleUp = new Codicon('triangle-up', { fontCharacter: '\\eb71' });
Codicon.twitter = new Codicon('twitter', { fontCharacter: '\\eb72' });
Codicon.unfold = new Codicon('unfold', { fontCharacter: '\\eb73' });
Codicon.unlock = new Codicon('unlock', { fontCharacter: '\\eb74' });
Codicon.unmute = new Codicon('unmute', { fontCharacter: '\\eb75' });
Codicon.unverified = new Codicon('unverified', { fontCharacter: '\\eb76' });
Codicon.verified = new Codicon('verified', { fontCharacter: '\\eb77' });
Codicon.versions = new Codicon('versions', { fontCharacter: '\\eb78' });
Codicon.vmActive = new Codicon('vm-active', { fontCharacter: '\\eb79' });
Codicon.vmOutline = new Codicon('vm-outline', { fontCharacter: '\\eb7a' });
Codicon.vmRunning = new Codicon('vm-running', { fontCharacter: '\\eb7b' });
Codicon.watch = new Codicon('watch', { fontCharacter: '\\eb7c' });
Codicon.whitespace = new Codicon('whitespace', { fontCharacter: '\\eb7d' });
Codicon.wholeWord = new Codicon('whole-word', { fontCharacter: '\\eb7e' });
Codicon.window = new Codicon('window', { fontCharacter: '\\eb7f' });
Codicon.wordWrap = new Codicon('word-wrap', { fontCharacter: '\\eb80' });
Codicon.zoomIn = new Codicon('zoom-in', { fontCharacter: '\\eb81' });
Codicon.zoomOut = new Codicon('zoom-out', { fontCharacter: '\\eb82' });
Codicon.listFilter = new Codicon('list-filter', { fontCharacter: '\\eb83' });
Codicon.listFlat = new Codicon('list-flat', { fontCharacter: '\\eb84' });
Codicon.listSelection = new Codicon('list-selection', { fontCharacter: '\\eb85' });
Codicon.selection = new Codicon('selection', { fontCharacter: '\\eb85' });
Codicon.listTree = new Codicon('list-tree', { fontCharacter: '\\eb86' });
Codicon.debugBreakpointFunctionUnverified = new Codicon('debug-breakpoint-function-unverified', { fontCharacter: '\\eb87' });
Codicon.debugBreakpointFunction = new Codicon('debug-breakpoint-function', { fontCharacter: '\\eb88' });
Codicon.debugBreakpointFunctionDisabled = new Codicon('debug-breakpoint-function-disabled', { fontCharacter: '\\eb88' });
Codicon.debugStackframeActive = new Codicon('debug-stackframe-active', { fontCharacter: '\\eb89' });
Codicon.debugStackframeDot = new Codicon('debug-stackframe-dot', { fontCharacter: '\\eb8a' });
Codicon.debugStackframe = new Codicon('debug-stackframe', { fontCharacter: '\\eb8b' });
Codicon.debugStackframeFocused = new Codicon('debug-stackframe-focused', { fontCharacter: '\\eb8b' });
Codicon.debugBreakpointUnsupported = new Codicon('debug-breakpoint-unsupported', { fontCharacter: '\\eb8c' });
Codicon.symbolString = new Codicon('symbol-string', { fontCharacter: '\\eb8d' });
Codicon.debugReverseContinue = new Codicon('debug-reverse-continue', { fontCharacter: '\\eb8e' });
Codicon.debugStepBack = new Codicon('debug-step-back', { fontCharacter: '\\eb8f' });
Codicon.debugRestartFrame = new Codicon('debug-restart-frame', { fontCharacter: '\\eb90' });
Codicon.callIncoming = new Codicon('call-incoming', { fontCharacter: '\\eb92' });
Codicon.callOutgoing = new Codicon('call-outgoing', { fontCharacter: '\\eb93' });
Codicon.menu = new Codicon('menu', { fontCharacter: '\\eb94' });
Codicon.expandAll = new Codicon('expand-all', { fontCharacter: '\\eb95' });
Codicon.feedback = new Codicon('feedback', { fontCharacter: '\\eb96' });
Codicon.groupByRefType = new Codicon('group-by-ref-type', { fontCharacter: '\\eb97' });
Codicon.ungroupByRefType = new Codicon('ungroup-by-ref-type', { fontCharacter: '\\eb98' });
Codicon.account = new Codicon('account', { fontCharacter: '\\eb99' });
Codicon.bellDot = new Codicon('bell-dot', { fontCharacter: '\\eb9a' });
Codicon.debugConsole = new Codicon('debug-console', { fontCharacter: '\\eb9b' });
Codicon.library = new Codicon('library', { fontCharacter: '\\eb9c' });
Codicon.output = new Codicon('output', { fontCharacter: '\\eb9d' });
Codicon.runAll = new Codicon('run-all', { fontCharacter: '\\eb9e' });
Codicon.syncIgnored = new Codicon('sync-ignored', { fontCharacter: '\\eb9f' });
Codicon.pinned = new Codicon('pinned', { fontCharacter: '\\eba0' });
Codicon.githubInverted = new Codicon('github-inverted', { fontCharacter: '\\eba1' });
Codicon.debugAlt = new Codicon('debug-alt', { fontCharacter: '\\eb91' });
Codicon.serverProcess = new Codicon('server-process', { fontCharacter: '\\eba2' });
Codicon.serverEnvironment = new Codicon('server-environment', { fontCharacter: '\\eba3' });
Codicon.pass = new Codicon('pass', { fontCharacter: '\\eba4' });
Codicon.stopCircle = new Codicon('stop-circle', { fontCharacter: '\\eba5' });
Codicon.playCircle = new Codicon('play-circle', { fontCharacter: '\\eba6' });
Codicon.record = new Codicon('record', { fontCharacter: '\\eba7' });
Codicon.debugAltSmall = new Codicon('debug-alt-small', { fontCharacter: '\\eba8' });
Codicon.vmConnect = new Codicon('vm-connect', { fontCharacter: '\\eba9' });
Codicon.cloud = new Codicon('cloud', { fontCharacter: '\\ebaa' });
Codicon.merge = new Codicon('merge', { fontCharacter: '\\ebab' });
Codicon.exportIcon = new Codicon('export', { fontCharacter: '\\ebac' });
Codicon.graphLeft = new Codicon('graph-left', { fontCharacter: '\\ebad' });
Codicon.magnet = new Codicon('magnet', { fontCharacter: '\\ebae' });
Codicon.notebook = new Codicon('notebook', { fontCharacter: '\\ebaf' });
Codicon.redo = new Codicon('redo', { fontCharacter: '\\ebb0' });
Codicon.checkAll = new Codicon('check-all', { fontCharacter: '\\ebb1' });
Codicon.pinnedDirty = new Codicon('pinned-dirty', { fontCharacter: '\\ebb2' });
Codicon.passFilled = new Codicon('pass-filled', { fontCharacter: '\\ebb3' });
Codicon.circleLargeFilled = new Codicon('circle-large-filled', { fontCharacter: '\\ebb4' });
Codicon.circleLargeOutline = new Codicon('circle-large-outline', { fontCharacter: '\\ebb5' });
Codicon.combine = new Codicon('combine', { fontCharacter: '\\ebb6' });
Codicon.gather = new Codicon('gather', { fontCharacter: '\\ebb6' });
Codicon.table = new Codicon('table', { fontCharacter: '\\ebb7' });
Codicon.variableGroup = new Codicon('variable-group', { fontCharacter: '\\ebb8' });
Codicon.typeHierarchy = new Codicon('type-hierarchy', { fontCharacter: '\\ebb9' });
Codicon.typeHierarchySub = new Codicon('type-hierarchy-sub', { fontCharacter: '\\ebba' });
Codicon.typeHierarchySuper = new Codicon('type-hierarchy-super', { fontCharacter: '\\ebbb' });
Codicon.gitPullRequestCreate = new Codicon('git-pull-request-create', { fontCharacter: '\\ebbc' });
Codicon.runAbove = new Codicon('run-above', { fontCharacter: '\\ebbd' });
Codicon.runBelow = new Codicon('run-below', { fontCharacter: '\\ebbe' });
Codicon.notebookTemplate = new Codicon('notebook-template', { fontCharacter: '\\ebbf' });
Codicon.debugRerun = new Codicon('debug-rerun', { fontCharacter: '\\ebc0' });
Codicon.workspaceTrusted = new Codicon('workspace-trusted', { fontCharacter: '\\ebc1' });
Codicon.workspaceUntrusted = new Codicon('workspace-untrusted', { fontCharacter: '\\ebc2' });
Codicon.workspaceUnspecified = new Codicon('workspace-unspecified', { fontCharacter: '\\ebc3' });
Codicon.terminalCmd = new Codicon('terminal-cmd', { fontCharacter: '\\ebc4' });
Codicon.terminalDebian = new Codicon('terminal-debian', { fontCharacter: '\\ebc5' });
Codicon.terminalLinux = new Codicon('terminal-linux', { fontCharacter: '\\ebc6' });
Codicon.terminalPowershell = new Codicon('terminal-powershell', { fontCharacter: '\\ebc7' });
Codicon.terminalTmux = new Codicon('terminal-tmux', { fontCharacter: '\\ebc8' });
Codicon.terminalUbuntu = new Codicon('terminal-ubuntu', { fontCharacter: '\\ebc9' });
Codicon.terminalBash = new Codicon('terminal-bash', { fontCharacter: '\\ebca' });
Codicon.arrowSwap = new Codicon('arrow-swap', { fontCharacter: '\\ebcb' });
Codicon.copy = new Codicon('copy', { fontCharacter: '\\ebcc' });
Codicon.personAdd = new Codicon('person-add', { fontCharacter: '\\ebcd' });
Codicon.filterFilled = new Codicon('filter-filled', { fontCharacter: '\\ebce' });
Codicon.wand = new Codicon('wand', { fontCharacter: '\\ebcf' });
Codicon.debugLineByLine = new Codicon('debug-line-by-line', { fontCharacter: '\\ebd0' });
Codicon.inspect = new Codicon('inspect', { fontCharacter: '\\ebd1' });
Codicon.layers = new Codicon('layers', { fontCharacter: '\\ebd2' });
Codicon.layersDot = new Codicon('layers-dot', { fontCharacter: '\\ebd3' });
Codicon.layersActive = new Codicon('layers-active', { fontCharacter: '\\ebd4' });
Codicon.compass = new Codicon('compass', { fontCharacter: '\\ebd5' });
Codicon.compassDot = new Codicon('compass-dot', { fontCharacter: '\\ebd6' });
Codicon.compassActive = new Codicon('compass-active', { fontCharacter: '\\ebd7' });
Codicon.azure = new Codicon('azure', { fontCharacter: '\\ebd8' });
Codicon.issueDraft = new Codicon('issue-draft', { fontCharacter: '\\ebd9' });
Codicon.gitPullRequestClosed = new Codicon('git-pull-request-closed', { fontCharacter: '\\ebda' });
Codicon.gitPullRequestDraft = new Codicon('git-pull-request-draft', { fontCharacter: '\\ebdb' });
Codicon.debugAll = new Codicon('debug-all', { fontCharacter: '\\ebdc' });
Codicon.debugCoverage = new Codicon('debug-coverage', { fontCharacter: '\\ebdd' });
Codicon.runErrors = new Codicon('run-errors', { fontCharacter: '\\ebde' });
Codicon.folderLibrary = new Codicon('folder-library', { fontCharacter: '\\ebdf' });
Codicon.debugContinueSmall = new Codicon('debug-continue-small', { fontCharacter: '\\ebe0' });
Codicon.beakerStop = new Codicon('beaker-stop', { fontCharacter: '\\ebe1' });
Codicon.graphLine = new Codicon('graph-line', { fontCharacter: '\\ebe2' });
Codicon.graphScatter = new Codicon('graph-scatter', { fontCharacter: '\\ebe3' });
Codicon.pieChart = new Codicon('pie-chart', { fontCharacter: '\\ebe4' });
Codicon.bracket = new Codicon('bracket', Codicon.json.definition);
Codicon.bracketDot = new Codicon('bracket-dot', { fontCharacter: '\\ebe5' });
Codicon.bracketError = new Codicon('bracket-error', { fontCharacter: '\\ebe6' });
Codicon.lockSmall = new Codicon('lock-small', { fontCharacter: '\\ebe7' });
Codicon.azureDevops = new Codicon('azure-devops', { fontCharacter: '\\ebe8' });
Codicon.verifiedFilled = new Codicon('verified-filled', { fontCharacter: '\\ebe9' });
Codicon.newLine = new Codicon('newline', { fontCharacter: '\\ebea' });
Codicon.layout = new Codicon('layout', { fontCharacter: '\\ebeb' });
Codicon.layoutActivitybarLeft = new Codicon('layout-activitybar-left', { fontCharacter: '\\ebec' });
Codicon.layoutActivitybarRight = new Codicon('layout-activitybar-right', { fontCharacter: '\\ebed' });
Codicon.layoutPanelLeft = new Codicon('layout-panel-left', { fontCharacter: '\\ebee' });
Codicon.layoutPanelCenter = new Codicon('layout-panel-center', { fontCharacter: '\\ebef' });
Codicon.layoutPanelJustify = new Codicon('layout-panel-justify', { fontCharacter: '\\ebf0' });
Codicon.layoutPanelRight = new Codicon('layout-panel-right', { fontCharacter: '\\ebf1' });
Codicon.layoutPanel = new Codicon('layout-panel', { fontCharacter: '\\ebf2' });
Codicon.layoutSidebarLeft = new Codicon('layout-sidebar-left', { fontCharacter: '\\ebf3' });
Codicon.layoutSidebarRight = new Codicon('layout-sidebar-right', { fontCharacter: '\\ebf4' });
Codicon.layoutStatusbar = new Codicon('layout-statusbar', { fontCharacter: '\\ebf5' });
Codicon.layoutMenubar = new Codicon('layout-menubar', { fontCharacter: '\\ebf6' });
Codicon.layoutCentered = new Codicon('layout-centered', { fontCharacter: '\\ebf7' });
Codicon.target = new Codicon('target', { fontCharacter: '\\ebf8' });
Codicon.indent = new Codicon('indent', { fontCharacter: '\\ebf9' });
Codicon.recordSmall = new Codicon('record-small', { fontCharacter: '\\ebfa' });
Codicon.errorSmall = new Codicon('error-small', { fontCharacter: '\\ebfb' });
Codicon.arrowCircleDown = new Codicon('arrow-circle-down', { fontCharacter: '\\ebfc' });
Codicon.arrowCircleLeft = new Codicon('arrow-circle-left', { fontCharacter: '\\ebfd' });
Codicon.arrowCircleRight = new Codicon('arrow-circle-right', { fontCharacter: '\\ebfe' });
Codicon.arrowCircleUp = new Codicon('arrow-circle-up', { fontCharacter: '\\ebff' });
// derived icons, that could become separate icons
Codicon.dialogError = new Codicon('dialog-error', Codicon.error.definition);
Codicon.dialogWarning = new Codicon('dialog-warning', Codicon.warning.definition);
Codicon.dialogInfo = new Codicon('dialog-info', Codicon.info.definition);
Codicon.dialogClose = new Codicon('dialog-close', Codicon.close.definition);
Codicon.treeItemExpanded = new Codicon('tree-item-expanded', Codicon.chevronDown.definition); // collapsed is done with rotation
Codicon.treeFilterOnTypeOn = new Codicon('tree-filter-on-type-on', Codicon.listFilter.definition);
Codicon.treeFilterOnTypeOff = new Codicon('tree-filter-on-type-off', Codicon.listSelection.definition);
Codicon.treeFilterClear = new Codicon('tree-filter-clear', Codicon.close.definition);
Codicon.treeItemLoading = new Codicon('tree-item-loading', Codicon.loading.definition);
Codicon.menuSelection = new Codicon('menu-selection', Codicon.check.definition);
Codicon.menuSubmenu = new Codicon('menu-submenu', Codicon.chevronRight.definition);
Codicon.menuBarMore = new Codicon('menubar-more', Codicon.more.definition);
Codicon.scrollbarButtonLeft = new Codicon('scrollbar-button-left', Codicon.triangleLeft.definition);
Codicon.scrollbarButtonRight = new Codicon('scrollbar-button-right', Codicon.triangleRight.definition);
Codicon.scrollbarButtonUp = new Codicon('scrollbar-button-up', Codicon.triangleUp.definition);
Codicon.scrollbarButtonDown = new Codicon('scrollbar-button-down', Codicon.triangleDown.definition);
Codicon.toolBarMore = new Codicon('toolbar-more', Codicon.more.definition);
Codicon.quickInputBack = new Codicon('quick-input-back', Codicon.arrowLeft.definition);
var CSSIcon;
(function (CSSIcon) {
    CSSIcon.iconNameSegment = '[A-Za-z0-9]+';
    CSSIcon.iconNameExpression = '[A-Za-z0-9-]+';
    CSSIcon.iconModifierExpression = '~[A-Za-z]+';
    CSSIcon.iconNameCharacter = '[A-Za-z0-9~-]';
    const cssIconIdRegex = new RegExp(`^(${CSSIcon.iconNameExpression})(${CSSIcon.iconModifierExpression})?$`);
    function asClassNameArray(icon) {
        if (icon instanceof Codicon) {
            return ['codicon', 'codicon-' + icon.id];
        }
        const match = cssIconIdRegex.exec(icon.id);
        if (!match) {
            return asClassNameArray(Codicon.error);
        }
        let [, id, modifier] = match;
        const classNames = ['codicon', 'codicon-' + id];
        if (modifier) {
            classNames.push('codicon-modifier-' + modifier.substr(1));
        }
        return classNames;
    }
    CSSIcon.asClassNameArray = asClassNameArray;
    function asClassName(icon) {
        return asClassNameArray(icon).join(' ');
    }
    CSSIcon.asClassName = asClassName;
    function asCSSSelector(icon) {
        return '.' + asClassNameArray(icon).join('.');
    }
    CSSIcon.asCSSSelector = asCSSSelector;
})(CSSIcon || (CSSIcon = {}));


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* binding */ Debug),
/* harmony export */   "LcsDiff": () => (/* binding */ LcsDiff),
/* harmony export */   "MyArray": () => (/* binding */ MyArray),
/* harmony export */   "StringDiffSequence": () => (/* binding */ StringDiffSequence),
/* harmony export */   "stringDiff": () => (/* binding */ stringDiff)
/* harmony export */ });
/* harmony import */ var _diffChange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffChange.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js");
/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hash.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class StringDiffSequence {
    constructor(source) {
        this.source = source;
    }
    getElements() {
        const source = this.source;
        const characters = new Int32Array(source.length);
        for (let i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
        }
        return characters;
    }
}
function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
//
// The code below has been ported from a C# implementation in VS
//
class Debug {
    static Assert(condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    }
}
class MyArray {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (let i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
}
/**
 * A utility class which helps to create the set of DiffChanges from
 * a difference operation. This class accepts original DiffElements and
 * modified DiffElements that are involved in a particular change. The
 * MarkNextChange() method can be called to mark the separation between
 * distinct changes. At the end, the Changes property can be called to retrieve
 * the constructed changes.
 */
class DiffChangeHelper {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
        this.m_changes = [];
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
        // Only add to the list if there is something to add
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Add the new change to our list
            this.m_changes.push(new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        // Reset for the next change
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
    }
}
/**
 * An implementation of the difference algorithm described in
 * "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
 */
class LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        this._originalSequence = originalSequence;
        this._modifiedSequence = modifiedSequence;
        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);
        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);
        this._hasStrings = (originalHasStrings && modifiedHasStrings);
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
        return (arr.length > 0 && typeof arr[0] === 'string');
    }
    static _getElements(sequence) {
        const elements = sequence.getElements();
        if (LcsDiff._isStringArray(elements)) {
            const hashes = new Int32Array(elements.length);
            for (let i = 0, len = elements.length; i < len; i++) {
                hashes[i] = (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.stringHash)(elements[i], 0);
            }
            return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
            return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
        if (!this.ElementsAreEqual(originalIndex, newIndex)) {
            return false;
        }
        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);
        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
        return (originalElement === modifiedElement);
    }
    static _getStrictElement(sequence, index) {
        if (typeof sequence.getStrictElement === 'function') {
            return sequence.getStrictElement(index);
        }
        return null;
    }
    OriginalElementsAreEqual(index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);
    }
    ModifiedElementsAreEqual(index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);
    }
    ComputeDiff(pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        const quitEarlyArr = [false];
        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
            // We have to clean up the computed diff to be more intuitive
            // but it turns out this cannot be done correctly until the entire set
            // of diffs have been computed
            changes = this.PrettifyChanges(changes);
        }
        return {
            quitEarly: quitEarlyArr[0],
            changes: changes
        };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        // Find the start of the differences
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
        }
        // Find the end of the differences
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
        }
        // In the special case where we either have all insertions or all deletions or the sequences are identical
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            let changes;
            if (modifiedStart <= modifiedEnd) {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                // All insertions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
            }
            else if (originalStart <= originalEnd) {
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // All deletions
                changes = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                ];
            }
            else {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // Identical sequences - No differences
                changes = [];
            }
            return changes;
        }
        // This problem can be solved using the Divide-And-Conquer technique.
        const midOriginalArr = [0];
        const midModifiedArr = [0];
        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        const midOriginal = midOriginalArr[0];
        const midModified = midModifiedArr[0];
        if (result !== null) {
            // Result is not-null when there was enough memory to compute the changes while
            // searching for the recursion point
            return result;
        }
        else if (!quitEarlyArr[0]) {
            // We can break the problem down recursively by finding the changes in the
            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            let rightChanges = [];
            if (!quitEarlyArr[0]) {
                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            }
            else {
                // We didn't have time to finish the first half, so we don't have time to compute this half.
                // Consider the entire rest of the sequence different.
                rightChanges = [
                    new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        // If we hit here, we quit early, and so can't return anything meaningful
        return [
            new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        let forwardChanges = null;
        let reverseChanges = null;
        // First, walk backward through the forward diagonals history
        let changeHelper = new DiffChangeHelper();
        let diagonalMin = diagonalForwardStart;
        let diagonalMax = diagonalForwardEnd;
        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;
        let historyIndex = this.m_forwardHistory.length - 1;
        do {
            // Get the diagonal index from the relative diagonal number
            const diagonal = diagonalRelative + diagonalForwardBase;
            // Figure out where we came from
            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                // Vertical line (the element is an insert)
                originalIndex = forwardPoints[diagonal + 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
            }
            else {
                // Horizontal line (the element is a deletion)
                originalIndex = forwardPoints[diagonal - 1] + 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex - 1;
                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
            }
            if (historyIndex >= 0) {
                forwardPoints = this.m_forwardHistory[historyIndex];
                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                diagonalMin = 1;
                diagonalMax = forwardPoints.length - 1;
            }
        } while (--historyIndex >= -1);
        // Ironically, we get the forward changes as the reverse of the
        // order we added them since we technically added them backwards
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
            // TODO: Calculate a partial from the reverse diagonals.
            //       For now, just assume everything after the midOriginal/midModified point is a diff
            let originalStartPoint = midOriginalArr[0] + 1;
            let modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
                const lastForwardChange = forwardChanges[forwardChanges.length - 1];
                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
                new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
        }
        else {
            // Now walk backward through the reverse diagonals history
            changeHelper = new DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
                // Get the diagonal index from the relative diagonal number
                const diagonal = diagonalRelative + diagonalReverseBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    // Horizontal line (the element is a deletion))
                    originalIndex = reversePoints[diagonal + 1] - 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex + 1;
                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                }
                else {
                    // Vertical line (the element is an insertion)
                    originalIndex = reversePoints[diagonal - 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    reversePoints = this.m_reverseHistory[historyIndex];
                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = reversePoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // There are cases where the reverse history will find diffs that
            // are correct, but not intuitive, so we need shift them.
            reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        let originalIndex = 0, modifiedIndex = 0;
        let diagonalForwardStart = 0, diagonalForwardEnd = 0;
        let diagonalReverseStart = 0, diagonalReverseEnd = 0;
        // To traverse the edit graph and produce the proper LCS, our actual
        // start position is just outside the given boundary
        originalStart--;
        modifiedStart--;
        // We set these up to make the compiler happy, but they will
        // be replaced before we return with the actual recursion point
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        // Clear out the history
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        // Each cell in the two arrays corresponds to a diagonal in the edit graph.
        // The integer value in the cell represents the originalIndex of the furthest
        // reaching point found so far that ends in that diagonal.
        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
        const numDiagonals = maxDifferences + 1;
        const forwardPoints = new Int32Array(numDiagonals);
        const reversePoints = new Int32Array(numDiagonals);
        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
        const diagonalForwardBase = (modifiedEnd - modifiedStart);
        const diagonalReverseBase = (originalEnd - originalStart);
        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalForwardBase)
        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalReverseBase)
        const diagonalForwardOffset = (originalStart - modifiedStart);
        const diagonalReverseOffset = (originalEnd - modifiedEnd);
        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
        const delta = diagonalReverseBase - diagonalForwardBase;
        const deltaIsEven = (delta % 2 === 0);
        // Here we set up the start and end points as the furthest points found so far
        // in both the forward and reverse directions, respectively
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
        quitEarlyArr[0] = false;
        // A couple of points:
        // --With this method, we iterate on the number of differences between the two sequences.
        //   The more differences there actually are, the longer this will take.
        // --Also, as the number of differences increases, we have to search on diagonals further
        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
        //   is even and odd diagonals only when numDifferences is odd.
        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
            let furthestOriginalIndex = 0;
            let furthestModifiedIndex = 0;
            // Run the algorithm in the forward direction
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalStart, modifiedStart)
                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    originalIndex = forwardPoints[diagonal + 1];
                }
                else {
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                }
                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                // Save the current originalIndex so we can test for false overlap in step 3
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // so long as the elements are equal.
                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                    originalIndex++;
                    modifiedIndex++;
                }
                forwardPoints[diagonal] = originalIndex;
                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                    furthestOriginalIndex = originalIndex;
                    furthestModifiedIndex = modifiedIndex;
                }
                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                // then check for overlap.
                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                    if (originalIndex >= reversePoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Check to see if we should be quitting early, before moving on to the next iteration.
            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
                // We can't finish, so skip ahead to generating a result from what we have.
                quitEarlyArr[0] = true;
                // Use the furthest distance we got in the forward direction.
                midOriginalArr[0] = furthestOriginalIndex;
                midModifiedArr[0] = furthestModifiedIndex;
                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                    // Enough of the history is in memory to walk it backwards
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                }
                else {
                    // We didn't actually remember enough of the history.
                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start
                    //back into the boundary limits since we decremented their value above beyond the boundary limit.
                    originalStart++;
                    modifiedStart++;
                    return [
                        new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
            }
            // Run the algorithm in the reverse direction
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalEnd, modifiedEnd)
                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    originalIndex = reversePoints[diagonal + 1] - 1;
                }
                else {
                    originalIndex = reversePoints[diagonal - 1];
                }
                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                // Save the current originalIndex so we can test for false overlap
                const tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // as long as the elements are equal.
                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                    originalIndex--;
                    modifiedIndex--;
                }
                reversePoints[diagonal] = originalIndex;
                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                // and diagonal is in the range of forward diagonals computed for numDifferences
                // then check for overlap.
                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                    if (originalIndex <= forwardPoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Save current vectors to history before the next iteration
            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {
                // We are allocating space for one extra int, which we fill with
                // the index of the diagonal base index
                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                this.m_forwardHistory.push(temp);
                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                this.m_reverseHistory.push(temp);
            }
        }
        // If we got here, then we have the full trace in history. We just have to convert it to a change list
        // NOTE: This part is a bit messy
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
        // Shift all the changes down first
        for (let i = 0; i < changes.length; i++) {
            const change = changes[i];
            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop
                && change.modifiedStart + change.modifiedLength < modifiedStop
                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))
                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
                if (endStrictEqual && !startStrictEqual) {
                    // moving the change down would create an equal change, but the elements are not strict equal
                    break;
                }
                change.originalStart++;
                change.modifiedStart++;
            }
            let mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
                changes[i] = mergedChangeArr[0];
                changes.splice(i + 1, 1);
                i--;
                continue;
            }
        }
        // Shift changes back up until we hit empty or whitespace-only lines
        for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            let originalStop = 0;
            let modifiedStop = 0;
            if (i > 0) {
                const prevChange = changes[i - 1];
                originalStop = prevChange.originalStart + prevChange.originalLength;
                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
            }
            const checkOriginal = change.originalLength > 0;
            const checkModified = change.modifiedLength > 0;
            let bestDelta = 0;
            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (let delta = 1;; delta++) {
                const originalStart = change.originalStart - delta;
                const modifiedStart = change.modifiedStart - delta;
                if (originalStart < originalStop || modifiedStart < modifiedStop) {
                    break;
                }
                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                    break;
                }
                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                    break;
                }
                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);
                const score = ((touchingPreviousChange ? 5 : 0)
                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));
                if (score > bestScore) {
                    bestScore = score;
                    bestDelta = delta;
                }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
            const mergedChangeArr = [null];
            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
                changes[i - 1] = mergedChangeArr[0];
                changes.splice(i, 1);
                i++;
                continue;
            }
        }
        // There could be multiple longest common substrings.
        // Give preference to the ones containing longer lines
        if (this._hasStrings) {
            for (let i = 1, len = changes.length; i < len; i++) {
                const aChange = changes[i - 1];
                const bChange = changes[i];
                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
                const aOriginalStart = aChange.originalStart;
                const bOriginalEnd = bChange.originalStart + bChange.originalLength;
                const abOriginalLength = bOriginalEnd - aOriginalStart;
                const aModifiedStart = aChange.modifiedStart;
                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
                const abModifiedLength = bModifiedEnd - aModifiedStart;
                // Avoid wasting a lot of time with these searches
                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
                    if (t) {
                        const [originalMatchStart, modifiedMatchStart] = t;
                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                            // switch to another sequence that has a better score
                            aChange.originalLength = originalMatchStart - aChange.originalStart;
                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                            bChange.originalStart = originalMatchStart + matchedLength;
                            bChange.modifiedStart = modifiedMatchStart + matchedLength;
                            bChange.originalLength = bOriginalEnd - bChange.originalStart;
                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
                        }
                    }
                }
            }
        }
        return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
        if (originalLength < desiredLength || modifiedLength < desiredLength) {
            return null;
        }
        const originalMax = originalStart + originalLength - desiredLength + 1;
        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
        let bestScore = 0;
        let bestOriginalStart = 0;
        let bestModifiedStart = 0;
        for (let i = originalStart; i < originalMax; i++) {
            for (let j = modifiedStart; j < modifiedMax; j++) {
                const score = this._contiguousSequenceScore(i, j, desiredLength);
                if (score > 0 && score > bestScore) {
                    bestScore = score;
                    bestOriginalStart = i;
                    bestModifiedStart = j;
                }
            }
        }
        if (bestScore > 0) {
            return [bestOriginalStart, bestModifiedStart];
        }
        return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
        let score = 0;
        for (let l = 0; l < length; l++) {
            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
                return 0;
            }
            score += this._originalStringElements[originalStart + l].length;
        }
        return score;
    }
    _OriginalIsBoundary(index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._originalStringElements[index]));
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
        }
        if (originalLength > 0) {
            const originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
                return true;
            }
        }
        return false;
    }
    _ModifiedIsBoundary(index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]));
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
        }
        if (modifiedLength > 0) {
            const modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
                return true;
            }
        }
        return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);
        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);
        return (originalScore + modifiedScore);
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
        let mergedChangeArr = [];
        if (left.length === 0 || right.length === 0) {
            return (right.length > 0) ? right : left;
        }
        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            // Since we break the problem down recursively, it is possible that we
            // might recurse in the middle of a change thereby splitting it into
            // two changes. Here in the combining stage, we detect and fuse those
            // changes back together
            const result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
        }
        else {
            const result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
        }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            const originalStart = left.originalStart;
            let originalLength = left.originalLength;
            const modifiedStart = left.modifiedStart;
            let modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
                originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new _diffChange_js__WEBPACK_IMPORTED_MODULE_0__.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
        }
        else {
            mergedChangeArr[0] = null;
            return false;
        }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
            // Nothing to clip, its in range
            return diagonal;
        }
        // diagonalsBelow: The number of diagonals below the reference diagonal
        // diagonalsAbove: The number of diagonals above the reference diagonal
        const diagonalsBelow = diagonalBaseIndex;
        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        const diffEven = (numDifferences % 2 === 0);
        if (diagonal < 0) {
            const lowerBoundEven = (diagonalsBelow % 2 === 0);
            return (diffEven === lowerBoundEven) ? 0 : 1;
        }
        else {
            const upperBoundEven = (diagonalsAbove % 2 === 0);
            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
        }
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffChange": () => (/* binding */ DiffChange)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Represents information about a specific difference between two sequences.
 */
class DiffChange {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
        //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
        return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
        return this.modifiedStart + this.modifiedLength;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancellationError": () => (/* binding */ CancellationError),
/* harmony export */   "ErrorHandler": () => (/* binding */ ErrorHandler),
/* harmony export */   "NotSupportedError": () => (/* binding */ NotSupportedError),
/* harmony export */   "canceled": () => (/* binding */ canceled),
/* harmony export */   "errorHandler": () => (/* binding */ errorHandler),
/* harmony export */   "illegalArgument": () => (/* binding */ illegalArgument),
/* harmony export */   "illegalState": () => (/* binding */ illegalState),
/* harmony export */   "isCancellationError": () => (/* binding */ isCancellationError),
/* harmony export */   "onUnexpectedError": () => (/* binding */ onUnexpectedError),
/* harmony export */   "onUnexpectedExternalError": () => (/* binding */ onUnexpectedExternalError),
/* harmony export */   "transformErrorForSerialization": () => (/* binding */ transformErrorForSerialization)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
class ErrorHandler {
    constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function (e) {
            setTimeout(() => {
                if (e.stack) {
                    throw new Error(e.message + '\n\n' + e.stack);
                }
                throw e;
            }, 0);
        };
    }
    emit(e) {
        this.listeners.forEach((listener) => {
            listener(e);
        });
    }
    onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
    }
}
const errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
    // ignore errors from cancelled promises
    if (!isCancellationError(e)) {
        errorHandler.onUnexpectedError(e);
    }
    return undefined;
}
function onUnexpectedExternalError(e) {
    // ignore errors from cancelled promises
    if (!isCancellationError(e)) {
        errorHandler.onUnexpectedExternalError(e);
    }
    return undefined;
}
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        let { name, message } = error;
        const stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name,
            message,
            stack
        };
    }
    // return as is
    return error;
}
const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
function isCancellationError(error) {
    if (error instanceof CancellationError) {
        return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
// !!!IMPORTANT!!!
// Do NOT change this class because it is also used as an API-type.
class CancellationError extends Error {
    constructor() {
        super(canceledName);
        this.name = this.message;
    }
}
/**
 * @deprecated use {@link CancellationError `new CancellationError()`} instead
 */
function canceled() {
    const error = new Error(canceledName);
    error.name = error.message;
    return error;
}
function illegalArgument(name) {
    if (name) {
        return new Error(`Illegal argument: ${name}`);
    }
    else {
        return new Error('Illegal argument');
    }
}
function illegalState(name) {
    if (name) {
        return new Error(`Illegal state: ${name}`);
    }
    else {
        return new Error('Illegal state');
    }
}
class NotSupportedError extends Error {
    constructor(message) {
        super('NotSupported');
        if (message) {
            this.message = message;
        }
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebounceEmitter": () => (/* binding */ DebounceEmitter),
/* harmony export */   "Emitter": () => (/* binding */ Emitter),
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "EventBufferer": () => (/* binding */ EventBufferer),
/* harmony export */   "PauseableEmitter": () => (/* binding */ PauseableEmitter),
/* harmony export */   "Relay": () => (/* binding */ Relay)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _linkedList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linkedList.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js");
/* harmony import */ var _stopwatch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stopwatch.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");




// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.
// -----------------------------------------------------------------------------------------------------------------------
let _enableDisposeWithListenerWarning = false;
// _enableDisposeWithListenerWarning = Boolean("TRUE"); // causes a linter warning so that it cannot be pushed
// -----------------------------------------------------------------------------------------------------------------------
// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.
// See https://github.com/microsoft/vscode/issues/142851
// -----------------------------------------------------------------------------------------------------------------------
let _enableSnapshotPotentialLeakWarning = false;
var Event;
(function (Event) {
    Event.None = () => _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable.None;
    function _addLeakageTraceLogic(options) {
        if (_enableSnapshotPotentialLeakWarning) {
            const { onListenerDidAdd: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onListenerDidAdd = () => {
                if (++count === 2) {
                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');
                    stack.print();
                }
                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
            };
        }
    }
    /**
     * Given an event, returns another event which only fires once.
     */
    function once(event) {
        return (listener, thisArgs = null, disposables) => {
            // we need this, in case the event fires during the listener call
            let didFire = false;
            let result;
            result = event(e => {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    Event.once = once;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function map(event, map, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);
    }
    Event.map = map;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function forEach(event, each, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);
    }
    Event.forEach = forEach;
    function filter(event, filter, disposable) {
        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    Event.filter = filter;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal(event) {
        return event;
    }
    Event.signal = signal;
    function any(...events) {
        return (listener, thisArgs = null, disposables) => (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));
    }
    Event.any = any;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce(event, merge, initial, disposable) {
        let output = initial;
        return map(event, e => {
            output = merge(output, e);
            return output;
        }, disposable);
    }
    Event.reduce = reduce;
    function snapshot(event, disposable) {
        let listener;
        const options = {
            onFirstListenerAdd() {
                listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove() {
                listener.dispose();
            }
        };
        if (!disposable) {
            _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        if (disposable) {
            disposable.add(emitter);
        }
        return emitter.event;
    }
    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
        let subscription;
        let output = undefined;
        let handle = undefined;
        let numDebouncedCalls = 0;
        const options = {
            leakWarningThreshold,
            onFirstListenerAdd() {
                subscription = event(cur => {
                    numDebouncedCalls++;
                    output = merge(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                        output = undefined;
                    }
                    clearTimeout(handle);
                    handle = setTimeout(() => {
                        const _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove() {
                subscription.dispose();
            }
        };
        if (!disposable) {
            _addLeakageTraceLogic(options);
        }
        const emitter = new Emitter(options);
        if (disposable) {
            disposable.add(emitter);
        }
        return emitter.event;
    }
    Event.debounce = debounce;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function latch(event, equals = (a, b) => a === b, disposable) {
        let firstCall = true;
        let cache;
        return filter(event, value => {
            const shouldEmit = firstCall || !equals(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
        }, disposable);
    }
    Event.latch = latch;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function split(event, isT, disposable) {
        return [
            Event.filter(event, isT, disposable),
            Event.filter(event, e => !isT(e), disposable),
        ];
    }
    Event.split = split;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function buffer(event, flushAfterTimeout = false, _buffer = []) {
        let buffer = _buffer.slice();
        let listener = event(e => {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        const flush = () => {
            if (buffer) {
                buffer.forEach(e => emitter.fire(e));
            }
            buffer = null;
        };
        const emitter = new Emitter({
            onFirstListenerAdd() {
                if (!listener) {
                    listener = event(e => emitter.fire(e));
                }
            },
            onFirstListenerDidAdd() {
                if (buffer) {
                    if (flushAfterTimeout) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove() {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            }
        });
        return emitter.event;
    }
    Event.buffer = buffer;
    class ChainableEvent {
        constructor(event) {
            this.event = event;
        }
        map(fn) {
            return new ChainableEvent(map(this.event, fn));
        }
        forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn));
        }
        filter(fn) {
            return new ChainableEvent(filter(this.event, fn));
        }
        reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
        }
        latch() {
            return new ChainableEvent(latch(this.event));
        }
        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
        }
        on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
        }
        once(listener, thisArgs, disposables) {
            return once(this.event)(listener, thisArgs, disposables);
        }
    }
    /**
     * @deprecated DO NOT use, this leaks memory
     */
    function chain(event) {
        return new ChainableEvent(event);
    }
    Event.chain = chain;
    function fromNodeEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
        return result.event;
    }
    Event.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map = id => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
        return result.event;
    }
    Event.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
        return new Promise(resolve => once(event)(resolve));
    }
    Event.toPromise = toPromise;
    function runAndSubscribe(event, handler) {
        handler(undefined);
        return event(e => handler(e));
    }
    Event.runAndSubscribe = runAndSubscribe;
    function runAndSubscribeWithStore(event, handler) {
        let store = null;
        function run(e) {
            store === null || store === void 0 ? void 0 : store.dispose();
            store = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore();
            handler(e, store);
        }
        run(undefined);
        const disposable = event(e => run(e));
        return (0,_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            disposable.dispose();
            store === null || store === void 0 ? void 0 : store.dispose();
        });
    }
    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;
})(Event || (Event = {}));
class EventProfiling {
    constructor(name) {
        this._listenerCount = 0;
        this._invocationCount = 0;
        this._elapsedOverall = 0;
        this._name = `${name}_${EventProfiling._idPool++}`;
    }
    start(listenerCount) {
        this._stopWatch = new _stopwatch_js__WEBPACK_IMPORTED_MODULE_3__.StopWatch(true);
        this._listenerCount = listenerCount;
    }
    stop() {
        if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this._elapsedOverall += elapsed;
            this._invocationCount += 1;
            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);
            this._stopWatch = undefined;
        }
    }
}
EventProfiling._idPool = 0;
let _globalLeakWarningThreshold = -1;
class LeakageMonitor {
    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
        this.customThreshold = customThreshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    dispose() {
        if (this._stacks) {
            this._stacks.clear();
        }
    }
    check(stack, listenerCount) {
        let threshold = _globalLeakWarningThreshold;
        if (typeof this.customThreshold === 'number') {
            threshold = this.customThreshold;
        }
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = new Map();
        }
        const count = (this._stacks.get(stack.value) || 0);
        this._stacks.set(stack.value, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            // only warn on first exceed and then every time the limit
            // is exceeded by 50% again
            this._warnCountdown = threshold * 0.5;
            // find most frequent listener and print warning
            let topStack;
            let topCount = 0;
            for (const [stack, count] of this._stacks) {
                if (!topStack || topCount < count) {
                    topStack = stack;
                    topCount = count;
                }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
        }
        return () => {
            const count = (this._stacks.get(stack.value) || 0);
            this._stacks.set(stack.value, count - 1);
        };
    }
}
class Stacktrace {
    constructor(value) {
        this.value = value;
    }
    static create() {
        var _a;
        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');
    }
    print() {
        console.warn(this.value.split('\n').slice(2).join('\n'));
    }
}
class Listener {
    constructor(callback, callbackThis, stack) {
        this.callback = callback;
        this.callbackThis = callbackThis;
        this.stack = stack;
        this.subscription = new _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.SafeDisposable();
    }
    invoke(e) {
        this.callback.call(this.callbackThis, e);
    }
}
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
    class Document {

        private readonly _onDidChange = new Emitter<(value:string)=>any>();

        public onDidChange = this._onDidChange.event;

        // getter-style
        // get onDidChange(): Event<(value:string)=>any> {
        // 	return this._onDidChange.event;
        // }

        private _doIt() {
            //...
            this._onDidChange.fire(value);
        }
    }
 */
class Emitter {
    constructor(options) {
        var _a;
        this._disposed = false;
        this._options = options;
        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;
        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;
    }
    dispose() {
        var _a, _b, _c, _d;
        if (!this._disposed) {
            this._disposed = true;
            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter
            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and
            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the
            // the following programming pattern is very popular:
            //
            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model
            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener
            // ...later...
            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the "overall dispose" is done
            if (this._listeners) {
                if (_enableDisposeWithListenerWarning) {
                    const listeners = Array.from(this._listeners);
                    queueMicrotask(() => {
                        var _a;
                        for (const listener of listeners) {
                            if (listener.subscription.isset()) {
                                listener.subscription.unset();
                                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();
                            }
                        }
                    });
                }
                this._listeners.clear();
            }
            (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear();
            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);
            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
        }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (callback, thisArgs, disposables) => {
                var _a, _b, _c;
                if (!this._listeners) {
                    this._listeners = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
                }
                const firstListener = this._listeners.isEmpty();
                if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onFirstListenerAdd)) {
                    this._options.onFirstListenerAdd(this);
                }
                let removeMonitor;
                let stack;
                if (this._leakageMon && this._listeners.size >= 30) {
                    // check and record this emitter for potential leakage
                    stack = Stacktrace.create();
                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
                }
                if (_enableDisposeWithListenerWarning) {
                    stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
                }
                const listener = new Listener(callback, thisArgs, stack);
                const removeListener = this._listeners.push(listener);
                if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {
                    this._options.onFirstListenerDidAdd(this);
                }
                if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {
                    this._options.onListenerDidAdd(this, callback, thisArgs);
                }
                const result = listener.subscription.set(() => {
                    if (removeMonitor) {
                        removeMonitor();
                    }
                    if (!this._disposed) {
                        removeListener();
                        if (this._options && this._options.onLastListenerRemove) {
                            const hasListeners = (this._listeners && !this._listeners.isEmpty());
                            if (!hasListeners) {
                                this._options.onLastListenerRemove(this);
                            }
                        }
                    }
                });
                if (disposables instanceof _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.DisposableStore) {
                    disposables.add(result);
                }
                else if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        var _a, _b;
        if (this._listeners) {
            // put all [listener,event]-pairs into delivery queue
            // then emit all event. an inner/nested event might be
            // the driver of this
            if (!this._deliveryQueue) {
                this._deliveryQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
            }
            for (let listener of this._listeners) {
                this._deliveryQueue.push([listener, event]);
            }
            // start/stop performance insight collection
            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);
            while (this._deliveryQueue.size > 0) {
                const [listener, event] = this._deliveryQueue.shift();
                try {
                    listener.invoke(event);
                }
                catch (e) {
                    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.onUnexpectedError)(e);
                }
            }
            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
        }
    }
}
class PauseableEmitter extends Emitter {
    constructor(options) {
        super(options);
        this._isPaused = 0;
        this._eventQueue = new _linkedList_js__WEBPACK_IMPORTED_MODULE_2__.LinkedList();
        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;
    }
    pause() {
        this._isPaused++;
    }
    resume() {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
            if (this._mergeFn) {
                // use the merge function to create a single composite
                // event. make a copy in case firing pauses this emitter
                const events = Array.from(this._eventQueue);
                this._eventQueue.clear();
                super.fire(this._mergeFn(events));
            }
            else {
                // no merging, fire each event individually and test
                // that this emitter isn't paused halfway through
                while (!this._isPaused && this._eventQueue.size !== 0) {
                    super.fire(this._eventQueue.shift());
                }
            }
        }
    }
    fire(event) {
        if (this._listeners) {
            if (this._isPaused !== 0) {
                this._eventQueue.push(event);
            }
            else {
                super.fire(event);
            }
        }
    }
}
class DebounceEmitter extends PauseableEmitter {
    constructor(options) {
        var _a;
        super(options);
        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;
    }
    fire(event) {
        if (!this._handle) {
            this.pause();
            this._handle = setTimeout(() => {
                this._handle = undefined;
                this.resume();
            }, this._delay);
        }
        super.fire(event);
    }
}
/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */
class EventBufferer {
    constructor() {
        this.buffers = [];
    }
    wrapEvent(event) {
        return (listener, thisArgs, disposables) => {
            return event(i => {
                const buffer = this.buffers[this.buffers.length - 1];
                if (buffer) {
                    buffer.push(() => listener.call(thisArgs, i));
                }
                else {
                    listener.call(thisArgs, i);
                }
            }, undefined, disposables);
        };
    }
    bufferEvents(fn) {
        const buffer = [];
        this.buffers.push(buffer);
        const r = fn();
        this.buffers.pop();
        buffer.forEach(flush => flush());
        return r;
    }
}
/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */
class Relay {
    constructor() {
        this.listening = false;
        this.inputEvent = Event.None;
        this.inputEventListener = _lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable.None;
        this.emitter = new Emitter({
            onFirstListenerDidAdd: () => {
                this.listening = true;
                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
            },
            onLastListenerRemove: () => {
                this.listening = false;
                this.inputEventListener.dispose();
            }
        });
        this.event = this.emitter.event;
    }
    set input(event) {
        this.inputEvent = event;
        if (this.listening) {
            this.inputEventListener.dispose();
            this.inputEventListener = event(this.emitter.fire, this.emitter);
        }
    }
    dispose() {
        this.inputEventListener.dispose();
        this.emitter.dispose();
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "once": () => (/* binding */ once)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/hash.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringSHA1": () => (/* binding */ StringSHA1),
/* harmony export */   "doHash": () => (/* binding */ doHash),
/* harmony export */   "hash": () => (/* binding */ hash),
/* harmony export */   "numberHash": () => (/* binding */ numberHash),
/* harmony export */   "stringHash": () => (/* binding */ stringHash),
/* harmony export */   "toHexString": () => (/* binding */ toHexString)
/* harmony export */ });
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Return a hash value for an object.
 */
function hash(obj) {
    return doHash(obj, 0);
}
function doHash(obj, hashVal) {
    switch (typeof obj) {
        case 'object':
            if (obj === null) {
                return numberHash(349, hashVal);
            }
            else if (Array.isArray(obj)) {
                return arrayHash(obj, hashVal);
            }
            return objectHash(obj, hashVal);
        case 'string':
            return stringHash(obj, hashVal);
        case 'boolean':
            return booleanHash(obj, hashVal);
        case 'number':
            return numberHash(obj, hashVal);
        case 'undefined':
            return numberHash(937, hashVal);
        default:
            return numberHash(617, hashVal);
    }
}
function numberHash(val, initialHashVal) {
    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
}
function booleanHash(b, initialHashVal) {
    return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
        hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
}
function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);
}
function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce((hashVal, key) => {
        hashVal = stringHash(key, hashVal);
        return doHash(obj[key], hashVal);
    }, initialHashVal);
}
function leftRotate(value, bits, totalBits = 32) {
    // delta + bits = totalBits
    const delta = totalBits - bits;
    // All ones, expect `delta` zeros aligned to the right
    const mask = ~((1 << delta) - 1);
    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)
    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;
}
function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
        dest[index + i] = value;
    }
}
function leftPad(value, length, char = '0') {
    while (value.length < length) {
        value = char + value;
    }
    return value;
}
function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
}
/**
 * A SHA1 implementation that works with strings and does not allocate.
 */
class StringSHA1 {
    constructor() {
        this._h0 = 0x67452301;
        this._h1 = 0xEFCDAB89;
        this._h2 = 0x98BADCFE;
        this._h3 = 0x10325476;
        this._h4 = 0xC3D2E1F0;
        this._buff = new Uint8Array(64 /* BLOCK_SIZE */ + 3 /* to fit any utf-8 */);
        this._buffDV = new DataView(this._buff.buffer);
        this._buffLen = 0;
        this._totalLen = 0;
        this._leftoverHighSurrogate = 0;
        this._finished = false;
    }
    update(str) {
        const strLen = str.length;
        if (strLen === 0) {
            return;
        }
        const buff = this._buff;
        let buffLen = this._buffLen;
        let leftoverHighSurrogate = this._leftoverHighSurrogate;
        let charCode;
        let offset;
        if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
        }
        else {
            charCode = str.charCodeAt(0);
            offset = 0;
        }
        while (true) {
            let codePoint = charCode;
            if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isHighSurrogate(charCode)) {
                if (offset + 1 < strLen) {
                    const nextCharCode = str.charCodeAt(offset + 1);
                    if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(nextCharCode)) {
                        offset++;
                        codePoint = _strings_js__WEBPACK_IMPORTED_MODULE_0__.computeCodePoint(charCode, nextCharCode);
                    }
                    else {
                        // illegal => unicode replacement character
                        codePoint = 65533 /* UNICODE_REPLACEMENT */;
                    }
                }
                else {
                    // last character is a surrogate pair
                    leftoverHighSurrogate = charCode;
                    break;
                }
            }
            else if (_strings_js__WEBPACK_IMPORTED_MODULE_0__.isLowSurrogate(charCode)) {
                // illegal => unicode replacement character
                codePoint = 65533 /* UNICODE_REPLACEMENT */;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
                charCode = str.charCodeAt(offset);
            }
            else {
                break;
            }
        }
        this._buffLen = buffLen;
        this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
        if (codePoint < 0x0080) {
            buff[buffLen++] = codePoint;
        }
        else if (codePoint < 0x0800) {
            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else if (codePoint < 0x10000) {
            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        else {
            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);
            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);
        }
        if (buffLen >= 64 /* BLOCK_SIZE */) {
            this._step();
            buffLen -= 64 /* BLOCK_SIZE */;
            this._totalLen += 64 /* BLOCK_SIZE */;
            // take last 3 in case of UTF8 overflow
            buff[0] = buff[64 /* BLOCK_SIZE */ + 0];
            buff[1] = buff[64 /* BLOCK_SIZE */ + 1];
            buff[2] = buff[64 /* BLOCK_SIZE */ + 2];
        }
        return buffLen;
    }
    digest() {
        if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
                // illegal => unicode replacement character
                this._leftoverHighSurrogate = 0;
                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
        }
        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
        this._buff[this._buffLen++] = 0x80;
        fill(this._buff, this._buffLen);
        if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
        }
        // this will fit because the mantissa can cover up to 52 bits
        const ml = 8 * this._totalLen;
        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
        this._buffDV.setUint32(60, ml % 4294967296, false);
        this._step();
    }
    _step() {
        const bigBlock32 = StringSHA1._bigBlock32;
        const data = this._buffDV;
        for (let j = 0; j < 64 /* 16*4 */; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
        }
        for (let j = 64; j < 320 /* 80*4 */; j += 4) {
            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);
        }
        let a = this._h0;
        let b = this._h1;
        let c = this._h2;
        let d = this._h3;
        let e = this._h4;
        let f, k;
        let temp;
        for (let j = 0; j < 80; j++) {
            if (j < 20) {
                f = (b & c) | ((~b) & d);
                k = 0x5A827999;
            }
            else if (j < 40) {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            }
            else if (j < 60) {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            }
            else {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }
            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
        }
        this._h0 = (this._h0 + a) & 0xffffffff;
        this._h1 = (this._h1 + b) & 0xffffffff;
        this._h2 = (this._h2 + c) & 0xffffffff;
        this._h3 = (this._h3 + d) & 0xffffffff;
        this._h4 = (this._h4 + e) & 0xffffffff;
    }
}
StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Iterable": () => (/* binding */ Iterable)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Iterable;
(function (Iterable) {
    function is(thing) {
        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';
    }
    Iterable.is = is;
    const _empty = Object.freeze([]);
    function empty() {
        return _empty;
    }
    Iterable.empty = empty;
    function* single(element) {
        yield element;
    }
    Iterable.single = single;
    function from(iterable) {
        return iterable || _empty;
    }
    Iterable.from = from;
    function isEmpty(iterable) {
        return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable.isEmpty = isEmpty;
    function first(iterable) {
        return iterable[Symbol.iterator]().next().value;
    }
    Iterable.first = first;
    function some(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                return true;
            }
        }
        return false;
    }
    Iterable.some = some;
    function find(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                return element;
            }
        }
        return undefined;
    }
    Iterable.find = find;
    function* filter(iterable, predicate) {
        for (const element of iterable) {
            if (predicate(element)) {
                yield element;
            }
        }
    }
    Iterable.filter = filter;
    function* map(iterable, fn) {
        let index = 0;
        for (const element of iterable) {
            yield fn(element, index++);
        }
    }
    Iterable.map = map;
    function* concat(...iterables) {
        for (const iterable of iterables) {
            for (const element of iterable) {
                yield element;
            }
        }
    }
    Iterable.concat = concat;
    function* concatNested(iterables) {
        for (const iterable of iterables) {
            for (const element of iterable) {
                yield element;
            }
        }
    }
    Iterable.concatNested = concatNested;
    function reduce(iterable, reducer, initialValue) {
        let value = initialValue;
        for (const element of iterable) {
            value = reducer(value, element);
        }
        return value;
    }
    Iterable.reduce = reduce;
    /**
     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.
     */
    function* slice(arr, from, to = arr.length) {
        if (from < 0) {
            from += arr.length;
        }
        if (to < 0) {
            to += arr.length;
        }
        else if (to > arr.length) {
            to = arr.length;
        }
        for (; from < to; from++) {
            yield arr[from];
        }
    }
    Iterable.slice = slice;
    /**
     * Consumes `atMost` elements from iterable and returns the consumed elements,
     * and an iterable for the rest of the elements.
     */
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
        const consumed = [];
        if (atMost === 0) {
            return [consumed, iterable];
        }
        const iterator = iterable[Symbol.iterator]();
        for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
                return [consumed, Iterable.empty()];
            }
            consumed.push(next.value);
        }
        return [consumed, { [Symbol.iterator]() { return iterator; } }];
    }
    Iterable.consume = consume;
    /**
     * Returns whether the iterables are the same length and all items are
     * equal using the comparator function.
     */
    function equals(a, b, comparator = (at, bt) => at === bt) {
        const ai = a[Symbol.iterator]();
        const bi = b[Symbol.iterator]();
        while (true) {
            const an = ai.next();
            const bn = bi.next();
            if (an.done !== bn.done) {
                return false;
            }
            else if (an.done) {
                return true;
            }
            else if (!comparator(an.value, bn.value)) {
                return false;
            }
        }
    }
    Iterable.equals = equals;
})(Iterable || (Iterable = {}));


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVENT_KEY_CODE_MAP": () => (/* binding */ EVENT_KEY_CODE_MAP),
/* harmony export */   "IMMUTABLE_CODE_TO_KEY_CODE": () => (/* binding */ IMMUTABLE_CODE_TO_KEY_CODE),
/* harmony export */   "IMMUTABLE_KEY_CODE_TO_CODE": () => (/* binding */ IMMUTABLE_KEY_CODE_TO_CODE),
/* harmony export */   "KeyChord": () => (/* binding */ KeyChord),
/* harmony export */   "KeyCodeUtils": () => (/* binding */ KeyCodeUtils),
/* harmony export */   "NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE": () => (/* binding */ NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class KeyCodeStrMap {
    constructor() {
        this._keyCodeToStr = [];
        this._strToKeyCode = Object.create(null);
    }
    define(keyCode, str) {
        this._keyCodeToStr[keyCode] = str;
        this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
        return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;
    }
}
const uiMap = new KeyCodeStrMap();
const userSettingsUSMap = new KeyCodeStrMap();
const userSettingsGeneralMap = new KeyCodeStrMap();
const EVENT_KEY_CODE_MAP = new Array(230);
const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
const scanCodeIntToStr = [];
const scanCodeStrToInt = Object.create(null);
const scanCodeLowerCaseStrToInt = Object.create(null);
/**
 * -1 if a ScanCode => KeyCode mapping depends on kb layout.
 */
const IMMUTABLE_CODE_TO_KEY_CODE = [];
/**
 * -1 if a KeyCode => ScanCode mapping depends on kb layout.
 */
const IMMUTABLE_KEY_CODE_TO_CODE = [];
for (let i = 0; i <= 193 /* MAX_VALUE */; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1 /* DependsOnKbLayout */;
}
for (let i = 0; i <= 127 /* MAX_VALUE */; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1 /* DependsOnKbLayout */;
}
(function () {
    // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    // See https://github.com/microsoft/node-native-keymap/blob/master/deps/chromium/keyboard_codes_win.h
    const empty = '';
    const mappings = [
        // keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
        [0, 1, 0 /* None */, 'None', 0 /* Unknown */, 'unknown', 0, 'VK_UNKNOWN', empty, empty],
        [0, 1, 1 /* Hyper */, 'Hyper', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 2 /* Super */, 'Super', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 3 /* Fn */, 'Fn', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 4 /* FnLock */, 'FnLock', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 5 /* Suspend */, 'Suspend', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 6 /* Resume */, 'Resume', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 7 /* Turbo */, 'Turbo', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 8 /* Sleep */, 'Sleep', 0 /* Unknown */, empty, 0, 'VK_SLEEP', empty, empty],
        [0, 1, 9 /* WakeUp */, 'WakeUp', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [31, 0, 10 /* KeyA */, 'KeyA', 31 /* KeyA */, 'A', 65, 'VK_A', empty, empty],
        [32, 0, 11 /* KeyB */, 'KeyB', 32 /* KeyB */, 'B', 66, 'VK_B', empty, empty],
        [33, 0, 12 /* KeyC */, 'KeyC', 33 /* KeyC */, 'C', 67, 'VK_C', empty, empty],
        [34, 0, 13 /* KeyD */, 'KeyD', 34 /* KeyD */, 'D', 68, 'VK_D', empty, empty],
        [35, 0, 14 /* KeyE */, 'KeyE', 35 /* KeyE */, 'E', 69, 'VK_E', empty, empty],
        [36, 0, 15 /* KeyF */, 'KeyF', 36 /* KeyF */, 'F', 70, 'VK_F', empty, empty],
        [37, 0, 16 /* KeyG */, 'KeyG', 37 /* KeyG */, 'G', 71, 'VK_G', empty, empty],
        [38, 0, 17 /* KeyH */, 'KeyH', 38 /* KeyH */, 'H', 72, 'VK_H', empty, empty],
        [39, 0, 18 /* KeyI */, 'KeyI', 39 /* KeyI */, 'I', 73, 'VK_I', empty, empty],
        [40, 0, 19 /* KeyJ */, 'KeyJ', 40 /* KeyJ */, 'J', 74, 'VK_J', empty, empty],
        [41, 0, 20 /* KeyK */, 'KeyK', 41 /* KeyK */, 'K', 75, 'VK_K', empty, empty],
        [42, 0, 21 /* KeyL */, 'KeyL', 42 /* KeyL */, 'L', 76, 'VK_L', empty, empty],
        [43, 0, 22 /* KeyM */, 'KeyM', 43 /* KeyM */, 'M', 77, 'VK_M', empty, empty],
        [44, 0, 23 /* KeyN */, 'KeyN', 44 /* KeyN */, 'N', 78, 'VK_N', empty, empty],
        [45, 0, 24 /* KeyO */, 'KeyO', 45 /* KeyO */, 'O', 79, 'VK_O', empty, empty],
        [46, 0, 25 /* KeyP */, 'KeyP', 46 /* KeyP */, 'P', 80, 'VK_P', empty, empty],
        [47, 0, 26 /* KeyQ */, 'KeyQ', 47 /* KeyQ */, 'Q', 81, 'VK_Q', empty, empty],
        [48, 0, 27 /* KeyR */, 'KeyR', 48 /* KeyR */, 'R', 82, 'VK_R', empty, empty],
        [49, 0, 28 /* KeyS */, 'KeyS', 49 /* KeyS */, 'S', 83, 'VK_S', empty, empty],
        [50, 0, 29 /* KeyT */, 'KeyT', 50 /* KeyT */, 'T', 84, 'VK_T', empty, empty],
        [51, 0, 30 /* KeyU */, 'KeyU', 51 /* KeyU */, 'U', 85, 'VK_U', empty, empty],
        [52, 0, 31 /* KeyV */, 'KeyV', 52 /* KeyV */, 'V', 86, 'VK_V', empty, empty],
        [53, 0, 32 /* KeyW */, 'KeyW', 53 /* KeyW */, 'W', 87, 'VK_W', empty, empty],
        [54, 0, 33 /* KeyX */, 'KeyX', 54 /* KeyX */, 'X', 88, 'VK_X', empty, empty],
        [55, 0, 34 /* KeyY */, 'KeyY', 55 /* KeyY */, 'Y', 89, 'VK_Y', empty, empty],
        [56, 0, 35 /* KeyZ */, 'KeyZ', 56 /* KeyZ */, 'Z', 90, 'VK_Z', empty, empty],
        [22, 0, 36 /* Digit1 */, 'Digit1', 22 /* Digit1 */, '1', 49, 'VK_1', empty, empty],
        [23, 0, 37 /* Digit2 */, 'Digit2', 23 /* Digit2 */, '2', 50, 'VK_2', empty, empty],
        [24, 0, 38 /* Digit3 */, 'Digit3', 24 /* Digit3 */, '3', 51, 'VK_3', empty, empty],
        [25, 0, 39 /* Digit4 */, 'Digit4', 25 /* Digit4 */, '4', 52, 'VK_4', empty, empty],
        [26, 0, 40 /* Digit5 */, 'Digit5', 26 /* Digit5 */, '5', 53, 'VK_5', empty, empty],
        [27, 0, 41 /* Digit6 */, 'Digit6', 27 /* Digit6 */, '6', 54, 'VK_6', empty, empty],
        [28, 0, 42 /* Digit7 */, 'Digit7', 28 /* Digit7 */, '7', 55, 'VK_7', empty, empty],
        [29, 0, 43 /* Digit8 */, 'Digit8', 29 /* Digit8 */, '8', 56, 'VK_8', empty, empty],
        [30, 0, 44 /* Digit9 */, 'Digit9', 30 /* Digit9 */, '9', 57, 'VK_9', empty, empty],
        [21, 0, 45 /* Digit0 */, 'Digit0', 21 /* Digit0 */, '0', 48, 'VK_0', empty, empty],
        [3, 1, 46 /* Enter */, 'Enter', 3 /* Enter */, 'Enter', 13, 'VK_RETURN', empty, empty],
        [9, 1, 47 /* Escape */, 'Escape', 9 /* Escape */, 'Escape', 27, 'VK_ESCAPE', empty, empty],
        [1, 1, 48 /* Backspace */, 'Backspace', 1 /* Backspace */, 'Backspace', 8, 'VK_BACK', empty, empty],
        [2, 1, 49 /* Tab */, 'Tab', 2 /* Tab */, 'Tab', 9, 'VK_TAB', empty, empty],
        [10, 1, 50 /* Space */, 'Space', 10 /* Space */, 'Space', 32, 'VK_SPACE', empty, empty],
        [83, 0, 51 /* Minus */, 'Minus', 83 /* Minus */, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],
        [81, 0, 52 /* Equal */, 'Equal', 81 /* Equal */, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],
        [87, 0, 53 /* BracketLeft */, 'BracketLeft', 87 /* BracketLeft */, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],
        [89, 0, 54 /* BracketRight */, 'BracketRight', 89 /* BracketRight */, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],
        [88, 0, 55 /* Backslash */, 'Backslash', 88 /* Backslash */, '\\', 220, 'VK_OEM_5', '\\', 'OEM_5'],
        [0, 0, 56 /* IntlHash */, 'IntlHash', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [80, 0, 57 /* Semicolon */, 'Semicolon', 80 /* Semicolon */, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],
        [90, 0, 58 /* Quote */, 'Quote', 90 /* Quote */, '\'', 222, 'VK_OEM_7', '\'', 'OEM_7'],
        [86, 0, 59 /* Backquote */, 'Backquote', 86 /* Backquote */, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],
        [82, 0, 60 /* Comma */, 'Comma', 82 /* Comma */, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],
        [84, 0, 61 /* Period */, 'Period', 84 /* Period */, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],
        [85, 0, 62 /* Slash */, 'Slash', 85 /* Slash */, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],
        [8, 1, 63 /* CapsLock */, 'CapsLock', 8 /* CapsLock */, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],
        [59, 1, 64 /* F1 */, 'F1', 59 /* F1 */, 'F1', 112, 'VK_F1', empty, empty],
        [60, 1, 65 /* F2 */, 'F2', 60 /* F2 */, 'F2', 113, 'VK_F2', empty, empty],
        [61, 1, 66 /* F3 */, 'F3', 61 /* F3 */, 'F3', 114, 'VK_F3', empty, empty],
        [62, 1, 67 /* F4 */, 'F4', 62 /* F4 */, 'F4', 115, 'VK_F4', empty, empty],
        [63, 1, 68 /* F5 */, 'F5', 63 /* F5 */, 'F5', 116, 'VK_F5', empty, empty],
        [64, 1, 69 /* F6 */, 'F6', 64 /* F6 */, 'F6', 117, 'VK_F6', empty, empty],
        [65, 1, 70 /* F7 */, 'F7', 65 /* F7 */, 'F7', 118, 'VK_F7', empty, empty],
        [66, 1, 71 /* F8 */, 'F8', 66 /* F8 */, 'F8', 119, 'VK_F8', empty, empty],
        [67, 1, 72 /* F9 */, 'F9', 67 /* F9 */, 'F9', 120, 'VK_F9', empty, empty],
        [68, 1, 73 /* F10 */, 'F10', 68 /* F10 */, 'F10', 121, 'VK_F10', empty, empty],
        [69, 1, 74 /* F11 */, 'F11', 69 /* F11 */, 'F11', 122, 'VK_F11', empty, empty],
        [70, 1, 75 /* F12 */, 'F12', 70 /* F12 */, 'F12', 123, 'VK_F12', empty, empty],
        [0, 1, 76 /* PrintScreen */, 'PrintScreen', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [79, 1, 77 /* ScrollLock */, 'ScrollLock', 79 /* ScrollLock */, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],
        [7, 1, 78 /* Pause */, 'Pause', 7 /* PauseBreak */, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],
        [19, 1, 79 /* Insert */, 'Insert', 19 /* Insert */, 'Insert', 45, 'VK_INSERT', empty, empty],
        [14, 1, 80 /* Home */, 'Home', 14 /* Home */, 'Home', 36, 'VK_HOME', empty, empty],
        [11, 1, 81 /* PageUp */, 'PageUp', 11 /* PageUp */, 'PageUp', 33, 'VK_PRIOR', empty, empty],
        [20, 1, 82 /* Delete */, 'Delete', 20 /* Delete */, 'Delete', 46, 'VK_DELETE', empty, empty],
        [13, 1, 83 /* End */, 'End', 13 /* End */, 'End', 35, 'VK_END', empty, empty],
        [12, 1, 84 /* PageDown */, 'PageDown', 12 /* PageDown */, 'PageDown', 34, 'VK_NEXT', empty, empty],
        [17, 1, 85 /* ArrowRight */, 'ArrowRight', 17 /* RightArrow */, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],
        [15, 1, 86 /* ArrowLeft */, 'ArrowLeft', 15 /* LeftArrow */, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],
        [18, 1, 87 /* ArrowDown */, 'ArrowDown', 18 /* DownArrow */, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],
        [16, 1, 88 /* ArrowUp */, 'ArrowUp', 16 /* UpArrow */, 'UpArrow', 38, 'VK_UP', 'Up', empty],
        [78, 1, 89 /* NumLock */, 'NumLock', 78 /* NumLock */, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],
        [108, 1, 90 /* NumpadDivide */, 'NumpadDivide', 108 /* NumpadDivide */, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],
        [103, 1, 91 /* NumpadMultiply */, 'NumpadMultiply', 103 /* NumpadMultiply */, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],
        [106, 1, 92 /* NumpadSubtract */, 'NumpadSubtract', 106 /* NumpadSubtract */, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],
        [104, 1, 93 /* NumpadAdd */, 'NumpadAdd', 104 /* NumpadAdd */, 'NumPad_Add', 107, 'VK_ADD', empty, empty],
        [3, 1, 94 /* NumpadEnter */, 'NumpadEnter', 3 /* Enter */, empty, 0, empty, empty, empty],
        [94, 1, 95 /* Numpad1 */, 'Numpad1', 94 /* Numpad1 */, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],
        [95, 1, 96 /* Numpad2 */, 'Numpad2', 95 /* Numpad2 */, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],
        [96, 1, 97 /* Numpad3 */, 'Numpad3', 96 /* Numpad3 */, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],
        [97, 1, 98 /* Numpad4 */, 'Numpad4', 97 /* Numpad4 */, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],
        [98, 1, 99 /* Numpad5 */, 'Numpad5', 98 /* Numpad5 */, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],
        [99, 1, 100 /* Numpad6 */, 'Numpad6', 99 /* Numpad6 */, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],
        [100, 1, 101 /* Numpad7 */, 'Numpad7', 100 /* Numpad7 */, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],
        [101, 1, 102 /* Numpad8 */, 'Numpad8', 101 /* Numpad8 */, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],
        [102, 1, 103 /* Numpad9 */, 'Numpad9', 102 /* Numpad9 */, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],
        [93, 1, 104 /* Numpad0 */, 'Numpad0', 93 /* Numpad0 */, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],
        [107, 1, 105 /* NumpadDecimal */, 'NumpadDecimal', 107 /* NumpadDecimal */, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],
        [92, 0, 106 /* IntlBackslash */, 'IntlBackslash', 92 /* IntlBackslash */, 'OEM_102', 226, 'VK_OEM_102', empty, empty],
        [58, 1, 107 /* ContextMenu */, 'ContextMenu', 58 /* ContextMenu */, 'ContextMenu', 93, empty, empty, empty],
        [0, 1, 108 /* Power */, 'Power', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 109 /* NumpadEqual */, 'NumpadEqual', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [71, 1, 110 /* F13 */, 'F13', 71 /* F13 */, 'F13', 124, 'VK_F13', empty, empty],
        [72, 1, 111 /* F14 */, 'F14', 72 /* F14 */, 'F14', 125, 'VK_F14', empty, empty],
        [73, 1, 112 /* F15 */, 'F15', 73 /* F15 */, 'F15', 126, 'VK_F15', empty, empty],
        [74, 1, 113 /* F16 */, 'F16', 74 /* F16 */, 'F16', 127, 'VK_F16', empty, empty],
        [75, 1, 114 /* F17 */, 'F17', 75 /* F17 */, 'F17', 128, 'VK_F17', empty, empty],
        [76, 1, 115 /* F18 */, 'F18', 76 /* F18 */, 'F18', 129, 'VK_F18', empty, empty],
        [77, 1, 116 /* F19 */, 'F19', 77 /* F19 */, 'F19', 130, 'VK_F19', empty, empty],
        [0, 1, 117 /* F20 */, 'F20', 0 /* Unknown */, empty, 0, 'VK_F20', empty, empty],
        [0, 1, 118 /* F21 */, 'F21', 0 /* Unknown */, empty, 0, 'VK_F21', empty, empty],
        [0, 1, 119 /* F22 */, 'F22', 0 /* Unknown */, empty, 0, 'VK_F22', empty, empty],
        [0, 1, 120 /* F23 */, 'F23', 0 /* Unknown */, empty, 0, 'VK_F23', empty, empty],
        [0, 1, 121 /* F24 */, 'F24', 0 /* Unknown */, empty, 0, 'VK_F24', empty, empty],
        [0, 1, 122 /* Open */, 'Open', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 123 /* Help */, 'Help', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 124 /* Select */, 'Select', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 125 /* Again */, 'Again', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 126 /* Undo */, 'Undo', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 127 /* Cut */, 'Cut', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 128 /* Copy */, 'Copy', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 129 /* Paste */, 'Paste', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 130 /* Find */, 'Find', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 131 /* AudioVolumeMute */, 'AudioVolumeMute', 112 /* AudioVolumeMute */, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],
        [0, 1, 132 /* AudioVolumeUp */, 'AudioVolumeUp', 113 /* AudioVolumeUp */, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],
        [0, 1, 133 /* AudioVolumeDown */, 'AudioVolumeDown', 114 /* AudioVolumeDown */, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],
        [105, 1, 134 /* NumpadComma */, 'NumpadComma', 105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],
        [110, 0, 135 /* IntlRo */, 'IntlRo', 110 /* ABNT_C1 */, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],
        [0, 1, 136 /* KanaMode */, 'KanaMode', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 0, 137 /* IntlYen */, 'IntlYen', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 138 /* Convert */, 'Convert', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 139 /* NonConvert */, 'NonConvert', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 140 /* Lang1 */, 'Lang1', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 141 /* Lang2 */, 'Lang2', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 142 /* Lang3 */, 'Lang3', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 143 /* Lang4 */, 'Lang4', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 144 /* Lang5 */, 'Lang5', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 145 /* Abort */, 'Abort', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 146 /* Props */, 'Props', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 147 /* NumpadParenLeft */, 'NumpadParenLeft', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 148 /* NumpadParenRight */, 'NumpadParenRight', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 149 /* NumpadBackspace */, 'NumpadBackspace', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 150 /* NumpadMemoryStore */, 'NumpadMemoryStore', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 151 /* NumpadMemoryRecall */, 'NumpadMemoryRecall', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 152 /* NumpadMemoryClear */, 'NumpadMemoryClear', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 153 /* NumpadMemoryAdd */, 'NumpadMemoryAdd', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 154 /* NumpadMemorySubtract */, 'NumpadMemorySubtract', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 155 /* NumpadClear */, 'NumpadClear', 126 /* Clear */, 'Clear', 12, 'VK_CLEAR', empty, empty],
        [0, 1, 156 /* NumpadClearEntry */, 'NumpadClearEntry', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [5, 1, 0 /* None */, empty, 5 /* Ctrl */, 'Ctrl', 17, 'VK_CONTROL', empty, empty],
        [4, 1, 0 /* None */, empty, 4 /* Shift */, 'Shift', 16, 'VK_SHIFT', empty, empty],
        [6, 1, 0 /* None */, empty, 6 /* Alt */, 'Alt', 18, 'VK_MENU', empty, empty],
        [57, 1, 0 /* None */, empty, 57 /* Meta */, 'Meta', 0, 'VK_COMMAND', empty, empty],
        [5, 1, 157 /* ControlLeft */, 'ControlLeft', 5 /* Ctrl */, empty, 0, 'VK_LCONTROL', empty, empty],
        [4, 1, 158 /* ShiftLeft */, 'ShiftLeft', 4 /* Shift */, empty, 0, 'VK_LSHIFT', empty, empty],
        [6, 1, 159 /* AltLeft */, 'AltLeft', 6 /* Alt */, empty, 0, 'VK_LMENU', empty, empty],
        [57, 1, 160 /* MetaLeft */, 'MetaLeft', 57 /* Meta */, empty, 0, 'VK_LWIN', empty, empty],
        [5, 1, 161 /* ControlRight */, 'ControlRight', 5 /* Ctrl */, empty, 0, 'VK_RCONTROL', empty, empty],
        [4, 1, 162 /* ShiftRight */, 'ShiftRight', 4 /* Shift */, empty, 0, 'VK_RSHIFT', empty, empty],
        [6, 1, 163 /* AltRight */, 'AltRight', 6 /* Alt */, empty, 0, 'VK_RMENU', empty, empty],
        [57, 1, 164 /* MetaRight */, 'MetaRight', 57 /* Meta */, empty, 0, 'VK_RWIN', empty, empty],
        [0, 1, 165 /* BrightnessUp */, 'BrightnessUp', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 166 /* BrightnessDown */, 'BrightnessDown', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 167 /* MediaPlay */, 'MediaPlay', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 168 /* MediaRecord */, 'MediaRecord', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 169 /* MediaFastForward */, 'MediaFastForward', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 170 /* MediaRewind */, 'MediaRewind', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [114, 1, 171 /* MediaTrackNext */, 'MediaTrackNext', 119 /* MediaTrackNext */, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],
        [115, 1, 172 /* MediaTrackPrevious */, 'MediaTrackPrevious', 120 /* MediaTrackPrevious */, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],
        [116, 1, 173 /* MediaStop */, 'MediaStop', 121 /* MediaStop */, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],
        [0, 1, 174 /* Eject */, 'Eject', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [117, 1, 175 /* MediaPlayPause */, 'MediaPlayPause', 122 /* MediaPlayPause */, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],
        [0, 1, 176 /* MediaSelect */, 'MediaSelect', 123 /* LaunchMediaPlayer */, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],
        [0, 1, 177 /* LaunchMail */, 'LaunchMail', 124 /* LaunchMail */, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],
        [0, 1, 178 /* LaunchApp2 */, 'LaunchApp2', 125 /* LaunchApp2 */, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],
        [0, 1, 179 /* LaunchApp1 */, 'LaunchApp1', 0 /* Unknown */, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],
        [0, 1, 180 /* SelectTask */, 'SelectTask', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 181 /* LaunchScreenSaver */, 'LaunchScreenSaver', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 182 /* BrowserSearch */, 'BrowserSearch', 115 /* BrowserSearch */, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],
        [0, 1, 183 /* BrowserHome */, 'BrowserHome', 116 /* BrowserHome */, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],
        [112, 1, 184 /* BrowserBack */, 'BrowserBack', 117 /* BrowserBack */, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],
        [113, 1, 185 /* BrowserForward */, 'BrowserForward', 118 /* BrowserForward */, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],
        [0, 1, 186 /* BrowserStop */, 'BrowserStop', 0 /* Unknown */, empty, 0, 'VK_BROWSER_STOP', empty, empty],
        [0, 1, 187 /* BrowserRefresh */, 'BrowserRefresh', 0 /* Unknown */, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],
        [0, 1, 188 /* BrowserFavorites */, 'BrowserFavorites', 0 /* Unknown */, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],
        [0, 1, 189 /* ZoomToggle */, 'ZoomToggle', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 190 /* MailReply */, 'MailReply', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 191 /* MailForward */, 'MailForward', 0 /* Unknown */, empty, 0, empty, empty, empty],
        [0, 1, 192 /* MailSend */, 'MailSend', 0 /* Unknown */, empty, 0, empty, empty, empty],
        // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
        // If an Input Method Editor is processing key input and the event is keydown, return 229.
        [109, 1, 0 /* None */, empty, 109 /* KEY_IN_COMPOSITION */, 'KeyInComposition', 229, empty, empty, empty],
        [111, 1, 0 /* None */, empty, 111 /* ABNT_C2 */, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],
        [91, 1, 0 /* None */, empty, 91 /* OEM_8 */, 'OEM_8', 223, 'VK_OEM_8', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_KANA', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_HANGUL', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_JUNJA', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_FINAL', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_HANJA', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_KANJI', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_CONVERT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_NONCONVERT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_ACCEPT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_MODECHANGE', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_SELECT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_PRINT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_EXECUTE', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_SNAPSHOT', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_HELP', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_APPS', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_PROCESSKEY', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_PACKET', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_ATTN', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_CRSEL', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_EXSEL', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_EREOF', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_PLAY', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_ZOOM', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_NONAME', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_PA1', empty, empty],
        [0, 1, 0 /* None */, empty, 0 /* Unknown */, empty, 0, 'VK_OEM_CLEAR', empty, empty],
    ];
    let seenKeyCode = [];
    let seenScanCode = [];
    for (const mapping of mappings) {
        const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
        if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
            if (immutable) {
                IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
                if ((keyCode !== 0 /* Unknown */)
                    && (keyCode !== 3 /* Enter */)
                    && (keyCode !== 5 /* Ctrl */)
                    && (keyCode !== 4 /* Shift */)
                    && (keyCode !== 6 /* Alt */)
                    && (keyCode !== 57 /* Meta */)) {
                    IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
                }
            }
        }
        if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
                throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
        }
        if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
        }
        if (vkey) {
            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
        }
    }
    // Manually added due to the exclusion above (due to duplication with NumpadEnter)
    IMMUTABLE_KEY_CODE_TO_CODE[3 /* Enter */] = 46 /* Enter */;
})();
var KeyCodeUtils;
(function (KeyCodeUtils) {
    function toString(keyCode) {
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toString = toString;
    function fromString(key) {
        return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromString = fromString;
    function toUserSettingsUS(keyCode) {
        return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
        return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
        if (keyCode >= 93 /* Numpad0 */ && keyCode <= 108 /* NumpadDivide */) {
            // [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it
            // renders them just as regular keys in menus. For example, num0 is rendered as "0",
            // numdiv is rendered as "/", numsub is rendered as "-".
            //
            // This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable
            // from keybindings based on regular keys.
            //
            // We therefore need to fall back to custom rendering for numpad keys.
            return null;
        }
        switch (keyCode) {
            case 16 /* UpArrow */:
                return 'Up';
            case 18 /* DownArrow */:
                return 'Down';
            case 15 /* LeftArrow */:
                return 'Left';
            case 17 /* RightArrow */:
                return 'Right';
        }
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;
    return (firstPart | chordPart) >>> 0;
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lazy": () => (/* binding */ Lazy)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Lazy {
    constructor(executor) {
        this.executor = executor;
        this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    getValue() {
        if (!this._didRun) {
            try {
                this._value = this.executor();
            }
            catch (err) {
                this._error = err;
            }
            finally {
                this._didRun = true;
            }
        }
        if (this._error) {
            throw this._error;
        }
        return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() { return this._value; }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Disposable": () => (/* binding */ Disposable),
/* harmony export */   "DisposableStore": () => (/* binding */ DisposableStore),
/* harmony export */   "ImmortalReference": () => (/* binding */ ImmortalReference),
/* harmony export */   "MultiDisposeError": () => (/* binding */ MultiDisposeError),
/* harmony export */   "MutableDisposable": () => (/* binding */ MutableDisposable),
/* harmony export */   "SafeDisposable": () => (/* binding */ SafeDisposable),
/* harmony export */   "combinedDisposable": () => (/* binding */ combinedDisposable),
/* harmony export */   "dispose": () => (/* binding */ dispose),
/* harmony export */   "isDisposable": () => (/* binding */ isDisposable),
/* harmony export */   "markAsSingleton": () => (/* binding */ markAsSingleton),
/* harmony export */   "setDisposableTracker": () => (/* binding */ setDisposableTracker),
/* harmony export */   "toDisposable": () => (/* binding */ toDisposable)
/* harmony export */ });
/* harmony import */ var _functional_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterator.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
const TRACK_DISPOSABLES = false;
let disposableTracker = null;
function setDisposableTracker(tracker) {
    disposableTracker = tracker;
}
if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = '__is_disposable_tracked__';
    setDisposableTracker(new class {
        trackDisposable(x) {
            const stack = new Error('Potentially leaked disposable').stack;
            setTimeout(() => {
                if (!x[__is_disposable_tracked__]) {
                    console.log(stack);
                }
            }, 3000);
        }
        setParent(child, parent) {
            if (child && child !== Disposable.None) {
                try {
                    child[__is_disposable_tracked__] = true;
                }
                catch (_a) {
                    // noop
                }
            }
        }
        markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
                try {
                    disposable[__is_disposable_tracked__] = true;
                }
                catch (_a) {
                    // noop
                }
            }
        }
        markAsSingleton(disposable) { }
    });
}
function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
}
function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
        return;
    }
    for (const child of children) {
        disposableTracker.setParent(child, parent);
    }
}
/**
 * Indicates that the given object is a singleton which does not need to be disposed.
*/
function markAsSingleton(singleton) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);
    return singleton;
}
class MultiDisposeError extends Error {
    constructor(errors) {
        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);
        this.errors = errors;
    }
}
function isDisposable(thing) {
    return typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
function dispose(arg) {
    if (_iterator_js__WEBPACK_IMPORTED_MODULE_1__.Iterable.is(arg)) {
        let errors = [];
        for (const d of arg) {
            if (d) {
                try {
                    d.dispose();
                }
                catch (e) {
                    errors.push(e);
                }
            }
        }
        if (errors.length === 1) {
            throw errors[0];
        }
        else if (errors.length > 1) {
            throw new MultiDisposeError(errors);
        }
        return Array.isArray(arg) ? [] : arg;
    }
    else if (arg) {
        arg.dispose();
        return arg;
    }
}
function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
}
function toDisposable(fn) {
    const self = trackDisposable({
        dispose: (0,_functional_js__WEBPACK_IMPORTED_MODULE_0__.once)(() => {
            markAsDisposed(self);
            fn();
        })
    });
    return self;
}
class DisposableStore {
    constructor() {
        this._toDispose = new Set();
        this._isDisposed = false;
        trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        markAsDisposed(this);
        this._isDisposed = true;
        this.clear();
    }
    /**
     * Returns `true` if this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
        try {
            dispose(this._toDispose.values());
        }
        finally {
            this._toDispose.clear();
        }
    }
    add(o) {
        if (!o) {
            return o;
        }
        if (o === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        setParentOfDisposable(o, this);
        if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);
            }
        }
        else {
            this._toDispose.add(o);
        }
        return o;
    }
}
DisposableStore.DISABLE_DISPOSED_WARNING = false;
class Disposable {
    constructor() {
        this._store = new DisposableStore();
        trackDisposable(this);
        setParentOfDisposable(this._store, this);
    }
    dispose() {
        markAsDisposed(this);
        this._store.dispose();
    }
    _register(o) {
        if (o === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        return this._store.add(o);
    }
}
Disposable.None = Object.freeze({ dispose() { } });
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
class MutableDisposable {
    constructor() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    get value() {
        return this._isDisposed ? undefined : this._value;
    }
    set value(value) {
        var _a;
        if (this._isDisposed || value === this._value) {
            return;
        }
        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
        if (value) {
            setParentOfDisposable(value, this);
        }
        this._value = value;
    }
    clear() {
        this.value = undefined;
    }
    dispose() {
        var _a;
        this._isDisposed = true;
        markAsDisposed(this);
        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();
        this._value = undefined;
    }
    /**
     * Clears the value, but does not dispose it.
     * The old value is returned.
    */
    clearAndLeak() {
        const oldValue = this._value;
        this._value = undefined;
        if (oldValue) {
            setParentOfDisposable(oldValue, null);
        }
        return oldValue;
    }
}
/**
 * A safe disposable can be `unset` so that a leaked reference (listener)
 * can be cut-off.
 */
class SafeDisposable {
    constructor() {
        this.dispose = () => { };
        this.unset = () => { };
        this.isset = () => false;
        trackDisposable(this);
    }
    set(fn) {
        let callback = fn;
        this.unset = () => callback = undefined;
        this.isset = () => callback !== undefined;
        this.dispose = () => {
            if (callback) {
                callback();
                callback = undefined;
                markAsDisposed(this);
            }
        };
        return this;
    }
}
class ImmortalReference {
    constructor(object) {
        this.object = object;
    }
    dispose() { }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkedList": () => (/* binding */ LinkedList)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class Node {
    constructor(element) {
        this.element = element;
        this.next = Node.Undefined;
        this.prev = Node.Undefined;
    }
}
Node.Undefined = new Node(undefined);
class LinkedList {
    constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    get size() {
        return this._size;
    }
    isEmpty() {
        return this._first === Node.Undefined;
    }
    clear() {
        let node = this._first;
        while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
        }
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    unshift(element) {
        return this._insert(element, false);
    }
    push(element) {
        return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
        }
        else if (atTheEnd) {
            // push
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
        }
        else {
            // unshift
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
            if (!didRemove) {
                didRemove = true;
                this._remove(newNode);
            }
        };
    }
    shift() {
        if (this._first === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
        }
    }
    pop() {
        if (this._last === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
        }
    }
    _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            // middle
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
        }
        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            // only node
            this._first = Node.Undefined;
            this._last = Node.Undefined;
        }
        else if (node.next === Node.Undefined) {
            // last
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
        }
        else if (node.prev === Node.Undefined) {
            // first
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
        }
        // done
        this._size -= 1;
    }
    *[Symbol.iterator]() {
        let node = this._first;
        while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
        }
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cloneAndChange": () => (/* binding */ cloneAndChange),
/* harmony export */   "deepClone": () => (/* binding */ deepClone),
/* harmony export */   "deepFreeze": () => (/* binding */ deepFreeze),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "getOrDefault": () => (/* binding */ getOrDefault),
/* harmony export */   "mixin": () => (/* binding */ mixin)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function deepClone(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof RegExp) {
        // See https://github.com/microsoft/TypeScript/issues/10990
        return obj;
    }
    const result = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach((key) => {
        if (obj[key] && typeof obj[key] === 'object') {
            result[key] = deepClone(obj[key]);
        }
        else {
            result[key] = obj[key];
        }
    });
    return result;
}
function deepFreeze(obj) {
    if (!obj || typeof obj !== 'object') {
        return obj;
    }
    const stack = [obj];
    while (stack.length > 0) {
        const obj = stack.shift();
        Object.freeze(obj);
        for (const key in obj) {
            if (_hasOwnProperty.call(obj, key)) {
                const prop = obj[key];
                if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                    stack.push(prop);
                }
            }
        }
    }
    return obj;
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneAndChange(obj, changer) {
    return _cloneAndChange(obj, changer, new Set());
}
function _cloneAndChange(obj, changer, seen) {
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isUndefinedOrNull)(obj)) {
        return obj;
    }
    const changed = changer(obj);
    if (typeof changed !== 'undefined') {
        return changed;
    }
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj)) {
        const r1 = [];
        for (const e of obj) {
            r1.push(_cloneAndChange(e, changer, seen));
        }
        return r1;
    }
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(obj)) {
        if (seen.has(obj)) {
            throw new Error('Cannot clone recursive data-structure');
        }
        seen.add(obj);
        const r2 = {};
        for (let i2 in obj) {
            if (_hasOwnProperty.call(obj, i2)) {
                r2[i2] = _cloneAndChange(obj[i2], changer, seen);
            }
        }
        seen.delete(obj);
        return r2;
    }
    return obj;
}
/**
 * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
 * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
 */
function mixin(destination, source, overwrite = true) {
    if (!(0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination)) {
        return source;
    }
    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
        Object.keys(source).forEach(key => {
            if (key in destination) {
                if (overwrite) {
                    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(destination[key]) && (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null || one === undefined || other === null || other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if ((Array.isArray(one)) !== (Array.isArray(other))) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
function getOrDefault(obj, fn, defaultValue) {
    const result = fn(obj);
    return typeof result === 'undefined' ? defaultValue : result;
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basename": () => (/* binding */ basename),
/* harmony export */   "dirname": () => (/* binding */ dirname),
/* harmony export */   "extname": () => (/* binding */ extname),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "posix": () => (/* binding */ posix),
/* harmony export */   "relative": () => (/* binding */ relative),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "sep": () => (/* binding */ sep),
/* harmony export */   "win32": () => (/* binding */ win32)
/* harmony export */ });
/* harmony import */ var _process_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace
// Copied from: https://github.com/nodejs/node/blob/v14.16.0/lib/path.js
/**
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const CHAR_UPPERCASE_A = 65; /* A */
const CHAR_LOWERCASE_A = 97; /* a */
const CHAR_UPPERCASE_Z = 90; /* Z */
const CHAR_LOWERCASE_Z = 122; /* z */
const CHAR_DOT = 46; /* . */
const CHAR_FORWARD_SLASH = 47; /* / */
const CHAR_BACKWARD_SLASH = 92; /* \ */
const CHAR_COLON = 58; /* : */
const CHAR_QUESTION_MARK = 63; /* ? */
class ErrorInvalidArgType extends Error {
    constructor(name, expected, actual) {
        // determiner: 'must be' or 'must not be'
        let determiner;
        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {
            determiner = 'must not be';
            expected = expected.replace(/^not /, '');
        }
        else {
            determiner = 'must be';
        }
        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';
        let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
        msg += `. Received type ${typeof actual}`;
        super(msg);
        this.code = 'ERR_INVALID_ARG_TYPE';
    }
}
function validateString(value, name) {
    if (typeof value !== 'string') {
        throw new ErrorInvalidArgType(name, 'string', value);
    }
}
function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||
        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);
}
// Resolves . and .. elements in a path with directory names
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = '';
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
        if (i < path.length) {
            code = path.charCodeAt(i);
        }
        else if (isPathSeparator(code)) {
            break;
        }
        else {
            code = CHAR_FORWARD_SLASH;
        }
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {
                // NOOP
            }
            else if (dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 ||
                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||
                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = '';
                            lastSegmentLength = 0;
                        }
                        else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                    else if (res.length !== 0) {
                        res = '';
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    res += res.length > 0 ? `${separator}..` : '..';
                    lastSegmentLength = 2;
                }
            }
            else {
                if (res.length > 0) {
                    res += `${separator}${path.slice(lastSlash + 1, i)}`;
                }
                else {
                    res = path.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        }
        else if (code === CHAR_DOT && dots !== -1) {
            ++dots;
        }
        else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);
    }
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base ||
        `${pathObject.name || ''}${pathObject.ext || ''}`;
    if (!dir) {
        return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;
}
const win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedDevice = '';
        let resolvedTail = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
                validateString(path, 'path');
                // Skip empty entries
                if (path.length === 0) {
                    continue;
                }
            }
            else if (resolvedDevice.length === 0) {
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
            }
            else {
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = _process_js__WEBPACK_IMPORTED_MODULE_0__.env[`=${resolvedDevice}`] || _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&
                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {
                    path = `${resolvedDevice}\\`;
                }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = '';
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len === 1) {
                if (isPathSeparator(code)) {
                    // `path` contains just a path separator
                    rootEnd = 1;
                    isAbsolute = true;
                }
            }
            else if (isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an
                // absolute path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        while (j < len && isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                                j++;
                            }
                            if (j === len || j !== last) {
                                // We matched a UNC root
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON) {
                // Possible device root
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                    // Treat separator following drive name as an absolute path
                    // indicator
                    isAbsolute = true;
                    rootEnd = 3;
                }
            }
            if (device.length > 0) {
                if (resolvedDevice.length > 0) {
                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                        // This path points to another device so it is not applicable
                        continue;
                    }
                }
                else {
                    resolvedDevice = device;
                }
            }
            if (resolvedAbsolute) {
                if (resolvedDevice.length > 0) {
                    break;
                }
            }
            else {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
                if (isAbsolute && resolvedDevice.length > 0) {
                    break;
                }
            }
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isPathSeparator);
        return resolvedAbsolute ?
            `${resolvedDevice}\\${resolvedTail}` :
            `${resolvedDevice}${resolvedTail}` || '.';
    },
    normalize(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len === 1) {
            // `path` contains just a single char, exit early to avoid
            // unnecessary work
            return isPosixPathSeparator(code) ? '\\' : path;
        }
        if (isPathSeparator(code)) {
            // Possible UNC root
            // If we started with a separator, we know we at least have an absolute
            // path of some kind (UNC or otherwise)
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            // Return the normalized version of the UNC root since there
                            // is nothing left to process
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            }
            else {
                rootEnd = 1;
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                // Treat separator following drive name as an absolute path
                // indicator
                isAbsolute = true;
                rootEnd = 3;
            }
        }
        let tail = rootEnd < len ?
            normalizeString(path.slice(rootEnd), !isAbsolute, '\\', isPathSeparator) :
            '';
        if (tail.length === 0 && !isAbsolute) {
            tail = '.';
        }
        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += '\\';
        }
        if (device === undefined) {
            return isAbsolute ? `\\${tail}` : tail;
        }
        return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return false;
        }
        const code = path.charCodeAt(0);
        return isPathSeparator(code) ||
            // Possible device root
            (len > 2 &&
                isWindowsDeviceRoot(code) &&
                path.charCodeAt(1) === CHAR_COLON &&
                isPathSeparator(path.charCodeAt(2)));
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        let firstPart;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = firstPart = arg;
                }
                else {
                    joined += `\\${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for a UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at a UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as a UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) {
                        ++slashCount;
                    }
                    else {
                        // We matched a UNC path in the first part
                        needsReplace = false;
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            while (slashCount < joined.length &&
                isPathSeparator(joined.charCodeAt(slashCount))) {
                slashCount++;
            }
            // Replace the slashes if needed
            if (slashCount >= 2) {
                joined = `\\${joined.slice(slashCount)}`;
            }
        }
        return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        const fromOrig = win32.resolve(from);
        const toOrig = win32.resolve(to);
        if (fromOrig === toOrig) {
            return '';
        }
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to) {
            return '';
        }
        // Trim any leading backslashes
        let fromStart = 0;
        while (fromStart < from.length &&
            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let fromEnd = from.length;
        while (fromEnd - 1 > fromStart &&
            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        while (toStart < to.length &&
            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        let toEnd = to.length;
        while (toEnd - 1 > toStart &&
            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length) {
            if (lastCommonSep === -1) {
                return toOrig;
            }
        }
        else {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                    return toOrig.slice(toStart + i + 1);
                }
                if (i === 2) {
                    // We get here if `from` is the device root.
                    // For example: from='C:\\'; to='C:\\foo'
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='C:\\foo\\bar'; to='C:\\foo'
                    lastCommonSep = i;
                }
                else if (i === 2) {
                    // We get here if `to` is the device root.
                    // For example: from='C:\\foo\\bar'; to='C:\\'
                    lastCommonSep = 3;
                }
            }
            if (lastCommonSep === -1) {
                lastCommonSep = 0;
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
                out += out.length === 0 ? '..' : '\\..';
            }
        }
        toStart += lastCommonSep;
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
        }
        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
        }
        return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== 'string') {
            return path;
        }
        if (path.length === 0) {
            return '';
        }
        const resolvedPath = win32.resolve(path);
        if (resolvedPath.length <= 2) {
            return path;
        }
        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            // Possible UNC root
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                    // Matched non-long UNC root, convert the path to a long UNC path
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        }
        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&
            resolvedPath.charCodeAt(1) === CHAR_COLON &&
            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            // Matched device root, convert the path to a long UNC path
            return `\\\\?\\${resolvedPath}`;
        }
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        const len = path.length;
        if (len === 0) {
            return '.';
        }
        let rootEnd = -1;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len === 1) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work or a dot.
            return isPathSeparator(code) ? path : '.';
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            return path;
                        }
                        if (j !== last) {
                            // We matched a UNC root with leftovers
                            // Offset by 1 to include the separator after the UNC root to
                            // treat it as a "normal root" on top of a (UNC) root
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
            // Possible device root
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
        }
        let end = -1;
        let matchedSlash = true;
        for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1) {
                return '.';
            }
            end = rootEnd;
        }
        return path.slice(0, end);
    },
    basename(path, ext) {
        if (ext !== undefined) {
            validateString(ext, 'ext');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            isWindowsDeviceRoot(path.charCodeAt(0)) &&
            path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
                return '';
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === CHAR_COLON &&
            isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '\\'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const len = path.length;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len === 1) {
            if (isPathSeparator(code)) {
                // `path` contains just a path separator, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            ret.base = ret.name = path;
            return ret;
        }
        // Try to match a root
        if (isPathSeparator(code)) {
            // Possible UNC root
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                // Matched double path separator at beginning
                let j = 2;
                let last = j;
                // Match 1 or more non-path separators
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                }
                if (j < len && j !== last) {
                    // Matched!
                    last = j;
                    // Match 1 or more path separators
                    while (j < len && isPathSeparator(path.charCodeAt(j))) {
                        j++;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more non-path separators
                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                            j++;
                        }
                        if (j === len) {
                            // We matched a UNC root only
                            rootEnd = j;
                        }
                        else if (j !== last) {
                            // We matched a UNC root with leftovers
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        }
        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            // Possible device root
            if (len <= 2) {
                // `path` contains just a drive root, exit early to avoid
                // unnecessary work
                ret.root = ret.dir = path;
                return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
                if (len === 3) {
                    // `path` contains just a drive root, exit early to avoid
                    // unnecessary work
                    ret.root = ret.dir = path;
                    return ret;
                }
                rootEnd = 3;
            }
        }
        if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
        }
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(startPart, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else {
            ret.dir = ret.root;
        }
        return ret;
    },
    sep: '\\',
    delimiter: ';',
    win32: null,
    posix: null
};
const posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
        let resolvedPath = '';
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : _process_js__WEBPACK_IMPORTED_MODULE_0__.cwd();
            validateString(path, 'path');
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);
        if (resolvedAbsolute) {
            return `/${resolvedPath}`;
        }
        return resolvedPath.length > 0 ? resolvedPath : '.';
    },
    normalize(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
        // Normalize the path
        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);
        if (path.length === 0) {
            if (isAbsolute) {
                return '/';
            }
            return trailingSeparator ? './' : '.';
        }
        if (trailingSeparator) {
            path += '/';
        }
        return isAbsolute ? `/${path}` : path;
    },
    isAbsolute(path) {
        validateString(path, 'path');
        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
        if (paths.length === 0) {
            return '.';
        }
        let joined;
        for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, 'path');
            if (arg.length > 0) {
                if (joined === undefined) {
                    joined = arg;
                }
                else {
                    joined += `/${arg}`;
                }
            }
        }
        if (joined === undefined) {
            return '.';
        }
        return posix.normalize(joined);
    },
    relative(from, to) {
        validateString(from, 'from');
        validateString(to, 'to');
        if (from === to) {
            return '';
        }
        // Trim leading forward slashes.
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) {
            return '';
        }
        const fromStart = 1;
        const fromEnd = from.length;
        const fromLen = fromEnd - fromStart;
        const toStart = 1;
        const toLen = to.length - toStart;
        // Compare paths to find the longest common path from root
        const length = (fromLen < toLen ? fromLen : toLen);
        let lastCommonSep = -1;
        let i = 0;
        for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
                break;
            }
            else if (fromCode === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
            }
        }
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `from` is the exact base path for `to`.
                    // For example: from='/foo/bar'; to='/foo/bar/baz'
                    return to.slice(toStart + i + 1);
                }
                if (i === 0) {
                    // We get here if `from` is the root
                    // For example: from='/'; to='/foo'
                    return to.slice(toStart + i);
                }
            }
            else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                    // We get here if `to` is the exact base path for `from`.
                    // For example: from='/foo/bar/baz'; to='/foo/bar'
                    lastCommonSep = i;
                }
                else if (i === 0) {
                    // We get here if `to` is the root.
                    // For example: from='/foo/bar'; to='/'
                    lastCommonSep = 0;
                }
            }
        }
        let out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`.
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                out += out.length === 0 ? '..' : '/..';
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts.
        return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    },
    dirname(path) {
        validateString(path, 'path');
        if (path.length === 0) {
            return '.';
        }
        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            return hasRoot ? '/' : '.';
        }
        if (hasRoot && end === 1) {
            return '//';
        }
        return path.slice(0, end);
    },
    basename(path, ext) {
        if (ext !== undefined) {
            validateString(ext, 'ext');
        }
        validateString(path, 'path');
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
                return '';
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) {
                end = firstNonSlashEnd;
            }
            else if (end === -1) {
                end = path.length;
            }
            return path.slice(start, end);
        }
        for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) {
            return '';
        }
        return path.slice(start, end);
    },
    extname(path) {
        validateString(path, 'path');
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 &&
                startDot === end - 1 &&
                startDot === startPart + 1)) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: _format.bind(null, '/'),
    parse(path) {
        validateString(path, 'path');
        const ret = { root: '', dir: '', base: '', ext: '', name: '' };
        if (path.length === 0) {
            return ret;
        }
        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) {
                    startDot = i;
                }
                else if (preDotState !== 1) {
                    preDotState = 1;
                }
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (end !== -1) {
            const start = startPart === 0 && isAbsolute ? 1 : startPart;
            if (startDot === -1 ||
                // We saw a non-dot character immediately before the dot
                preDotState === 0 ||
                // The (right-most) trimmed path component is exactly '..'
                (preDotState === 1 &&
                    startDot === end - 1 &&
                    startDot === startPart + 1)) {
                ret.base = ret.name = path.slice(start, end);
            }
            else {
                ret.name = path.slice(start, startDot);
                ret.base = path.slice(start, end);
                ret.ext = path.slice(startDot, end);
            }
        }
        if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else if (isAbsolute) {
            ret.dir = '/';
        }
        return ret;
    },
    sep: '/',
    delimiter: ':',
    win32: null,
    posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
const normalize = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.normalize : posix.normalize);
const resolve = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.resolve : posix.resolve);
const relative = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.relative : posix.relative);
const dirname = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.dirname : posix.dirname);
const basename = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.basename : posix.basename);
const extname = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.extname : posix.extname);
const sep = (_process_js__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32' ? win32.sep : posix.sep);


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OS": () => (/* binding */ OS),
/* harmony export */   "globals": () => (/* binding */ globals),
/* harmony export */   "isAndroid": () => (/* binding */ isAndroid),
/* harmony export */   "isChrome": () => (/* binding */ isChrome),
/* harmony export */   "isEdge": () => (/* binding */ isEdge),
/* harmony export */   "isFirefox": () => (/* binding */ isFirefox),
/* harmony export */   "isIOS": () => (/* binding */ isIOS),
/* harmony export */   "isLinux": () => (/* binding */ isLinux),
/* harmony export */   "isLittleEndian": () => (/* binding */ isLittleEndian),
/* harmony export */   "isMacintosh": () => (/* binding */ isMacintosh),
/* harmony export */   "isNative": () => (/* binding */ isNative),
/* harmony export */   "isSafari": () => (/* binding */ isSafari),
/* harmony export */   "isWeb": () => (/* binding */ isWeb),
/* harmony export */   "isWebWorker": () => (/* binding */ isWebWorker),
/* harmony export */   "isWindows": () => (/* binding */ isWindows),
/* harmony export */   "language": () => (/* binding */ language),
/* harmony export */   "setTimeout0": () => (/* binding */ setTimeout0),
/* harmony export */   "userAgent": () => (/* binding */ userAgent)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
const LANGUAGE_DEFAULT = 'en';
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isLinuxSnap = false;
let _isNative = false;
let _isWeb = false;
let _isElectron = false;
let _isIOS = false;
let _isCI = false;
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _translationsConfigFile = undefined;
let _userAgent = undefined;
const globals = (typeof self === 'object' ? self : typeof __webpack_require__.g === 'object' ? __webpack_require__.g : {});
let nodeProcess = undefined;
if (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {
    // Native environment (sandboxed)
    nodeProcess = globals.vscode.process;
}
else if (typeof process !== 'undefined') {
    // Native environment (non-sandboxed)
    nodeProcess = process;
}
const isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === 'string';
const isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === 'renderer';
// Web environment
if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf('Windows') >= 0;
    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf('Linux') >= 0;
    _isWeb = true;
    _locale = navigator.language;
    _language = _locale;
}
// Native environment
else if (typeof nodeProcess === 'object') {
    _isWindows = (nodeProcess.platform === 'win32');
    _isMacintosh = (nodeProcess.platform === 'darwin');
    _isLinux = (nodeProcess.platform === 'linux');
    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages['*'];
            _locale = nlsConfig.locale;
            // VSCode's default language is 'en'
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
        }
        catch (e) {
        }
    }
    _isNative = true;
}
// Unknown environment
else {
    console.error('Unable to resolve platform.');
}
let _platform = 0 /* Web */;
if (_isMacintosh) {
    _platform = 1 /* Mac */;
}
else if (_isWindows) {
    _platform = 3 /* Windows */;
}
else if (_isLinux) {
    _platform = 2 /* Linux */;
}
const isWindows = _isWindows;
const isMacintosh = _isMacintosh;
const isLinux = _isLinux;
const isNative = _isNative;
const isWeb = _isWeb;
const isWebWorker = (_isWeb && typeof globals.importScripts === 'function');
const isIOS = _isIOS;
const userAgent = _userAgent;
/**
 * The language used for the user interface. The format of
 * the string is all lower case (e.g. zh-tw for Traditional
 * Chinese)
 */
const language = _language;
/**
 * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
 *
 * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay
 * that browsers set when the nesting level is > 5.
 */
const setTimeout0 = (() => {
    if (typeof globals.postMessage === 'function' && !globals.importScripts) {
        let pending = [];
        globals.addEventListener('message', (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
                for (let i = 0, len = pending.length; i < len; i++) {
                    const candidate = pending[i];
                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                        pending.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        let lastId = 0;
        return (callback) => {
            const myId = ++lastId;
            pending.push({
                id: myId,
                callback: callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, '*');
        };
    }
    return (callback) => setTimeout(callback);
})();
const OS = (_isMacintosh || _isIOS ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
    if (!_isLittleEndianComputed) {
        _isLittleEndianComputed = true;
        const test = new Uint8Array(2);
        test[0] = 1;
        test[1] = 2;
        const view = new Uint16Array(test.buffer);
        _isLittleEndian = (view[0] === (2 << 8) + 1);
    }
    return _isLittleEndian;
}
const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);
const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);
const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));
const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);
const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/process.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwd": () => (/* binding */ cwd),
/* harmony export */   "env": () => (/* binding */ env),
/* harmony export */   "platform": () => (/* binding */ platform)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

let safeProcess;
// Native sandbox environment
if (typeof _platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.vscode !== 'undefined' && typeof _platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.vscode.process !== 'undefined') {
    const sandboxProcess = _platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.vscode.process;
    safeProcess = {
        get platform() { return sandboxProcess.platform; },
        get arch() { return sandboxProcess.arch; },
        get env() { return sandboxProcess.env; },
        cwd() { return sandboxProcess.cwd(); }
    };
}
// Native node.js environment
else if (typeof process !== 'undefined') {
    safeProcess = {
        get platform() { return process.platform; },
        get arch() { return process.arch; },
        get env() { return process.env; },
        cwd() { return process.env['VSCODE_CWD'] || process.cwd(); }
    };
}
// Web environment
else {
    safeProcess = {
        // Supported
        get platform() { return _platform_js__WEBPACK_IMPORTED_MODULE_0__.isWindows ? 'win32' : _platform_js__WEBPACK_IMPORTED_MODULE_0__.isMacintosh ? 'darwin' : 'linux'; },
        get arch() { return undefined; /* arch is undefined in web */ },
        // Unsupported
        get env() { return {}; },
        cwd() { return '/'; }
    };
}
/**
 * Provides safe access to the `cwd` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `/`.
 */
const cwd = safeProcess.cwd;
/**
 * Provides safe access to the `env` property in node.js, sandboxed or web
 * environments.
 *
 * Note: in web, this property is hardcoded to be `{}`.
 */
const env = safeProcess.env;
/**
 * Provides safe access to the `platform` property in node.js, sandboxed or web
 * environments.
 */
const platform = safeProcess.platform;


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StopWatch": () => (/* binding */ StopWatch)
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

const hasPerformanceNow = (_platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.performance && typeof _platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.performance.now === 'function');
class StopWatch {
    constructor(highResolution) {
        this._highResolution = hasPerformanceNow && highResolution;
        this._startTime = this._now();
        this._stopTime = -1;
    }
    static create(highResolution = true) {
        return new StopWatch(highResolution);
    }
    stop() {
        this._stopTime = this._now();
    }
    elapsed() {
        if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
        }
        return this._now() - this._startTime;
    }
    _now() {
        return this._highResolution ? _platform_js__WEBPACK_IMPORTED_MODULE_0__.globals.performance.now() : Date.now();
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AmbiguousCharacters": () => (/* binding */ AmbiguousCharacters),
/* harmony export */   "CodePointIterator": () => (/* binding */ CodePointIterator),
/* harmony export */   "GraphemeIterator": () => (/* binding */ GraphemeIterator),
/* harmony export */   "InvisibleCharacters": () => (/* binding */ InvisibleCharacters),
/* harmony export */   "UNUSUAL_LINE_TERMINATORS": () => (/* binding */ UNUSUAL_LINE_TERMINATORS),
/* harmony export */   "UTF8_BOM_CHARACTER": () => (/* binding */ UTF8_BOM_CHARACTER),
/* harmony export */   "commonPrefixLength": () => (/* binding */ commonPrefixLength),
/* harmony export */   "commonSuffixLength": () => (/* binding */ commonSuffixLength),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "compareIgnoreCase": () => (/* binding */ compareIgnoreCase),
/* harmony export */   "compareSubstring": () => (/* binding */ compareSubstring),
/* harmony export */   "compareSubstringIgnoreCase": () => (/* binding */ compareSubstringIgnoreCase),
/* harmony export */   "computeCodePoint": () => (/* binding */ computeCodePoint),
/* harmony export */   "containsRTL": () => (/* binding */ containsRTL),
/* harmony export */   "containsUnusualLineTerminators": () => (/* binding */ containsUnusualLineTerminators),
/* harmony export */   "containsUppercaseCharacter": () => (/* binding */ containsUppercaseCharacter),
/* harmony export */   "convertSimple2RegExpPattern": () => (/* binding */ convertSimple2RegExpPattern),
/* harmony export */   "createRegExp": () => (/* binding */ createRegExp),
/* harmony export */   "equalsIgnoreCase": () => (/* binding */ equalsIgnoreCase),
/* harmony export */   "escape": () => (/* binding */ escape),
/* harmony export */   "escapeRegExpCharacters": () => (/* binding */ escapeRegExpCharacters),
/* harmony export */   "firstNonWhitespaceIndex": () => (/* binding */ firstNonWhitespaceIndex),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "getCharContainingOffset": () => (/* binding */ getCharContainingOffset),
/* harmony export */   "getLeadingWhitespace": () => (/* binding */ getLeadingWhitespace),
/* harmony export */   "getLeftDeleteOffset": () => (/* binding */ getLeftDeleteOffset),
/* harmony export */   "getNextCodePoint": () => (/* binding */ getNextCodePoint),
/* harmony export */   "isBasicASCII": () => (/* binding */ isBasicASCII),
/* harmony export */   "isEmojiImprecise": () => (/* binding */ isEmojiImprecise),
/* harmony export */   "isFalsyOrWhitespace": () => (/* binding */ isFalsyOrWhitespace),
/* harmony export */   "isFullWidthCharacter": () => (/* binding */ isFullWidthCharacter),
/* harmony export */   "isHighSurrogate": () => (/* binding */ isHighSurrogate),
/* harmony export */   "isLowSurrogate": () => (/* binding */ isLowSurrogate),
/* harmony export */   "isLowerAsciiLetter": () => (/* binding */ isLowerAsciiLetter),
/* harmony export */   "isUpperAsciiLetter": () => (/* binding */ isUpperAsciiLetter),
/* harmony export */   "lastNonWhitespaceIndex": () => (/* binding */ lastNonWhitespaceIndex),
/* harmony export */   "ltrim": () => (/* binding */ ltrim),
/* harmony export */   "nextCharLength": () => (/* binding */ nextCharLength),
/* harmony export */   "noBreakWhitespace": () => (/* binding */ noBreakWhitespace),
/* harmony export */   "prevCharLength": () => (/* binding */ prevCharLength),
/* harmony export */   "regExpFlags": () => (/* binding */ regExpFlags),
/* harmony export */   "regExpLeadsToEndlessLoop": () => (/* binding */ regExpLeadsToEndlessLoop),
/* harmony export */   "rtrim": () => (/* binding */ rtrim),
/* harmony export */   "singleLetterHash": () => (/* binding */ singleLetterHash),
/* harmony export */   "splitLines": () => (/* binding */ splitLines),
/* harmony export */   "startsWithIgnoreCase": () => (/* binding */ startsWithIgnoreCase),
/* harmony export */   "startsWithUTF8BOM": () => (/* binding */ startsWithUTF8BOM),
/* harmony export */   "stripWildcards": () => (/* binding */ stripWildcards),
/* harmony export */   "trim": () => (/* binding */ trim)
/* harmony export */ });
/* harmony import */ var _cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;


function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== 'string') {
        return true;
    }
    return str.trim().length === 0;
}
const _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */
function format(value, ...args) {
    if (args.length === 0) {
        return value;
    }
    return value.replace(_formatRegexp, function (match, group) {
        const idx = parseInt(group, 10);
        return isNaN(idx) || idx < 0 || idx >= args.length ?
            match :
            args[idx];
    });
}
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */
function escape(html) {
    return html.replace(/[<>&]/g, function (match) {
        switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            default: return match;
        }
    });
}
/**
 * Escapes regular expression characters in a given string
 */
function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */
function trim(haystack, needle = ' ') {
    const trimmed = ltrim(haystack, needle);
    return rtrim(trimmed, needle);
}
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function ltrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length;
    if (needleLen === 0 || haystack.length === 0) {
        return haystack;
    }
    let offset = 0;
    while (haystack.indexOf(needle, offset) === offset) {
        offset = offset + needleLen;
    }
    return haystack.substring(offset);
}
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function rtrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    const needleLen = needle.length, haystackLen = haystack.length;
    if (needleLen === 0 || haystackLen === 0) {
        return haystack;
    }
    let offset = haystackLen, idx = -1;
    while (true) {
        idx = haystack.lastIndexOf(needle, offset - 1);
        if (idx === -1 || idx + needleLen !== offset) {
            break;
        }
        if (idx === 0) {
            return '';
        }
        offset = idx;
    }
    return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
function stripWildcards(pattern) {
    return pattern.replace(/\*/g, '');
}
function createRegExp(searchString, isRegex, options = {}) {
    if (!searchString) {
        throw new Error('Cannot create regex from empty string');
    }
    if (!isRegex) {
        searchString = escapeRegExpCharacters(searchString);
    }
    if (options.wholeWord) {
        if (!/\B/.test(searchString.charAt(0))) {
            searchString = '\\b' + searchString;
        }
        if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
            searchString = searchString + '\\b';
        }
    }
    let modifiers = '';
    if (options.global) {
        modifiers += 'g';
    }
    if (!options.matchCase) {
        modifiers += 'i';
    }
    if (options.multiline) {
        modifiers += 'm';
    }
    if (options.unicode) {
        modifiers += 'u';
    }
    return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    const match = regexp.exec('');
    return !!(match && regexp.lastIndex === 0);
}
function regExpFlags(regexp) {
    return (regexp.global ? 'g' : '')
        + (regexp.ignoreCase ? 'i' : '')
        + (regexp.multiline ? 'm' : '')
        + (regexp /* standalone editor compilation */.unicode ? 'u' : '');
}
function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
}
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */
function getLeadingWhitespace(str, start = 0, end = str.length) {
    for (let i = start; i < end; i++) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return str.substring(start, i);
        }
    }
    return str.substring(start, end);
}
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
        const chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a > b) {
        return 1;
    }
    else {
        return 0;
    }
}
function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        let codeA = a.charCodeAt(aStart);
        let codeB = b.charCodeAt(bStart);
        if (codeA < codeB) {
            return -1;
        }
        else if (codeA > codeB) {
            return 1;
        }
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function compareIgnoreCase(a, b) {
    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
}
function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
        let codeA = a.charCodeAt(aStart);
        let codeB = b.charCodeAt(bStart);
        if (codeA === codeB) {
            // equal
            continue;
        }
        if (codeA >= 128 || codeB >= 128) {
            // not ASCII letters -> fallback to lower-casing strings
            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
        }
        // mapper lower-case ascii letter onto upper-case varinats
        // [97-122] (lower ascii) --> [65-90] (upper ascii)
        if (isLowerAsciiLetter(codeA)) {
            codeA -= 32;
        }
        if (isLowerAsciiLetter(codeB)) {
            codeB -= 32;
        }
        // compare both code points
        const diff = codeA - codeB;
        if (diff === 0) {
            continue;
        }
        return diff;
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
        return -1;
    }
    else if (aLen > bLen) {
        return 1;
    }
    return 0;
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function equalsIgnoreCase(a, b) {
    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
}
function startsWithIgnoreCase(str, candidate) {
    const candidateLength = candidate.length;
    if (candidate.length > str.length) {
        return false;
    }
    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
}
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    let i, len = Math.min(a.length, b.length);
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
/**
 * @returns the length of the common suffix of the two strings.
 */
function commonSuffixLength(a, b) {
    let i, len = Math.min(a.length, b.length);
    const aLastIndex = a.length - 1;
    const bLastIndex = b.length - 1;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
            return i;
        }
    }
    return len;
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
/**
 * See http://en.wikipedia.org/wiki/Surrogate_pair
 */
function computeCodePoint(highSurrogate, lowSurrogate) {
    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;
}
/**
 * get the code point that begins at offset `offset`
 */
function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
        const nextCharCode = str.charCodeAt(offset + 1);
        if (isLowSurrogate(nextCharCode)) {
            return computeCodePoint(charCode, nextCharCode);
        }
    }
    return charCode;
}
/**
 * get the code point that ends right before offset `offset`
 */
function getPrevCodePoint(str, offset) {
    const charCode = str.charCodeAt(offset - 1);
    if (isLowSurrogate(charCode) && offset > 1) {
        const prevCharCode = str.charCodeAt(offset - 2);
        if (isHighSurrogate(prevCharCode)) {
            return computeCodePoint(prevCharCode, charCode);
        }
    }
    return charCode;
}
class CodePointIterator {
    constructor(str, offset = 0) {
        this._str = str;
        this._len = str.length;
        this._offset = offset;
    }
    get offset() {
        return this._offset;
    }
    setOffset(offset) {
        this._offset = offset;
    }
    prevCodePoint() {
        const codePoint = getPrevCodePoint(this._str, this._offset);
        this._offset -= (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        return codePoint;
    }
    nextCodePoint() {
        const codePoint = getNextCodePoint(this._str, this._len, this._offset);
        this._offset += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        return codePoint;
    }
    eol() {
        return (this._offset >= this._len);
    }
}
class GraphemeIterator {
    constructor(str, offset = 0) {
        this._iterator = new CodePointIterator(str, offset);
    }
    get offset() {
        return this._iterator.offset;
    }
    nextGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
        while (!iterator.eol()) {
            const offset = iterator.offset;
            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
                // move iterator back
                iterator.setOffset(offset);
                break;
            }
            graphemeBreakType = nextGraphemeBreakType;
        }
        return (iterator.offset - initialOffset);
    }
    prevGraphemeLength() {
        const graphemeBreakTree = GraphemeBreakTree.getInstance();
        const iterator = this._iterator;
        const initialOffset = iterator.offset;
        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
        while (iterator.offset > 0) {
            const offset = iterator.offset;
            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
                // move iterator back
                iterator.setOffset(offset);
                break;
            }
            graphemeBreakType = prevGraphemeBreakType;
        }
        return (initialOffset - iterator.offset);
    }
    eol() {
        return this._iterator.eol();
    }
}
function nextCharLength(str, initialOffset) {
    const iterator = new GraphemeIterator(str, initialOffset);
    return iterator.nextGraphemeLength();
}
function prevCharLength(str, initialOffset) {
    const iterator = new GraphemeIterator(str, initialOffset);
    return iterator.prevGraphemeLength();
}
function getCharContainingOffset(str, offset) {
    if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {
        offset--;
    }
    const endOffset = offset + nextCharLength(str, offset);
    const startOffset = endOffset - prevCharLength(str, endOffset);
    return [startOffset, endOffset];
}
/**
 * Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js
 */
const CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */
function containsRTL(str) {
    return CONTAINS_RTL.test(str);
}
const IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */
function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
}
const UNUSUAL_LINE_TERMINATORS = /[\u2028\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)
/**
 * Returns true if `str` contains unusual line terminators, like LS or PS
 */
function containsUnusualLineTerminators(str) {
    return UNUSUAL_LINE_TERMINATORS.test(str);
}
function isFullWidthCharacter(charCode) {
    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
    // http://jrgraphix.net/research/unicode_blocks.php
    //          2E80 - 2EFF   CJK Radicals Supplement
    //          2F00 - 2FDF   Kangxi Radicals
    //          2FF0 - 2FFF   Ideographic Description Characters
    //          3000 - 303F   CJK Symbols and Punctuation
    //          3040 - 309F   Hiragana
    //          30A0 - 30FF   Katakana
    //          3100 - 312F   Bopomofo
    //          3130 - 318F   Hangul Compatibility Jamo
    //          3190 - 319F   Kanbun
    //          31A0 - 31BF   Bopomofo Extended
    //          31F0 - 31FF   Katakana Phonetic Extensions
    //          3200 - 32FF   Enclosed CJK Letters and Months
    //          3300 - 33FF   CJK Compatibility
    //          3400 - 4DBF   CJK Unified Ideographs Extension A
    //          4DC0 - 4DFF   Yijing Hexagram Symbols
    //          4E00 - 9FFF   CJK Unified Ideographs
    //          A000 - A48F   Yi Syllables
    //          A490 - A4CF   Yi Radicals
    //          AC00 - D7AF   Hangul Syllables
    // [IGNORE] D800 - DB7F   High Surrogates
    // [IGNORE] DB80 - DBFF   High Private Use Surrogates
    // [IGNORE] DC00 - DFFF   Low Surrogates
    // [IGNORE] E000 - F8FF   Private Use Area
    //          F900 - FAFF   CJK Compatibility Ideographs
    // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms
    // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A
    // [IGNORE] FE00 - FE0F   Variation Selectors
    // [IGNORE] FE20 - FE2F   Combining Half Marks
    // [IGNORE] FE30 - FE4F   CJK Compatibility Forms
    // [IGNORE] FE50 - FE6F   Small Form Variants
    // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B
    //          FF00 - FFEF   Halfwidth and Fullwidth Forms
    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
    // [IGNORE] FFF0 - FFFF   Specials
    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
        || (charCode >= 0xF900 && charCode <= 0xFAFF)
        || (charCode >= 0xFF01 && charCode <= 0xFF5E));
}
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js
 */
function isEmojiImprecise(x) {
    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)
        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)
        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)
        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)
        || (x >= 129648 && x <= 129782));
}
// -- UTF-8 BOM
const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
function startsWithUTF8BOM(str) {
    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
}
function containsUppercaseCharacter(target, ignoreEscapedChars = false) {
    if (!target) {
        return false;
    }
    if (ignoreEscapedChars) {
        target = target.replace(/\\./g, '');
    }
    return target.toLowerCase() !== target;
}
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */
function singleLetterHash(n) {
    const LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
    n = n % (2 * LETTERS_CNT);
    if (n < LETTERS_CNT) {
        return String.fromCharCode(97 /* a */ + n);
    }
    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
    // !!! Let's make the common case a bit faster
    if (breakTypeA === 0 /* Other */) {
        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table
        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);
    }
    // Do not break between a CR and LF. Otherwise, break before and after controls.
    // GB3                                        CR  LF
    // GB4                       (Control | CR | LF) 
    // GB5                                            (Control | CR | LF)
    if (breakTypeA === 2 /* CR */) {
        if (breakTypeB === 3 /* LF */) {
            return false; // GB3
        }
    }
    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {
        return true; // GB4
    }
    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {
        return true; // GB5
    }
    // Do not break Hangul syllable sequences.
    // GB6                                         L  (L | V | LV | LVT)
    // GB7                                  (LV | V)  (V | T)
    // GB8                                 (LVT | T)  T
    if (breakTypeA === 8 /* L */) {
        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {
            return false; // GB6
        }
    }
    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {
        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {
            return false; // GB7
        }
    }
    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {
        if (breakTypeB === 10 /* T */) {
            return false; // GB8
        }
    }
    // Do not break before extending characters or ZWJ.
    // GB9                                            (Extend | ZWJ)
    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {
        return false; // GB9
    }
    // The GB9a and GB9b rules only apply to extended grapheme clusters:
    // Do not break before SpacingMarks, or after Prepend characters.
    // GB9a                                           SpacingMark
    // GB9b                                  Prepend 
    if (breakTypeB === 7 /* SpacingMark */) {
        return false; // GB9a
    }
    if (breakTypeA === 1 /* Prepend */) {
        return false; // GB9b
    }
    // Do not break within emoji modifier sequences or emoji zwj sequences.
    // GB11    \p{Extended_Pictographic} Extend* ZWJ  \p{Extended_Pictographic}
    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB11
    }
    // GB12                          sot (RI RI)* RI  RI
    // GB13                        [^RI] (RI RI)* RI  RI
    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB12 & GB13
    }
    // GB999                                     Any  Any
    return true;
}
class GraphemeBreakTree {
    constructor() {
        this._data = getGraphemeBreakRawData();
    }
    static getInstance() {
        if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
        }
        return GraphemeBreakTree._INSTANCE;
    }
    getGraphemeBreakType(codePoint) {
        // !!! Let's make 7bit ASCII a bit faster: 0..31
        if (codePoint < 32) {
            if (codePoint === 10 /* LineFeed */) {
                return 3 /* LF */;
            }
            if (codePoint === 13 /* CarriageReturn */) {
                return 2 /* CR */;
            }
            return 4 /* Control */;
        }
        // !!! Let's make 7bit ASCII a bit faster: 32..126
        if (codePoint < 127) {
            return 0 /* Other */;
        }
        const data = this._data;
        const nodeCount = data.length / 3;
        let nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
                // go left
                nodeIndex = 2 * nodeIndex;
            }
            else if (codePoint > data[3 * nodeIndex + 1]) {
                // go right
                nodeIndex = 2 * nodeIndex + 1;
            }
            else {
                // hit
                return data[3 * nodeIndex + 2];
            }
        }
        return 0 /* Other */;
    }
}
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
    // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js
    return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');
}
//#endregion
/**
 * Computes the offset after performing a left delete on the given string,
 * while considering unicode grapheme/emoji rules.
*/
function getLeftDeleteOffset(offset, str) {
    if (offset === 0) {
        return 0;
    }
    // Try to delete emoji part.
    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);
    if (emojiOffset !== undefined) {
        return emojiOffset;
    }
    // Otherwise, just skip a single code point.
    const iterator = new CodePointIterator(str, offset);
    iterator.prevCodePoint();
    return iterator.offset;
}
function getOffsetBeforeLastEmojiComponent(initialOffset, str) {
    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the
    // structure of emojis.
    const iterator = new CodePointIterator(str, initialOffset);
    let codePoint = iterator.prevCodePoint();
    // Skip modifiers
    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* emojiVariantSelector */ || codePoint === 8419 /* enclosingKeyCap */)) {
        if (iterator.offset === 0) {
            // Cannot skip modifier, no preceding emoji base.
            return undefined;
        }
        codePoint = iterator.prevCodePoint();
    }
    // Expect base emoji
    if (!isEmojiImprecise(codePoint)) {
        // Unexpected code point, not a valid emoji.
        return undefined;
    }
    let resultOffset = iterator.offset;
    if (resultOffset > 0) {
        // Skip optional ZWJ code points that combine multiple emojis.
        // In theory, we should check if that ZWJ actually combines multiple emojis
        // to prevent deleting ZWJs in situations we didn't account for.
        const optionalZwjCodePoint = iterator.prevCodePoint();
        if (optionalZwjCodePoint === 8205 /* zwj */) {
            resultOffset = iterator.offset;
        }
    }
    return resultOffset;
}
function isEmojiModifier(codePoint) {
    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;
}
const noBreakWhitespace = '\xa0';
class AmbiguousCharacters {
    constructor(confusableDictionary) {
        this.confusableDictionary = confusableDictionary;
    }
    static getInstance(locales) {
        return AmbiguousCharacters.cache.get(Array.from(locales));
    }
    static getLocales() {
        return AmbiguousCharacters._locales.getValue();
    }
    isAmbiguous(codePoint) {
        return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
        return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
        return new Set(this.confusableDictionary.keys());
    }
}
_a = AmbiguousCharacters;
AmbiguousCharacters.ambiguousCharacterData = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => {
    // Generated using https://github.com/hediet/vscode-unicode-data
    // Stored as key1, value1, key2, value2, ...
    return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
});
AmbiguousCharacters.cache = new _cache_js__WEBPACK_IMPORTED_MODULE_0__.LRUCachedComputed((locales) => {
    function arrayToMap(arr) {
        const result = new Map();
        for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
        }
        return result;
    }
    function mergeMaps(map1, map2) {
        const result = new Map(map1);
        for (const [key, value] of map2) {
            result.set(key, value);
        }
        return result;
    }
    function intersectMaps(map1, map2) {
        if (!map1) {
            return map2;
        }
        const result = new Map();
        for (const [key, value] of map1) {
            if (map2.has(key)) {
                result.set(key, value);
            }
        }
        return result;
    }
    const data = _a.ambiguousCharacterData.getValue();
    let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);
    if (filteredLocales.length === 0) {
        filteredLocales = ['_default'];
    }
    let languageSpecificMap = undefined;
    for (const locale of filteredLocales) {
        const map = arrayToMap(data[locale]);
        languageSpecificMap = intersectMaps(languageSpecificMap, map);
    }
    const commonMap = arrayToMap(data['_common']);
    const map = mergeMaps(commonMap, languageSpecificMap);
    return new AmbiguousCharacters(map);
});
AmbiguousCharacters._locales = new _lazy_js__WEBPACK_IMPORTED_MODULE_1__.Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith('_')));
class InvisibleCharacters {
    static getRawData() {
        // Generated using https://github.com/hediet/vscode-unicode-data
        return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');
    }
    static getData() {
        if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
        }
        return this._data;
    }
    static isInvisibleCharacter(codePoint) {
        return InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
        return InvisibleCharacters.getData();
    }
}
InvisibleCharacters._data = undefined;


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assertIsDefined": () => (/* binding */ assertIsDefined),
/* harmony export */   "assertNever": () => (/* binding */ assertNever),
/* harmony export */   "assertType": () => (/* binding */ assertType),
/* harmony export */   "createProxyObject": () => (/* binding */ createProxyObject),
/* harmony export */   "getAllMethodNames": () => (/* binding */ getAllMethodNames),
/* harmony export */   "getAllPropertyNames": () => (/* binding */ getAllPropertyNames),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDefined": () => (/* binding */ isDefined),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isIterable": () => (/* binding */ isIterable),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "isUndefinedOrNull": () => (/* binding */ isUndefinedOrNull),
/* harmony export */   "validateConstraint": () => (/* binding */ validateConstraint),
/* harmony export */   "validateConstraints": () => (/* binding */ validateConstraints),
/* harmony export */   "withNullAsUndefined": () => (/* binding */ withNullAsUndefined)
/* harmony export */ });
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
 */
function isArray(array) {
    return Array.isArray(array);
}
/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
    return (typeof str === 'string');
}
/**
 *
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */
function isObject(obj) {
    // The method can't do a type cast since there are type (like strings) which
    // are subclasses of any put not positvely matched by the function. Hence type
    // narrowing results in wrong results.
    return typeof obj === 'object'
        && obj !== null
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */
function isNumber(obj) {
    return (typeof obj === 'number' && !isNaN(obj));
}
/**
 * @returns whether the provided parameter is an Iterable, casting to the given generic
 */
function isIterable(obj) {
    return !!obj && typeof obj[Symbol.iterator] === 'function';
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */
function isBoolean(obj) {
    return (obj === true || obj === false);
}
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return (typeof obj === 'undefined');
}
/**
 * @returns whether the provided parameter is defined.
 */
function isDefined(arg) {
    return !isUndefinedOrNull(arg);
}
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return (isUndefined(obj) || obj === null);
}
function assertType(condition, type) {
    if (!condition) {
        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');
    }
}
/**
 * Asserts that the argument passed in is neither undefined nor null.
 */
function assertIsDefined(arg) {
    if (isUndefinedOrNull(arg)) {
        throw new Error('Assertion Failed: argument is undefined or null');
    }
    return arg;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */
function isFunction(obj) {
    return (typeof obj === 'function');
}
function validateConstraints(args, constraints) {
    const len = Math.min(args.length, constraints.length);
    for (let i = 0; i < len; i++) {
        validateConstraint(args[i], constraints[i]);
    }
}
function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
        if (typeof arg !== constraint) {
            throw new Error(`argument does not match constraint: typeof ${constraint}`);
        }
    }
    else if (isFunction(constraint)) {
        try {
            if (arg instanceof constraint) {
                return;
            }
        }
        catch (_a) {
            // ignore
        }
        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
            return;
        }
        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
            return;
        }
        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);
    }
}
function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
        res = res.concat(Object.getOwnPropertyNames(proto));
        proto = Object.getPrototypeOf(proto);
    }
    return res;
}
function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
        if (typeof obj[prop] === 'function') {
            methods.push(prop);
        }
    }
    return methods;
}
function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
        return function () {
            const args = Array.prototype.slice.call(arguments, 0);
            return invoke(method, args);
        };
    };
    let result = {};
    for (const methodName of methodNames) {
        result[methodName] = createProxyMethod(methodName);
    }
    return result;
}
/**
 * Converts null to undefined, passes all other values through.
 */
function withNullAsUndefined(x) {
    return x === null ? undefined : x;
}
function assertNever(value, message = 'Unreachable') {
    throw new Error(message);
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toUint32": () => (/* binding */ toUint32),
/* harmony export */   "toUint8": () => (/* binding */ toUint8)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function toUint8(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 255 /* MAX_UINT_8 */) {
        return 255 /* MAX_UINT_8 */;
    }
    return v | 0;
}
function toUint32(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 4294967295 /* MAX_UINT_32 */) {
        return 4294967295 /* MAX_UINT_32 */;
    }
    return v | 0;
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "uriToFsPath": () => (/* binding */ uriToFsPath)
/* harmony export */ });
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/path.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const _schemePattern = /^\w[\w\d+.-]*$/;
const _singleSlashStart = /^\//;
const _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
const _empty = '';
const _slash = '/';
const _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
class URI {
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    static isUri(thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'string'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
        // if (this.scheme !== 'file') {
        // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
        // }
        return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
        if (!change) {
            return this;
        }
        let { scheme, authority, path, query, fragment } = change;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new Uri(scheme, authority, path, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
        const match = _regexp.exec(value);
        if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
        }
        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path) {
        let authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new Uri('file', authority, path, _empty, _empty);
    }
    static from(components) {
        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
        _validateUri(result, true);
        return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
        if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
        }
        let newPath;
        if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows && uri.scheme === 'file') {
            newPath = URI.file(_path_js__WEBPACK_IMPORTED_MODULE_0__.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
        }
        else {
            newPath = _path_js__WEBPACK_IMPORTED_MODULE_0__.posix.join(uri.path, ...pathFragment);
        }
        return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
        return _asFormatted(this, skipEncoding);
    }
    toJSON() {
        return this;
    }
    static revive(data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            const result = new Uri(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
        }
    }
}
const _pathSepMarker = _platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows ? 1 : undefined;
// This class exists so that URI is compatible with vscode.Uri (API).
class Uri extends URI {
    constructor() {
        super(...arguments);
        this._formatted = null;
        this._fsPath = null;
    }
    get fsPath() {
        if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
        }
        return this._fsPath;
    }
    toString(skipEncoding = false) {
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    }
    toJSON() {
        const res = {
            $mid: 1 /* Uri */
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    }
}
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
const encodeTable = {
    [58 /* Colon */]: '%3A',
    [47 /* Slash */]: '%2F',
    [63 /* QuestionMark */]: '%3F',
    [35 /* Hash */]: '%23',
    [91 /* OpenSquareBracket */]: '%5B',
    [93 /* CloseSquareBracket */]: '%5D',
    [64 /* AtSign */]: '%40',
    [33 /* ExclamationMark */]: '%21',
    [36 /* DollarSign */]: '%24',
    [38 /* Ampersand */]: '%26',
    [39 /* SingleQuote */]: '%27',
    [40 /* OpenParen */]: '%28',
    [41 /* CloseParen */]: '%29',
    [42 /* Asterisk */]: '%2A',
    [43 /* Plus */]: '%2B',
    [44 /* Comma */]: '%2C',
    [59 /* Semicolon */]: '%3B',
    [61 /* Equals */]: '%3D',
    [32 /* Space */]: '%20',
};
function encodeURIComponentFast(uriComponent, allowSlash) {
    let res = undefined;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
        const code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            const escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    let res = undefined;
    for (let pos = 0; pos < path.length; pos++) {
        const code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = `//${uri.authority}${uri.path}`;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        if (!keepDriveLetterCasing) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            value = uri.path.substr(1);
        }
    }
    else {
        // other path
        value = uri.path;
    }
    if (_platform_js__WEBPACK_IMPORTED_MODULE_1__.isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    let res = '';
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        let idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            const userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            const code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            const code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}
// --- decode
function decodeURIComponentGraceful(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (_a) {
        if (str.length > 3) {
            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
        }
        else {
            return str;
        }
    }
}
const _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
        return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleWorkerClient": () => (/* binding */ SimpleWorkerClient),
/* harmony export */   "SimpleWorkerServer": () => (/* binding */ SimpleWorkerServer),
/* harmony export */   "create": () => (/* binding */ create),
/* harmony export */   "logOnceWebWorkerWarning": () => (/* binding */ logOnceWebWorkerWarning)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../event.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../platform.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js");
/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






const INITIALIZE = '$initialize';
let webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
    if (!_platform_js__WEBPACK_IMPORTED_MODULE_3__.isWeb) {
        // running tests
        return;
    }
    if (!webWorkerWarningLogged) {
        webWorkerWarningLogged = true;
        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');
    }
    console.warn(err.message);
}
class RequestMessage {
    constructor(vsWorker, req, method, args) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.method = method;
        this.args = args;
        this.type = 0 /* Request */;
    }
}
class ReplyMessage {
    constructor(vsWorker, seq, res, err) {
        this.vsWorker = vsWorker;
        this.seq = seq;
        this.res = res;
        this.err = err;
        this.type = 1 /* Reply */;
    }
}
class SubscribeEventMessage {
    constructor(vsWorker, req, eventName, arg) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.eventName = eventName;
        this.arg = arg;
        this.type = 2 /* SubscribeEvent */;
    }
}
class EventMessage {
    constructor(vsWorker, req, event) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.event = event;
        this.type = 3 /* Event */;
    }
}
class UnsubscribeEventMessage {
    constructor(vsWorker, req) {
        this.vsWorker = vsWorker;
        this.req = req;
        this.type = 4 /* UnsubscribeEvent */;
    }
}
class SimpleWorkerProtocol {
    constructor(handler) {
        this._workerId = -1;
        this._handler = handler;
        this._lastSentReq = 0;
        this._pendingReplies = Object.create(null);
        this._pendingEmitters = new Map();
        this._pendingEvents = new Map();
    }
    setWorkerId(workerId) {
        this._workerId = workerId;
    }
    sendMessage(method, args) {
        const req = String(++this._lastSentReq);
        return new Promise((resolve, reject) => {
            this._pendingReplies[req] = {
                resolve: resolve,
                reject: reject
            };
            this._send(new RequestMessage(this._workerId, req, method, args));
        });
    }
    listen(eventName, arg) {
        let req = null;
        const emitter = new _event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter({
            onFirstListenerAdd: () => {
                req = String(++this._lastSentReq);
                this._pendingEmitters.set(req, emitter);
                this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
            },
            onLastListenerRemove: () => {
                this._pendingEmitters.delete(req);
                this._send(new UnsubscribeEventMessage(this._workerId, req));
                req = null;
            }
        });
        return emitter.event;
    }
    handleMessage(message) {
        if (!message || !message.vsWorker) {
            return;
        }
        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
        }
        this._handleMessage(message);
    }
    _handleMessage(msg) {
        switch (msg.type) {
            case 1 /* Reply */:
                return this._handleReplyMessage(msg);
            case 0 /* Request */:
                return this._handleRequestMessage(msg);
            case 2 /* SubscribeEvent */:
                return this._handleSubscribeEventMessage(msg);
            case 3 /* Event */:
                return this._handleEventMessage(msg);
            case 4 /* UnsubscribeEvent */:
                return this._handleUnsubscribeEventMessage(msg);
        }
    }
    _handleReplyMessage(replyMessage) {
        if (!this._pendingReplies[replyMessage.seq]) {
            console.warn('Got reply to unknown seq');
            return;
        }
        let reply = this._pendingReplies[replyMessage.seq];
        delete this._pendingReplies[replyMessage.seq];
        if (replyMessage.err) {
            let err = replyMessage.err;
            if (replyMessage.err.$isError) {
                err = new Error();
                err.name = replyMessage.err.name;
                err.message = replyMessage.err.message;
                err.stack = replyMessage.err.stack;
            }
            reply.reject(err);
            return;
        }
        reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
        let req = requestMessage.req;
        let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
        result.then((r) => {
            this._send(new ReplyMessage(this._workerId, req, r, undefined));
        }, (e) => {
            if (e.detail instanceof Error) {
                // Loading errors have a detail property that points to the actual error
                e.detail = (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e.detail);
            }
            this._send(new ReplyMessage(this._workerId, req, undefined, (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.transformErrorForSerialization)(e)));
        });
    }
    _handleSubscribeEventMessage(msg) {
        const req = msg.req;
        const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
            this._send(new EventMessage(this._workerId, req, event));
        });
        this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
        if (!this._pendingEmitters.has(msg.req)) {
            console.warn('Got event for unknown req');
            return;
        }
        this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
        if (!this._pendingEvents.has(msg.req)) {
            console.warn('Got unsubscribe for unknown req');
            return;
        }
        this._pendingEvents.get(msg.req).dispose();
        this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
        let transfer = [];
        if (msg.type === 0 /* Request */) {
            for (let i = 0; i < msg.args.length; i++) {
                if (msg.args[i] instanceof ArrayBuffer) {
                    transfer.push(msg.args[i]);
                }
            }
        }
        else if (msg.type === 1 /* Reply */) {
            if (msg.res instanceof ArrayBuffer) {
                transfer.push(msg.res);
            }
        }
        this._handler.sendMessage(msg, transfer);
    }
}
/**
 * Main thread side
 */
class SimpleWorkerClient extends _lifecycle_js__WEBPACK_IMPORTED_MODULE_2__.Disposable {
    constructor(workerFactory, moduleId, host) {
        super();
        let lazyProxyReject = null;
        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {
            this._protocol.handleMessage(msg);
        }, (err) => {
            // in Firefox, web workers fail lazily :(
            // we will reject the proxy
            if (lazyProxyReject) {
                lazyProxyReject(err);
            }
        }));
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                this._worker.postMessage(msg, transfer);
            },
            handleMessage: (method, args) => {
                if (typeof host[method] !== 'function') {
                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));
                }
                try {
                    return Promise.resolve(host[method].apply(host, args));
                }
                catch (e) {
                    return Promise.reject(e);
                }
            },
            handleEvent: (eventName, arg) => {
                if (propertyIsDynamicEvent(eventName)) {
                    const event = host[eventName].call(host, arg);
                    if (typeof event !== 'function') {
                        throw new Error(`Missing dynamic event ${eventName} on main thread host.`);
                    }
                    return event;
                }
                if (propertyIsEvent(eventName)) {
                    const event = host[eventName];
                    if (typeof event !== 'function') {
                        throw new Error(`Missing event ${eventName} on main thread host.`);
                    }
                    return event;
                }
                throw new Error(`Malformed event name ${eventName}`);
            }
        });
        this._protocol.setWorkerId(this._worker.getId());
        // Gather loader configuration
        let loaderConfiguration = null;
        if (typeof _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.require !== 'undefined' && typeof _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.require.getConfig === 'function') {
            // Get the configuration from the Monaco AMD Loader
            loaderConfiguration = _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.require.getConfig();
        }
        else if (typeof _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.requirejs !== 'undefined') {
            // Get the configuration from requirejs
            loaderConfiguration = _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.requirejs.s.contexts._.config;
        }
        const hostMethods = _types_js__WEBPACK_IMPORTED_MODULE_4__.getAllMethodNames(host);
        // Send initialize message
        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
            this._worker.getId(),
            JSON.parse(JSON.stringify(loaderConfiguration)),
            moduleId,
            hostMethods,
        ]);
        // Create proxy to loaded code
        const proxyMethodRequest = (method, args) => {
            return this._request(method, args);
        };
        const proxyListen = (eventName, arg) => {
            return this._protocol.listen(eventName, arg);
        };
        this._lazyProxy = new Promise((resolve, reject) => {
            lazyProxyReject = reject;
            this._onModuleLoaded.then((availableMethods) => {
                resolve(createProxyObject(availableMethods, proxyMethodRequest, proxyListen));
            }, (e) => {
                reject(e);
                this._onError('Worker failed to load ' + moduleId, e);
            });
        });
    }
    getProxyObject() {
        return this._lazyProxy;
    }
    _request(method, args) {
        return new Promise((resolve, reject) => {
            this._onModuleLoaded.then(() => {
                this._protocol.sendMessage(method, args).then(resolve, reject);
            }, reject);
        });
    }
    _onError(message, error) {
        console.error(message);
        console.info(error);
    }
}
function propertyIsEvent(name) {
    // Assume a property is an event if it has a form of "onSomething"
    return name[0] === 'o' && name[1] === 'n' && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(2));
}
function propertyIsDynamicEvent(name) {
    // Assume a property is a dynamic event (a method that returns an event) if it has a form of "onDynamicSomething"
    return /^onDynamic/.test(name) && _strings_js__WEBPACK_IMPORTED_MODULE_5__.isUpperAsciiLetter(name.charCodeAt(9));
}
function createProxyObject(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
        return function () {
            const args = Array.prototype.slice.call(arguments, 0);
            return invoke(method, args);
        };
    };
    const createProxyDynamicEvent = (eventName) => {
        return function (arg) {
            return proxyListen(eventName, arg);
        };
    };
    let result = {};
    for (const methodName of methodNames) {
        if (propertyIsDynamicEvent(methodName)) {
            result[methodName] = createProxyDynamicEvent(methodName);
            continue;
        }
        if (propertyIsEvent(methodName)) {
            result[methodName] = proxyListen(methodName, undefined);
            continue;
        }
        result[methodName] = createProxyMethod(methodName);
    }
    return result;
}
/**
 * Worker side
 */
class SimpleWorkerServer {
    constructor(postMessage, requestHandlerFactory) {
        this._requestHandlerFactory = requestHandlerFactory;
        this._requestHandler = null;
        this._protocol = new SimpleWorkerProtocol({
            sendMessage: (msg, transfer) => {
                postMessage(msg, transfer);
            },
            handleMessage: (method, args) => this._handleMessage(method, args),
            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
        });
    }
    onmessage(msg) {
        this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
        if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
        }
        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    _handleEvent(eventName, arg) {
        if (!this._requestHandler) {
            throw new Error(`Missing requestHandler`);
        }
        if (propertyIsDynamicEvent(eventName)) {
            const event = this._requestHandler[eventName].call(this._requestHandler, arg);
            if (typeof event !== 'function') {
                throw new Error(`Missing dynamic event ${eventName} on request handler.`);
            }
            return event;
        }
        if (propertyIsEvent(eventName)) {
            const event = this._requestHandler[eventName];
            if (typeof event !== 'function') {
                throw new Error(`Missing event ${eventName} on request handler.`);
            }
            return event;
        }
        throw new Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
        this._protocol.setWorkerId(workerId);
        const proxyMethodRequest = (method, args) => {
            return this._protocol.sendMessage(method, args);
        };
        const proxyListen = (eventName, arg) => {
            return this._protocol.listen(eventName, arg);
        };
        const hostProxy = createProxyObject(hostMethods, proxyMethodRequest, proxyListen);
        if (this._requestHandlerFactory) {
            // static request handler
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(_types_js__WEBPACK_IMPORTED_MODULE_4__.getAllMethodNames(this._requestHandler));
        }
        if (loaderConfig) {
            // Remove 'baseUrl', handling it is beyond scope for now
            if (typeof loaderConfig.baseUrl !== 'undefined') {
                delete loaderConfig['baseUrl'];
            }
            if (typeof loaderConfig.paths !== 'undefined') {
                if (typeof loaderConfig.paths.vs !== 'undefined') {
                    delete loaderConfig.paths['vs'];
                }
            }
            if (typeof loaderConfig.trustedTypesPolicy !== undefined) {
                // don't use, it has been destroyed during serialize
                delete loaderConfig['trustedTypesPolicy'];
            }
            // Since this is in a web worker, enable catching errors
            loaderConfig.catchError = true;
            _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.require.config(loaderConfig);
        }
        return new Promise((resolve, reject) => {
            // Use the global require to be sure to get the global config
            // ESM-comment-begin
            // 			const req = (globals.require || require);
            // ESM-comment-end
            // ESM-uncomment-begin
            const req = _platform_js__WEBPACK_IMPORTED_MODULE_3__.globals.require;
            // ESM-uncomment-end
            req([moduleId], (module) => {
                this._requestHandler = module.create(hostProxy);
                if (!this._requestHandler) {
                    reject(new Error(`No RequestHandler!`));
                    return;
                }
                resolve(_types_js__WEBPACK_IMPORTED_MODULE_4__.getAllMethodNames(this._requestHandler));
            }, reject);
        });
    }
}
/**
 * Called on the worker side
 */
function create(postMessage) {
    return new SimpleWorkerServer(postMessage, null);
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharacterClassifier": () => (/* binding */ CharacterClassifier),
/* harmony export */   "CharacterSet": () => (/* binding */ CharacterSet)
/* harmony export */ });
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/uint.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
class CharacterClassifier {
    constructor(_defaultValue) {
        const defaultValue = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
        this._map = new Map();
    }
    static _createAsciiMap(defaultValue) {
        const asciiMap = new Uint8Array(256);
        for (let i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
        }
        return asciiMap;
    }
    set(charCode, _value) {
        const value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_0__.toUint8)(_value);
        if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
        }
        else {
            this._map.set(charCode, value);
        }
    }
    get(charCode) {
        if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
        }
        else {
            return (this._map.get(charCode) || this._defaultValue);
        }
    }
}
class CharacterSet {
    constructor() {
        this._actual = new CharacterClassifier(0 /* False */);
    }
    add(charCode) {
        this._actual.set(charCode, 1 /* True */);
    }
    has(charCode) {
        return (this._actual.get(charCode) === 1 /* True */);
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Position": () => (/* binding */ Position)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A position in the editor.
 */
class Position {
    constructor(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
        }
        else {
            return new Position(newLineNumber, newColumn);
        }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
        return Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a, b) {
        if (!a && !b) {
            return true;
        }
        return (!!a &&
            !!b &&
            a.lineNumber === b.lineNumber &&
            a.column === b.column);
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
        return Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
        return Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a, b) {
        const aLineNumber = a.lineNumber | 0;
        const bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
            const aColumn = a.column | 0;
            const bColumn = b.column | 0;
            return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
        return new Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
        return '(' + this.lineNumber + ',' + this.column + ')';
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
        return new Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
        return (obj
            && (typeof obj.lineNumber === 'number')
            && (typeof obj.column === 'number'));
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Range": () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
class Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
        }
        else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
        return Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position) {
        return Range.containsPosition(this, position);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
        return Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
        return Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
        }
        return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
        return Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a, b) {
        let startLineNumber;
        let startColumn;
        let endLineNumber;
        let endColumn;
        if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
        }
        else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
        }
        else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
        }
        else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
        }
        else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
        }
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
        return Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a, b) {
        let resultStartLineNumber = a.startLineNumber;
        let resultStartColumn = a.startColumn;
        let resultEndLineNumber = a.endLineNumber;
        let resultEndColumn = a.endColumn;
        let otherStartLineNumber = b.startLineNumber;
        let otherStartColumn = b.startColumn;
        let otherEndLineNumber = b.endLineNumber;
        let otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
        }
        else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
        }
        else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        // Check if selection is now empty
        if (resultStartLineNumber > resultEndLineNumber) {
            return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
        }
        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
        return Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a, b) {
        return (!!a &&
            !!b &&
            a.startLineNumber === b.startLineNumber &&
            a.startColumn === b.startColumn &&
            a.endLineNumber === b.endLineNumber &&
            a.endColumn === b.endColumn);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
        return Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
        return Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
        return Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    // ---
    static fromPositions(start, end = start) {
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
        if (!range) {
            return null;
        }
        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
        return (obj
            && (typeof obj.startLineNumber === 'number')
            && (typeof obj.startColumn === 'number')
            && (typeof obj.endLineNumber === 'number')
            && (typeof obj.endColumn === 'number'));
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a, b) {
        if (a && b) {
            const aStartLineNumber = a.startLineNumber | 0;
            const bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                const aStartColumn = a.startColumn | 0;
                const bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    const aEndLineNumber = a.endLineNumber | 0;
                    const bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        const aEndColumn = a.endColumn | 0;
                        const bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        }
        const aExists = (a ? 1 : 0);
        const bExists = (b ? 1 : 0);
        return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a, b) {
        if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
                if (a.startLineNumber === b.startLineNumber) {
                    return a.startColumn - b.startColumn;
                }
                return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
        return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
        return this;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Selection": () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
class Selection extends _range_js__WEBPACK_IMPORTED_MODULE_1__.Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
        this.selectionStartLineNumber = selectionStartLineNumber;
        this.selectionStartColumn = selectionStartColumn;
        this.positionLineNumber = positionLineNumber;
        this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
        return (Selection.selectionsEqual(this, other));
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a, b) {
        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
            a.selectionStartColumn === b.selectionStartColumn &&
            a.positionLineNumber === b.positionLineNumber &&
            a.positionColumn === b.positionColumn);
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0 /* LTR */;
        }
        return 1 /* RTL */;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
        return new _position_js__WEBPACK_IMPORTED_MODULE_0__.Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
        if (direction === 0 /* LTR */) {
            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        }
        else {
            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
        }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
        return (obj
            && (typeof obj.selectionStartLineNumber === 'number')
            && (typeof obj.selectionStartColumn === 'number')
            && (typeof obj.positionLineNumber === 'number')
            && (typeof obj.positionColumn === 'number'));
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
        if (direction === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WordCharacterClassifier": () => (/* binding */ WordCharacterClassifier),
/* harmony export */   "getMapForWordSeparators": () => (/* binding */ getMapForWordSeparators)
/* harmony export */ });
/* harmony import */ var _characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./characterClassifier.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class WordCharacterClassifier extends _characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__.CharacterClassifier {
    constructor(wordSeparators) {
        super(0 /* Regular */);
        for (let i = 0, len = wordSeparators.length; i < len; i++) {
            this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);
        }
        this.set(32 /* Space */, 1 /* Whitespace */);
        this.set(9 /* Tab */, 1 /* Whitespace */);
    }
}
function once(computeFn) {
    const cache = {}; // TODO@Alex unbounded cache
    return (input) => {
        if (!cache.hasOwnProperty(input)) {
            cache[input] = computeFn(input);
        }
        return cache[input];
    };
}
const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_WORD_REGEXP": () => (/* binding */ DEFAULT_WORD_REGEXP),
/* harmony export */   "USUAL_WORD_SEPARATORS": () => (/* binding */ USUAL_WORD_SEPARATORS),
/* harmony export */   "ensureValidWordDefinition": () => (/* binding */ ensureValidWordDefinition),
/* harmony export */   "getWordAtText": () => (/* binding */ getWordAtText)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
/**
 * Create a word definition regular expression based on default word separators.
 * Optionally provide allowed separators that should be included in words.
 *
 * The default would look like this:
 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
 */
function createWordRegExp(allowInWords = '') {
    let source = '(-?\\d*\\.\\d\\w*)|([^';
    for (const sep of USUAL_WORD_SEPARATORS) {
        if (allowInWords.indexOf(sep) >= 0) {
            continue;
        }
        source += '\\' + sep;
    }
    source += '\\s]+)';
    return new RegExp(source, 'g');
}
// catches numbers (including floating numbers) in the first group, and alphanum in the second
const DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && (wordDefinition instanceof RegExp)) {
        if (!wordDefinition.global) {
            let flags = 'g';
            if (wordDefinition.ignoreCase) {
                flags += 'i';
            }
            if (wordDefinition.multiline) {
                flags += 'm';
            }
            if (wordDefinition.unicode) {
                flags += 'u';
            }
            result = new RegExp(wordDefinition.source, flags);
        }
        else {
            result = wordDefinition;
        }
    }
    result.lastIndex = 0;
    return result;
}
const _defaultConfig = {
    maxLen: 1000,
    windowSize: 15,
    timeBudget: 150
};
function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {
    if (text.length > config.maxLen) {
        // don't throw strings that long at the regexp
        // but use a sub-string in which a word must occur
        let start = column - config.maxLen / 2;
        if (start < 0) {
            start = 0;
        }
        else {
            textOffset += start;
        }
        text = text.substring(start, column + config.maxLen / 2);
        return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1;; i++) {
        // check time budget
        if (Date.now() - t1 >= config.timeBudget) {
            break;
        }
        // reset the index at which the regexp should start matching, also know where it
        // should stop so that subsequent search don't repeat previous searches
        const regexIndex = pos - config.windowSize * i;
        wordDefinition.lastIndex = Math.max(0, regexIndex);
        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
        if (!thisMatch && match) {
            // stop: we have something
            break;
        }
        match = thisMatch;
        // stop: searched at start
        if (regexIndex <= 0) {
            break;
        }
        prevRegexIndex = regexIndex;
    }
    if (match) {
        const result = {
            word: match[0],
            startColumn: textOffset + 1 + match.index,
            endColumn: textOffset + 1 + match.index + match[0].length
        };
        wordDefinition.lastIndex = 0;
        return result;
    }
    return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
        const matchIndex = match.index || 0;
        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
            return match;
        }
        else if (stopPos > 0 && matchIndex > stopPos) {
            return null;
        }
    }
    return null;
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiffComputer": () => (/* binding */ DiffComputer)
/* harmony export */ });
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
}
class LineSequence {
    constructor(lines) {
        const startColumns = [];
        const endColumns = [];
        for (let i = 0, length = lines.length; i < length; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
    }
    getElements() {
        const elements = [];
        for (let i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
        }
        return elements;
    }
    getStrictElement(index) {
        return this.lines[index];
    }
    getStartLineNumber(i) {
        return i + 1;
    }
    getEndLineNumber(i) {
        return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        const charCodes = [];
        const lineNumbers = [];
        const columns = [];
        let len = 0;
        for (let index = startIndex; index <= endIndex; index++) {
            const lineContent = this.lines[index];
            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);
            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);
            for (let col = startColumn; col < endColumn; col++) {
                charCodes[len] = lineContent.charCodeAt(col - 1);
                lineNumbers[len] = index + 1;
                columns[len] = col;
                len++;
            }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
    }
}
class CharSequence {
    constructor(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
    }
    getElements() {
        return this._charCodes;
    }
    getStartLineNumber(i) {
        return this._lineNumbers[i];
    }
    getStartColumn(i) {
        return this._columns[i];
    }
    getEndLineNumber(i) {
        return this._lineNumbers[i];
    }
    getEndColumn(i) {
        return this._columns[i] + 1;
    }
}
class CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
        let originalStartLineNumber;
        let originalStartColumn;
        let originalEndLineNumber;
        let originalEndColumn;
        let modifiedStartLineNumber;
        let modifiedStartColumn;
        let modifiedEndLineNumber;
        let modifiedEndColumn;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = 0;
            originalStartColumn = 0;
            originalEndLineNumber = 0;
            originalEndColumn = 0;
        }
        else {
            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = 0;
            modifiedStartColumn = 0;
            modifiedEndLineNumber = 0;
            modifiedEndColumn = 0;
        }
        else {
            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
}
function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
        return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
        const currChange = rawChanges[i];
        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
            // Merge the current change into the previous one
            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
        }
        else {
            // Add the current change
            result.push(currChange);
            prevChange = currChange;
        }
    }
    return result;
}
class LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        let originalStartLineNumber;
        let originalEndLineNumber;
        let modifiedStartLineNumber;
        let modifiedEndLineNumber;
        let charChanges = undefined;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
        }
        else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
        }
        else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            // Compute character changes for diff chunks of at most 20 lines...
            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
                rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
            }
        }
        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
}
class DiffComputer {
    constructor(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...
    }
    computeDiff() {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            // empty original => fast path
            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
                return {
                    quitEarly: false,
                    changes: []
                };
            }
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: 1,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: this.modified.lines.length,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            // empty modified => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: this.original.lines.length,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: 1,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        const rawChanges = diffResult.changes;
        const quitEarly = diffResult.quitEarly;
        // The diff is always computed with ignoring trim whitespace
        // This ensures we get the prettiest diff
        if (this.shouldIgnoreTrimWhitespace) {
            const lineChanges = [];
            for (let i = 0, length = rawChanges.length; i < length; i++) {
                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
                quitEarly: quitEarly,
                changes: lineChanges
            };
        }
        // Need to post-process and introduce changes where the trim whitespace is different
        // Note that we are looping starting at -1 to also cover the lines before the first change
        const result = [];
        let originalLineIndex = 0;
        let modifiedLineIndex = 0;
        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {
            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);
            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);
            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
                const originalLine = this.originalLines[originalLineIndex];
                const modifiedLine = this.modifiedLines[modifiedLineIndex];
                if (originalLine !== modifiedLine) {
                    // These lines differ only in trim whitespace
                    // Check the leading whitespace
                    {
                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalStartColumn--;
                            modifiedStartColumn--;
                        }
                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                        }
                    }
                    // Check the trailing whitespace
                    {
                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                        const originalMaxColumn = originalLine.length + 1;
                        const modifiedMaxColumn = modifiedLine.length + 1;
                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalEndColumn++;
                            modifiedEndColumn++;
                        }
                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                        }
                    }
                }
                originalLineIndex++;
                modifiedLineIndex++;
            }
            if (nextChange) {
                // Emit the actual change
                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
                originalLineIndex += nextChange.originalLength;
                modifiedLineIndex += nextChange.modifiedLength;
            }
        }
        return {
            quitEarly: quitEarly,
            changes: result
        };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            // Merged into previous
            return;
        }
        let charChanges = undefined;
        if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        const len = result.length;
        if (len === 0) {
            return false;
        }
        const prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            // Don't merge with inserts/deletes
            return false;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
        }
        return false;
    }
}
function getFirstNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.firstNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
    const r = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_1__.lastNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
        return () => true;
    }
    const startTime = Date.now();
    return () => {
        return Date.now() - startTime < maximumRuntime;
    };
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItemKinds": () => (/* binding */ CompletionItemKinds),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "EncodedTokenizationResult": () => (/* binding */ EncodedTokenizationResult),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "InlayHintKind": () => (/* binding */ InlayHintKind),
/* harmony export */   "InlineCompletionTriggerKind": () => (/* binding */ InlineCompletionTriggerKind),
/* harmony export */   "SignatureHelpTriggerKind": () => (/* binding */ SignatureHelpTriggerKind),
/* harmony export */   "SymbolKinds": () => (/* binding */ SymbolKinds),
/* harmony export */   "Token": () => (/* binding */ Token),
/* harmony export */   "TokenMetadata": () => (/* binding */ TokenMetadata),
/* harmony export */   "TokenizationRegistry": () => (/* binding */ TokenizationRegistry),
/* harmony export */   "TokenizationResult": () => (/* binding */ TokenizationResult),
/* harmony export */   "isLocationLink": () => (/* binding */ isLocationLink)
/* harmony export */ });
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/uri.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokenizationRegistry.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js");
/* harmony import */ var _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../base/common/codicons.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




/**
 * @internal
 */
class TokenMetadata {
    static getLanguageId(metadata) {
        return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;
    }
    static getTokenType(metadata) {
        return (metadata & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;
    }
    static getFontStyle(metadata) {
        return (metadata & 15360 /* FONT_STYLE_MASK */) >>> 10 /* FONT_STYLE_OFFSET */;
    }
    static getForeground(metadata) {
        return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;
    }
    static getBackground(metadata) {
        return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;
    }
    static getClassNameFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        let className = 'mtk' + foreground;
        const fontStyle = this.getFontStyle(metadata);
        if (fontStyle & 1 /* Italic */) {
            className += ' mtki';
        }
        if (fontStyle & 2 /* Bold */) {
            className += ' mtkb';
        }
        if (fontStyle & 4 /* Underline */) {
            className += ' mtku';
        }
        if (fontStyle & 8 /* Strikethrough */) {
            className += ' mtks';
        }
        return className;
    }
    static getInlineStyleFromMetadata(metadata, colorMap) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        let result = `color: ${colorMap[foreground]};`;
        if (fontStyle & 1 /* Italic */) {
            result += 'font-style: italic;';
        }
        if (fontStyle & 2 /* Bold */) {
            result += 'font-weight: bold;';
        }
        let textDecoration = '';
        if (fontStyle & 4 /* Underline */) {
            textDecoration += ' underline';
        }
        if (fontStyle & 8 /* Strikethrough */) {
            textDecoration += ' line-through';
        }
        if (textDecoration) {
            result += `text-decoration:${textDecoration};`;
        }
        return result;
    }
    static getPresentationFromMetadata(metadata) {
        const foreground = this.getForeground(metadata);
        const fontStyle = this.getFontStyle(metadata);
        return {
            foreground: foreground,
            italic: Boolean(fontStyle & 1 /* Italic */),
            bold: Boolean(fontStyle & 2 /* Bold */),
            underline: Boolean(fontStyle & 4 /* Underline */),
            strikethrough: Boolean(fontStyle & 8 /* Strikethrough */),
        };
    }
}
class Token {
    constructor(offset, type, language) {
        this._tokenBrand = undefined;
        this.offset = offset;
        this.type = type;
        this.language = language;
    }
    toString() {
        return '(' + this.offset + ', ' + this.type + ')';
    }
}
/**
 * @internal
 */
class TokenizationResult {
    constructor(tokens, endState) {
        this._tokenizationResultBrand = undefined;
        this.tokens = tokens;
        this.endState = endState;
    }
}
/**
 * @internal
 */
class EncodedTokenizationResult {
    constructor(tokens, endState) {
        this._encodedTokenizationResultBrand = undefined;
        this.tokens = tokens;
        this.endState = endState;
    }
}
/**
 * @internal
 */
var CompletionItemKinds;
(function (CompletionItemKinds) {
    const byKind = new Map();
    byKind.set(0 /* Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolMethod);
    byKind.set(1 /* Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolFunction);
    byKind.set(2 /* Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolConstructor);
    byKind.set(3 /* Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolField);
    byKind.set(4 /* Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolVariable);
    byKind.set(5 /* Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolClass);
    byKind.set(6 /* Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolStruct);
    byKind.set(7 /* Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolInterface);
    byKind.set(8 /* Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolModule);
    byKind.set(9 /* Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolProperty);
    byKind.set(10 /* Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEvent);
    byKind.set(11 /* Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolOperator);
    byKind.set(12 /* Unit */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolUnit);
    byKind.set(13 /* Value */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolValue);
    byKind.set(15 /* Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEnum);
    byKind.set(14 /* Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolConstant);
    byKind.set(15 /* Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEnum);
    byKind.set(16 /* EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEnumMember);
    byKind.set(17 /* Keyword */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolKeyword);
    byKind.set(27 /* Snippet */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolSnippet);
    byKind.set(18 /* Text */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolText);
    byKind.set(19 /* Color */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolColor);
    byKind.set(20 /* File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolFile);
    byKind.set(21 /* Reference */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolReference);
    byKind.set(22 /* Customcolor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolCustomColor);
    byKind.set(23 /* Folder */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolFolder);
    byKind.set(24 /* TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolTypeParameter);
    byKind.set(25 /* User */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.account);
    byKind.set(26 /* Issue */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.issues);
    /**
     * @internal
     */
    function toIcon(kind) {
        let codicon = byKind.get(kind);
        if (!codicon) {
            console.info('No codicon found for CompletionItemKind ' + kind);
            codicon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolProperty;
        }
        return codicon;
    }
    CompletionItemKinds.toIcon = toIcon;
    const data = new Map();
    data.set('method', 0 /* Method */);
    data.set('function', 1 /* Function */);
    data.set('constructor', 2 /* Constructor */);
    data.set('field', 3 /* Field */);
    data.set('variable', 4 /* Variable */);
    data.set('class', 5 /* Class */);
    data.set('struct', 6 /* Struct */);
    data.set('interface', 7 /* Interface */);
    data.set('module', 8 /* Module */);
    data.set('property', 9 /* Property */);
    data.set('event', 10 /* Event */);
    data.set('operator', 11 /* Operator */);
    data.set('unit', 12 /* Unit */);
    data.set('value', 13 /* Value */);
    data.set('constant', 14 /* Constant */);
    data.set('enum', 15 /* Enum */);
    data.set('enum-member', 16 /* EnumMember */);
    data.set('enumMember', 16 /* EnumMember */);
    data.set('keyword', 17 /* Keyword */);
    data.set('snippet', 27 /* Snippet */);
    data.set('text', 18 /* Text */);
    data.set('color', 19 /* Color */);
    data.set('file', 20 /* File */);
    data.set('reference', 21 /* Reference */);
    data.set('customcolor', 22 /* Customcolor */);
    data.set('folder', 23 /* Folder */);
    data.set('type-parameter', 24 /* TypeParameter */);
    data.set('typeParameter', 24 /* TypeParameter */);
    data.set('account', 25 /* User */);
    data.set('issue', 26 /* Issue */);
    /**
     * @internal
     */
    function fromString(value, strict) {
        let res = data.get(value);
        if (typeof res === 'undefined' && !strict) {
            res = 9 /* Property */;
        }
        return res;
    }
    CompletionItemKinds.fromString = fromString;
})(CompletionItemKinds || (CompletionItemKinds = {}));
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * @internal
 */
function isLocationLink(thing) {
    return thing
        && _base_common_uri_js__WEBPACK_IMPORTED_MODULE_0__.URI.isUri(thing.uri)
        && _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.isIRange(thing.range)
        && (_core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.isIRange(thing.originSelectionRange) || _core_range_js__WEBPACK_IMPORTED_MODULE_1__.Range.isIRange(thing.targetSelectionRange));
}
/**
 * @internal
 */
var SymbolKinds;
(function (SymbolKinds) {
    const byKind = new Map();
    byKind.set(0 /* File */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolFile);
    byKind.set(1 /* Module */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolModule);
    byKind.set(2 /* Namespace */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolNamespace);
    byKind.set(3 /* Package */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolPackage);
    byKind.set(4 /* Class */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolClass);
    byKind.set(5 /* Method */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolMethod);
    byKind.set(6 /* Property */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolProperty);
    byKind.set(7 /* Field */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolField);
    byKind.set(8 /* Constructor */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolConstructor);
    byKind.set(9 /* Enum */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEnum);
    byKind.set(10 /* Interface */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolInterface);
    byKind.set(11 /* Function */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolFunction);
    byKind.set(12 /* Variable */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolVariable);
    byKind.set(13 /* Constant */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolConstant);
    byKind.set(14 /* String */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolString);
    byKind.set(15 /* Number */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolNumber);
    byKind.set(16 /* Boolean */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolBoolean);
    byKind.set(17 /* Array */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolArray);
    byKind.set(18 /* Object */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolObject);
    byKind.set(19 /* Key */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolKey);
    byKind.set(20 /* Null */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolNull);
    byKind.set(21 /* EnumMember */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEnumMember);
    byKind.set(22 /* Struct */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolStruct);
    byKind.set(23 /* Event */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolEvent);
    byKind.set(24 /* Operator */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolOperator);
    byKind.set(25 /* TypeParameter */, _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolTypeParameter);
    /**
     * @internal
     */
    function toIcon(kind) {
        let icon = byKind.get(kind);
        if (!icon) {
            console.info('No codicon found for SymbolKind ' + kind);
            icon = _base_common_codicons_js__WEBPACK_IMPORTED_MODULE_3__.Codicon.symbolProperty;
        }
        return icon;
    }
    SymbolKinds.toIcon = toIcon;
})(SymbolKinds || (SymbolKinds = {}));
class FoldingRangeKind {
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value) {
        this.value = value;
    }
}
/**
 * Kind for folding range representing a comment. The value of the kind is 'comment'.
 */
FoldingRangeKind.Comment = new FoldingRangeKind('comment');
/**
 * Kind for folding range representing a import. The value of the kind is 'imports'.
 */
FoldingRangeKind.Imports = new FoldingRangeKind('imports');
/**
 * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
 * The value of the kind is 'region'.
 */
FoldingRangeKind.Region = new FoldingRangeKind('region');
/**
 * @internal
 */
var Command;
(function (Command) {
    /**
     * @internal
     */
    function is(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        return typeof obj.id === 'string' &&
            typeof obj.title === 'string';
    }
    Command.is = is;
})(Command || (Command = {}));
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
/**
 * @internal
 */
const TokenizationRegistry = new _tokenizationRegistry_js__WEBPACK_IMPORTED_MODULE_2__.TokenizationRegistry();


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkComputer": () => (/* binding */ LinkComputer),
/* harmony export */   "StateMachine": () => (/* binding */ StateMachine),
/* harmony export */   "Uint8Matrix": () => (/* binding */ Uint8Matrix),
/* harmony export */   "computeLinks": () => (/* binding */ computeLinks)
/* harmony export */ });
/* harmony import */ var _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/characterClassifier.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

class Uint8Matrix {
    constructor(rows, cols, defaultValue) {
        const data = new Uint8Array(rows * cols);
        for (let i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
        }
        this._data = data;
        this.rows = rows;
        this.cols = cols;
    }
    get(row, col) {
        return this._data[row * this.cols + col];
    }
    set(row, col, value) {
        this._data[row * this.cols + col] = value;
    }
}
class StateMachine {
    constructor(edges) {
        let maxCharCode = 0;
        let maxState = 0 /* Invalid */;
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            if (chCode > maxCharCode) {
                maxCharCode = chCode;
            }
            if (from > maxState) {
                maxState = from;
            }
            if (to > maxState) {
                maxState = to;
            }
        }
        maxCharCode++;
        maxState++;
        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);
        for (let i = 0, len = edges.length; i < len; i++) {
            const [from, chCode, to] = edges[i];
            states.set(from, chCode, to);
        }
        this._states = states;
        this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
        if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0 /* Invalid */;
        }
        return this._states.get(currentState, chCode);
    }
}
// State machine for http:// or https:// or file://
let _stateMachine = null;
function getStateMachine() {
    if (_stateMachine === null) {
        _stateMachine = new StateMachine([
            [1 /* Start */, 104 /* h */, 2 /* H */],
            [1 /* Start */, 72 /* H */, 2 /* H */],
            [1 /* Start */, 102 /* f */, 6 /* F */],
            [1 /* Start */, 70 /* F */, 6 /* F */],
            [2 /* H */, 116 /* t */, 3 /* HT */],
            [2 /* H */, 84 /* T */, 3 /* HT */],
            [3 /* HT */, 116 /* t */, 4 /* HTT */],
            [3 /* HT */, 84 /* T */, 4 /* HTT */],
            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],
            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],
            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],
            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],
            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],
            [6 /* F */, 105 /* i */, 7 /* FI */],
            [6 /* F */, 73 /* I */, 7 /* FI */],
            [7 /* FI */, 108 /* l */, 8 /* FIL */],
            [7 /* FI */, 76 /* L */, 8 /* FIL */],
            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],
            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],
            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],
            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],
            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],
        ]);
    }
    return _stateMachine;
}
let _classifier = null;
function getClassifier() {
    if (_classifier === null) {
        _classifier = new _core_characterClassifier_js__WEBPACK_IMPORTED_MODULE_0__.CharacterClassifier(0 /* None */);
        // allow-any-unicode-next-line
        const FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"';
        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);
        }
        const CANNOT_END_WITH_CHARACTERS = '.,;';
        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);
        }
    }
    return _classifier;
}
class LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
        // Do not allow to end link in certain characters...
        let lastIncludedCharIndex = linkEndIndex - 1;
        do {
            const chCode = line.charCodeAt(lastIncludedCharIndex);
            const chClass = classifier.get(chCode);
            if (chClass !== 2 /* CannotEndIn */) {
                break;
            }
            lastIncludedCharIndex--;
        } while (lastIncludedCharIndex > linkBeginIndex);
        // Handle links enclosed in parens, square brackets and curlys.
        if (linkBeginIndex > 0) {
            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)
                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)
                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {
                // Do not end in ) if ( is before the link start
                // Do not end in ] if [ is before the link start
                // Do not end in } if { is before the link start
                lastIncludedCharIndex--;
            }
        }
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: linkBeginIndex + 1,
                endLineNumber: lineNumber,
                endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
        };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
        const classifier = getClassifier();
        const result = [];
        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            const line = model.getLineContent(i);
            const len = line.length;
            let j = 0;
            let linkBeginIndex = 0;
            let linkBeginChCode = 0;
            let state = 1 /* Start */;
            let hasOpenParens = false;
            let hasOpenSquareBracket = false;
            let inSquareBrackets = false;
            let hasOpenCurlyBracket = false;
            while (j < len) {
                let resetStateMachine = false;
                const chCode = line.charCodeAt(j);
                if (state === 13 /* Accept */) {
                    let chClass;
                    switch (chCode) {
                        case 40 /* OpenParen */:
                            hasOpenParens = true;
                            chClass = 0 /* None */;
                            break;
                        case 41 /* CloseParen */:
                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 91 /* OpenSquareBracket */:
                            inSquareBrackets = true;
                            hasOpenSquareBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 93 /* CloseSquareBracket */:
                            inSquareBrackets = false;
                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 123 /* OpenCurlyBrace */:
                            hasOpenCurlyBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 125 /* CloseCurlyBrace */:
                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        /* The following three rules make it that ' or " or ` are allowed inside links if the link began with a different one */
                        case 39 /* SingleQuote */:
                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 34 /* DoubleQuote */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 96 /* BackTick */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 42 /* Asterisk */:
                            // `*` terminates a link if the link began with `*`
                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 124 /* Pipe */:
                            // `|` terminates a link if the link began with `|`
                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 32 /* Space */:
                            // ` ` allow space in between [ and ]
                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        default:
                            chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                        resetStateMachine = true;
                    }
                }
                else if (state === 12 /* End */) {
                    let chClass;
                    if (chCode === 91 /* OpenSquareBracket */) {
                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]
                        hasOpenSquareBracket = true;
                        chClass = 0 /* None */;
                    }
                    else {
                        chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        resetStateMachine = true;
                    }
                    else {
                        state = 13 /* Accept */;
                    }
                }
                else {
                    state = stateMachine.nextState(state, chCode);
                    if (state === 0 /* Invalid */) {
                        resetStateMachine = true;
                    }
                }
                if (resetStateMachine) {
                    state = 1 /* Start */;
                    hasOpenParens = false;
                    hasOpenSquareBracket = false;
                    hasOpenCurlyBracket = false;
                    // Record where the link started
                    linkBeginIndex = j + 1;
                    linkBeginChCode = chCode;
                }
                j++;
            }
            if (state === 13 /* Accept */) {
                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
        }
        return result;
    }
}
/**
 * Returns an array of all links contains in the provided
 * document. *Note* that this operation is computational
 * expensive and should not run in the UI thread.
 */
function computeLinks(model) {
    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
        // Unknown caller!
        return [];
    }
    return LinkComputer.computeLinks(model);
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicInplaceReplace": () => (/* binding */ BasicInplaceReplace)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class BasicInplaceReplace {
    constructor() {
        this._defaultValueSet = [
            ['true', 'false'],
            ['True', 'False'],
            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
            ['public', 'protected', 'private'],
        ];
    }
    navigateValueSet(range1, text1, range2, text2, up) {
        if (range1 && text1) {
            const result = this.doNavigateValueSet(text1, up);
            if (result) {
                return {
                    range: range1,
                    value: result
                };
            }
        }
        if (range2 && text2) {
            const result = this.doNavigateValueSet(text2, up);
            if (result) {
                return {
                    range: range2,
                    value: result
                };
            }
        }
        return null;
    }
    doNavigateValueSet(text, up) {
        const numberResult = this.numberReplace(text, up);
        if (numberResult !== null) {
            return numberResult;
        }
        return this.textReplace(text, up);
    }
    numberReplace(value, up) {
        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));
        let n1 = Number(value);
        let n2 = parseFloat(value);
        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
                return null; // don't do negative
                //			} else if(n1 === 9 && up) {
                //				return null; // don't insert 10 into a number
            }
            else {
                n1 = Math.floor(n1 * precision);
                n1 += up ? precision : -precision;
                return String(n1 / precision);
            }
        }
        return null;
    }
    textReplace(value, up) {
        return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
        let result = null;
        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
        }
        return result;
    }
    valueSetReplace(valueSet, value, up) {
        let idx = valueSet.indexOf(value);
        if (idx >= 0) {
            idx += up ? +1 : -1;
            if (idx < 0) {
                idx = valueSet.length - 1;
            }
            else {
                idx %= valueSet.length;
            }
            return valueSet[idx];
        }
        return null;
    }
}
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApplyEditsResult": () => (/* binding */ ApplyEditsResult),
/* harmony export */   "FindMatch": () => (/* binding */ FindMatch),
/* harmony export */   "InjectedTextCursorStops": () => (/* binding */ InjectedTextCursorStops),
/* harmony export */   "MinimapPosition": () => (/* binding */ MinimapPosition),
/* harmony export */   "OverviewRulerLane": () => (/* binding */ OverviewRulerLane),
/* harmony export */   "SearchData": () => (/* binding */ SearchData),
/* harmony export */   "TextModelResolvedOptions": () => (/* binding */ TextModelResolvedOptions),
/* harmony export */   "ValidAnnotatedEditOperation": () => (/* binding */ ValidAnnotatedEditOperation),
/* harmony export */   "shouldSynchronizeModel": () => (/* binding */ shouldSynchronizeModel)
/* harmony export */ });
/* harmony import */ var _base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/objects.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/objects.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
/**
 * Position in the minimap to render the decoration.
 */
var MinimapPosition;
(function (MinimapPosition) {
    MinimapPosition[MinimapPosition["Inline"] = 1] = "Inline";
    MinimapPosition[MinimapPosition["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
var InjectedTextCursorStops;
(function (InjectedTextCursorStops) {
    InjectedTextCursorStops[InjectedTextCursorStops["Both"] = 0] = "Both";
    InjectedTextCursorStops[InjectedTextCursorStops["Right"] = 1] = "Right";
    InjectedTextCursorStops[InjectedTextCursorStops["Left"] = 2] = "Left";
    InjectedTextCursorStops[InjectedTextCursorStops["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
class TextModelResolvedOptions {
    /**
     * @internal
     */
    constructor(src) {
        this._textModelResolvedOptionsBrand = undefined;
        this.tabSize = Math.max(1, src.tabSize | 0);
        this.indentSize = src.tabSize | 0;
        this.insertSpaces = Boolean(src.insertSpaces);
        this.defaultEOL = src.defaultEOL | 0;
        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;
    }
    /**
     * @internal
     */
    equals(other) {
        return (this.tabSize === other.tabSize
            && this.indentSize === other.indentSize
            && this.insertSpaces === other.insertSpaces
            && this.defaultEOL === other.defaultEOL
            && this.trimAutoWhitespace === other.trimAutoWhitespace
            && (0,_base_common_objects_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));
    }
    /**
     * @internal
     */
    createChangeEvent(newOpts) {
        return {
            tabSize: this.tabSize !== newOpts.tabSize,
            indentSize: this.indentSize !== newOpts.indentSize,
            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
        };
    }
}
class FindMatch {
    /**
     * @internal
     */
    constructor(range, matches) {
        this._findMatchBrand = undefined;
        this.range = range;
        this.matches = matches;
    }
}
/**
 * @internal
 */
class ValidAnnotatedEditOperation {
    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {
        this.identifier = identifier;
        this.range = range;
        this.text = text;
        this.forceMoveMarkers = forceMoveMarkers;
        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;
        this._isTracked = _isTracked;
    }
}
/**
 * @internal
 */
class SearchData {
    constructor(regex, wordSeparators, simpleSearch) {
        this.regex = regex;
        this.wordSeparators = wordSeparators;
        this.simpleSearch = simpleSearch;
    }
}
/**
 * @internal
 */
class ApplyEditsResult {
    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
        this.reverseEdits = reverseEdits;
        this.changes = changes;
        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
    }
}
/**
 * @internal
 */
function shouldSynchronizeModel(model) {
    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MirrorTextModel": () => (/* binding */ MirrorTextModel)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prefixSumComputer.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



class MirrorTextModel {
    constructor(uri, lines, eol, versionId) {
        this._uri = uri;
        this._lines = lines;
        this._eol = eol;
        this._versionId = versionId;
        this._lineStarts = null;
        this._cachedTextValue = null;
    }
    dispose() {
        this._lines.length = 0;
    }
    get version() {
        return this._versionId;
    }
    getText() {
        if (this._cachedTextValue === null) {
            this._cachedTextValue = this._lines.join(this._eol);
        }
        return this._cachedTextValue;
    }
    onEvents(e) {
        if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
        }
        // Update my lines
        const changes = e.changes;
        for (const change of changes) {
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new _core_position_js__WEBPACK_IMPORTED_MODULE_1__.Position(change.range.startLineNumber, change.range.startColumn), change.text);
        }
        this._versionId = e.versionId;
        this._cachedTextValue = null;
    }
    _ensureLineStarts() {
        if (!this._lineStarts) {
            const eolLength = this._eol.length;
            const linesLength = this._lines.length;
            const lineStartValues = new Uint32Array(linesLength);
            for (let i = 0; i < linesLength; i++) {
                lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new _prefixSumComputer_js__WEBPACK_IMPORTED_MODULE_2__.PrefixSumComputer(lineStartValues);
        }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
        this._lines[lineIndex] = newValue;
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
        }
    }
    _acceptDeleteRange(range) {
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            // Delete text on the affected line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
        }
        // Take remaining text on last line and append it to remaining text on first line
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
        // Delete middle lines
        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
    }
    _acceptInsertText(position, insertText) {
        if (insertText.length === 0) {
            // Nothing to insert
            return;
        }
        const insertLines = (0,_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitLines)(insertText);
        if (insertLines.length === 1) {
            // Inserting text on one line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]
                + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
        }
        // Append overflowing text from first line to the end of text to insert
        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
        // Delete overflowing text from first line and insert text on first line
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
            + insertLines[0]);
        // Insert new lines & store lengths
        const newLengths = new Uint32Array(insertLines.length - 1);
        for (let i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
        }
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.insertValues(position.lineNumber, newLengths);
        }
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstantTimePrefixSumComputer": () => (/* binding */ ConstantTimePrefixSumComputer),
/* harmony export */   "PrefixSumComputer": () => (/* binding */ PrefixSumComputer),
/* harmony export */   "PrefixSumIndexOfResult": () => (/* binding */ PrefixSumIndexOfResult)
/* harmony export */ });
/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js");
/* harmony import */ var _base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/uint.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uint.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


class PrefixSumComputer {
    constructor(values) {
        this.values = values;
        this.prefixSum = new Uint32Array(values.length);
        this.prefixSumValidIndex = new Int32Array(1);
        this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
        insertIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(insertIndex);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        const insertValuesLen = insertValues.length;
        if (insertValuesLen === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length + insertValuesLen);
        this.values.set(oldValues.subarray(0, insertIndex), 0);
        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
        this.values.set(insertValues, insertIndex);
        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
        }
        this.prefixSum = new Uint32Array(this.values.length);
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    setValue(index, value) {
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);
        value = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(value);
        if (this.values[index] === value) {
            return false;
        }
        this.values[index] = value;
        if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
        }
        return true;
    }
    removeValues(startIndex, count) {
        startIndex = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(startIndex);
        count = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(count);
        const oldValues = this.values;
        const oldPrefixSum = this.prefixSum;
        if (startIndex >= oldValues.length) {
            return false;
        }
        const maxCount = oldValues.length - startIndex;
        if (count >= maxCount) {
            count = maxCount;
        }
        if (count === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length - count);
        this.values.set(oldValues.subarray(0, startIndex), 0);
        this.values.set(oldValues.subarray(startIndex + count), startIndex);
        this.prefixSum = new Uint32Array(this.values.length);
        if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
        }
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    }
    getTotalSum() {
        if (this.values.length === 0) {
            return 0;
        }
        return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index) {
        if (index < 0) {
            return 0;
        }
        index = (0,_base_common_uint_js__WEBPACK_IMPORTED_MODULE_1__.toUint32)(index);
        return this._getPrefixSum(index);
    }
    _getPrefixSum(index) {
        if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
        }
        let startIndex = this.prefixSumValidIndex[0] + 1;
        if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
        }
        if (index >= this.values.length) {
            index = this.values.length - 1;
        }
        for (let i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
        }
        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
        return this.prefixSum[index];
    }
    getIndexOf(sum) {
        sum = Math.floor(sum);
        // Compute all sums (to get a fully valid prefixSum)
        this.getTotalSum();
        let low = 0;
        let high = this.values.length - 1;
        let mid = 0;
        let midStop = 0;
        let midStart = 0;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (sum < midStart) {
                high = mid - 1;
            }
            else if (sum >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
}
/**
 * {@link getIndexOf} has an amortized runtime complexity of O(1).
 *
 * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))
*/
class ConstantTimePrefixSumComputer {
    constructor(values) {
        this._values = values;
        this._isValid = false;
        this._validEndIndex = -1;
        this._prefixSum = [];
        this._indexBySum = [];
    }
    /**
     * @returns SUM(0 <= j < values.length, values[j])
     */
    getTotalSum() {
        this._ensureValid();
        return this._indexBySum.length;
    }
    /**
     * Returns the sum of the first `count` many items.
     * @returns `SUM(0 <= j < count, values[j])`.
     */
    getPrefixSum(count) {
        this._ensureValid();
        if (count === 0) {
            return 0;
        }
        return this._prefixSum[count - 1];
    }
    /**
     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
     */
    getIndexOf(sum) {
        this._ensureValid();
        const idx = this._indexBySum[sum];
        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;
        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);
    }
    removeValues(start, deleteCount) {
        this._values.splice(start, deleteCount);
        this._invalidate(start);
    }
    insertValues(insertIndex, insertArr) {
        this._values = (0,_base_common_arrays_js__WEBPACK_IMPORTED_MODULE_0__.arrayInsert)(this._values, insertIndex, insertArr);
        this._invalidate(insertIndex);
    }
    _invalidate(index) {
        this._isValid = false;
        this._validEndIndex = Math.min(this._validEndIndex, index - 1);
    }
    _ensureValid() {
        if (this._isValid) {
            return;
        }
        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {
            const value = this._values[i];
            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;
            this._prefixSum[i] = sumAbove + value;
            for (let j = 0; j < value; j++) {
                this._indexBySum[sumAbove + j] = i;
            }
        }
        // trim things
        this._prefixSum.length = this._values.length;
        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];
        // mark as valid
        this._isValid = true;
        this._validEndIndex = this._values.length - 1;
    }
    setValue(index, value) {
        if (this._values[index] === value) {
            // no change
            return;
        }
        this._values[index] = value;
        this._invalidate(index);
    }
}
class PrefixSumIndexOfResult {
    constructor(index, remainder) {
        this.index = index;
        this.remainder = remainder;
        this._prefixSumIndexOfResultBrand = undefined;
        this.index = index;
        this.remainder = remainder;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SearchParams": () => (/* binding */ SearchParams),
/* harmony export */   "Searcher": () => (/* binding */ Searcher),
/* harmony export */   "TextModelSearch": () => (/* binding */ TextModelSearch),
/* harmony export */   "createFindMatch": () => (/* binding */ createFindMatch),
/* harmony export */   "isMultilineRegexSource": () => (/* binding */ isMultilineRegexSource),
/* harmony export */   "isValidMatch": () => (/* binding */ isValidMatch)
/* harmony export */ });
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/wordCharacterClassifier.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





const LIMIT_FIND_COUNT = 999;
class SearchParams {
    constructor(searchString, isRegex, matchCase, wordSeparators) {
        this.searchString = searchString;
        this.isRegex = isRegex;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators;
    }
    parseSearchRequest() {
        if (this.searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        let multiline;
        if (this.isRegex) {
            multiline = isMultilineRegexSource(this.searchString);
        }
        else {
            multiline = (this.searchString.indexOf('\n') >= 0);
        }
        let regex = null;
        try {
            regex = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.createRegExp(this.searchString, this.isRegex, {
                matchCase: this.matchCase,
                wholeWord: false,
                multiline: multiline,
                global: true,
                unicode: true
            });
        }
        catch (err) {
            return null;
        }
        if (!regex) {
            return null;
        }
        let canUseSimpleSearch = (!this.isRegex && !multiline);
        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {
            // casing might make a difference
            canUseSimpleSearch = this.matchCase;
        }
        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.SearchData(regex, this.wordSeparators ? (0,_core_wordCharacterClassifier_js__WEBPACK_IMPORTED_MODULE_1__.getMapForWordSeparators)(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);
    }
}
function isMultilineRegexSource(searchString) {
    if (!searchString || searchString.length === 0) {
        return false;
    }
    for (let i = 0, len = searchString.length; i < len; i++) {
        const chCode = searchString.charCodeAt(i);
        if (chCode === 92 /* Backslash */) {
            // move to next char
            i++;
            if (i >= len) {
                // string ends with a \
                break;
            }
            const nextChCode = searchString.charCodeAt(i);
            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */) {
                return true;
            }
        }
    }
    return false;
}
function createFindMatch(range, rawMatches, captureMatches) {
    if (!captureMatches) {
        return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, null);
    }
    const matches = [];
    for (let i = 0, len = rawMatches.length; i < len; i++) {
        matches[i] = rawMatches[i];
    }
    return new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(range, matches);
}
class LineFeedCounter {
    constructor(text) {
        const lineFeedsOffsets = [];
        let lineFeedsOffsetsLen = 0;
        for (let i = 0, textLen = text.length; i < textLen; i++) {
            if (text.charCodeAt(i) === 10 /* LineFeed */) {
                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;
            }
        }
        this._lineFeedsOffsets = lineFeedsOffsets;
    }
    findLineFeedCountBeforeOffset(offset) {
        const lineFeedsOffsets = this._lineFeedsOffsets;
        let min = 0;
        let max = lineFeedsOffsets.length - 1;
        if (max === -1) {
            // no line feeds
            return 0;
        }
        if (offset <= lineFeedsOffsets[0]) {
            // before first line feed
            return 0;
        }
        while (min < max) {
            const mid = min + ((max - min) / 2 >> 0);
            if (lineFeedsOffsets[mid] >= offset) {
                max = mid - 1;
            }
            else {
                if (lineFeedsOffsets[mid + 1] >= offset) {
                    // bingo!
                    min = mid;
                    max = mid;
                }
                else {
                    min = mid + 1;
                }
            }
        }
        return min + 1;
    }
}
class TextModelSearch {
    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return [];
        }
        if (searchData.regex.multiline) {
            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);
        }
        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);
    }
    /**
     * Multiline search always executes on the lines concatenated with \n.
     * We must therefore compensate for the count of \n in case the model is CRLF
     */
    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {
        let startOffset;
        let lineFeedCountBeforeMatch = 0;
        if (lfCounter) {
            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);
            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \r as there were \n */;
        }
        else {
            startOffset = deltaOffset + matchIndex;
        }
        let endOffset;
        if (lfCounter) {
            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);
            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;
            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \r as there were \n */;
        }
        else {
            endOffset = startOffset + match0.length;
        }
        const startPosition = model.getPositionAt(startOffset);
        const endPosition = model.getPositionAt(endOffset);
        return new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
    }
    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {
        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        const text = model.getValueInRange(searchRange, 1 /* LF */);
        const lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
        const result = [];
        let counter = 0;
        let m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
            if (counter >= limitResultCount) {
                return result;
            }
        }
        return result;
    }
    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {
        const result = [];
        let resultLen = 0;
        // Early case for a search range that starts & stops on the same line number
        if (searchRange.startLineNumber === searchRange.endLineNumber) {
            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
            return result;
        }
        // Collect results from first line
        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);
        // Collect results from middle lines
        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {
            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        // Collect results from last line
        if (resultLen < limitResultCount) {
            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);
        }
        return result;
    }
    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
        const wordSeparators = searchData.wordSeparators;
        if (!captureMatches && searchData.simpleSearch) {
            const searchString = searchData.simpleSearch;
            const searchStringLen = searchString.length;
            const textLength = text.length;
            let lastMatchIndex = -searchStringLen;
            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                    result[resultLen++] = new _model_js__WEBPACK_IMPORTED_MODULE_4__.FindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            }
            return resultLen;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        let m;
        // Reset regex to search from the beginning
        searcher.reset(0);
        do {
            m = searcher.next(text);
            if (m) {
                result[resultLen++] = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                if (resultLen >= limitResultCount) {
                    return resultLen;
                }
            }
        } while (m);
        return resultLen;
    }
    static findNextMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {
        const searchTextStart = new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(searchStart.lineNumber, 1);
        const deltaOffset = model.getOffsetAt(searchTextStart);
        const lineCount = model.getLineCount();
        // We always execute multiline search over the lines joined with \n
        // This makes it that \n will match the EOL for both CRLF and LF models
        // We compensate for offset errors in `_getMultilineMatchRange`
        const text = model.getValueInRange(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);
        const lfCounter = (model.getEOL() === '\r\n' ? new LineFeedCounter(text) : null);
        searcher.reset(searchStart.column - 1);
        let m = searcher.next(text);
        if (m) {
            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);
        }
        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {
            // Try again from the top
            return this._doFindNextMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(1, 1), searcher, captureMatches);
        }
        return null;
    }
    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        // Look in first line
        const text = model.getLineContent(startLineNumber);
        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);
        if (r) {
            return r;
        }
        for (let i = 1; i <= lineCount; i++) {
            const lineIndex = (startLineNumber + i - 1) % lineCount;
            const text = model.getLineContent(lineIndex + 1);
            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);
            if (r) {
                return r;
            }
        }
        return null;
    }
    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {
        // Set regex to search from column
        searcher.reset(fromColumn - 1);
        const m = searcher.next(text);
        if (m) {
            return createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return null;
    }
    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
            return null;
        }
        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);
        if (searchData.regex.multiline) {
            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);
        }
        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);
    }
    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {
        const matches = this._doFindMatchesMultiline(model, new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);
        if (matches.length > 0) {
            return matches[matches.length - 1];
        }
        const lineCount = model.getLineCount();
        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
            // Try again with all content
            return this._doFindPreviousMatchMultiline(model, new _core_position_js__WEBPACK_IMPORTED_MODULE_2__.Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);
        }
        return null;
    }
    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {
        const lineCount = model.getLineCount();
        const startLineNumber = searchStart.lineNumber;
        // Look in first line
        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);
        if (r) {
            return r;
        }
        for (let i = 1; i <= lineCount; i++) {
            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
            const text = model.getLineContent(lineIndex + 1);
            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);
            if (r) {
                return r;
            }
        }
        return null;
    }
    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {
        let bestResult = null;
        let m;
        searcher.reset(0);
        while ((m = searcher.next(text))) {
            bestResult = createFindMatch(new _core_range_js__WEBPACK_IMPORTED_MODULE_3__.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
        }
        return bestResult;
    }
}
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
        // Match starts at start of string
        return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {
        // The character before the match is a word separator
        return true;
    }
    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {
        // The character before the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        const firstCharInMatch = text.charCodeAt(matchStartIndex);
        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {
            // The first character inside the match is a word separator
            return true;
        }
    }
    return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
        // Match ends at end of string
        return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {
        // The character after the match is a word separator
        return true;
    }
    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {
        // The character after the match is line break or carriage return.
        return true;
    }
    if (matchLength > 0) {
        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {
            // The last character in the match is a word separator
            return true;
        }
    }
    return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)
        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));
}
class Searcher {
    constructor(wordSeparators, searchRegex) {
        this._wordSeparators = wordSeparators;
        this._searchRegex = searchRegex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    }
    reset(lastIndex) {
        this._searchRegex.lastIndex = lastIndex;
        this._prevMatchStartIndex = -1;
        this._prevMatchLength = 0;
    }
    next(text) {
        const textLength = text.length;
        let m;
        do {
            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
                // Reached the end of the line
                return null;
            }
            m = this._searchRegex.exec(text);
            if (!m) {
                return null;
            }
            const matchStartIndex = m.index;
            const matchLength = m[0].length;
            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
                if (matchLength === 0) {
                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here
                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise
                    if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_0__.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {
                        this._searchRegex.lastIndex += 2;
                    }
                    else {
                        this._searchRegex.lastIndex += 1;
                    }
                    continue;
                }
                // Exit early if the regex matches the same range twice
                return null;
            }
            this._prevMatchStartIndex = matchStartIndex;
            this._prevMatchLength = matchLength;
            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
                return m;
            }
        } while (m);
        return null;
    }
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyMod": () => (/* binding */ KeyMod),
/* harmony export */   "createMonacoBaseAPI": () => (/* binding */ createMonacoBaseAPI)
/* harmony export */ });
/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js");
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/event.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/keyCodes.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/uri.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _core_selection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/selection.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../languages.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js");
/* harmony import */ var _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../standalone/standaloneEnums.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









class KeyMod {
    static chord(firstPart, secondPart) {
        return (0,_base_common_keyCodes_js__WEBPACK_IMPORTED_MODULE_2__.KeyChord)(firstPart, secondPart);
    }
}
KeyMod.CtrlCmd = 2048 /* CtrlCmd */;
KeyMod.Shift = 1024 /* Shift */;
KeyMod.Alt = 512 /* Alt */;
KeyMod.WinCtrl = 256 /* WinCtrl */;
function createMonacoBaseAPI() {
    return {
        editor: undefined,
        languages: undefined,
        CancellationTokenSource: _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource,
        Emitter: _base_common_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter,
        KeyCode: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.KeyCode,
        KeyMod: KeyMod,
        Position: _core_position_js__WEBPACK_IMPORTED_MODULE_4__.Position,
        Range: _core_range_js__WEBPACK_IMPORTED_MODULE_5__.Range,
        Selection: _core_selection_js__WEBPACK_IMPORTED_MODULE_6__.Selection,
        SelectionDirection: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.SelectionDirection,
        MarkerSeverity: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerSeverity,
        MarkerTag: _standalone_standaloneEnums_js__WEBPACK_IMPORTED_MODULE_8__.MarkerTag,
        Uri: _base_common_uri_js__WEBPACK_IMPORTED_MODULE_3__.URI,
        Token: _languages_js__WEBPACK_IMPORTED_MODULE_7__.Token
    };
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorSimpleWorker": () => (/* binding */ EditorSimpleWorker),
/* harmony export */   "MirrorModel": () => (/* binding */ MirrorModel),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../base/common/diff/diff.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");
/* harmony import */ var _base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/platform.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js");
/* harmony import */ var _base_common_uri_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/uri.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/uri.js");
/* harmony import */ var _core_position_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/position.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js");
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../diff/diffComputer.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js");
/* harmony import */ var _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/mirrorTextModel.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/wordHelper.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/* harmony import */ var _languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../languages/linkComputer.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js");
/* harmony import */ var _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../languages/supports/inplaceReplaceSupport.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js");
/* harmony import */ var _editorBaseApi_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./editorBaseApi.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js");
/* harmony import */ var _base_common_types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../base/common/types.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js");
/* harmony import */ var _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../base/common/stopwatch.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");
/* harmony import */ var _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./unicodeTextModelHighlighter.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};














/**
 * @internal
 */
class MirrorModel extends _model_mirrorTextModel_js__WEBPACK_IMPORTED_MODULE_6__.MirrorTextModel {
    get uri() {
        return this._uri;
    }
    get eol() {
        return this._eol;
    }
    getValue() {
        return this.getText();
    }
    getLinesContent() {
        return this._lines.slice(0);
    }
    getLineCount() {
        return this._lines.length;
    }
    getLineContent(lineNumber) {
        return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
        const wordAtText = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_7__.getWordAtText)(position.column, (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_7__.ensureValidWordDefinition)(wordDefinition), this._lines[position.lineNumber - 1], 0);
        if (wordAtText) {
            return new _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
        }
        return null;
    }
    words(wordDefinition) {
        const lines = this._lines;
        const wordenize = this._wordenize.bind(this);
        let lineNumber = 0;
        let lineText = '';
        let wordRangesIdx = 0;
        let wordRanges = [];
        return {
            *[Symbol.iterator]() {
                while (true) {
                    if (wordRangesIdx < wordRanges.length) {
                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                        wordRangesIdx += 1;
                        yield value;
                    }
                    else {
                        if (lineNumber < lines.length) {
                            lineText = lines[lineNumber];
                            wordRanges = wordenize(lineText, wordDefinition);
                            wordRangesIdx = 0;
                            lineNumber += 1;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        };
    }
    getLineWords(lineNumber, wordDefinition) {
        const content = this._lines[lineNumber - 1];
        const ranges = this._wordenize(content, wordDefinition);
        const words = [];
        for (const range of ranges) {
            words.push({
                word: content.substring(range.start, range.end),
                startColumn: range.start + 1,
                endColumn: range.end + 1
            });
        }
        return words;
    }
    _wordenize(content, wordDefinition) {
        const result = [];
        let match;
        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure
        while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
                // it did match the empty string
                break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
        }
        return result;
    }
    getValueInRange(range) {
        range = this._validateRange(range);
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
        }
        const lineEnding = this._eol;
        const startLineIndex = range.startLineNumber - 1;
        const endLineIndex = range.endLineNumber - 1;
        const resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    }
    offsetAt(position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        const out = this._lineStarts.getIndexOf(offset);
        const lineLength = this._lines[out.index].length;
        // Ensure we return a valid position
        return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
        };
    }
    _validateRange(range) {
        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
        if (start.lineNumber !== range.startLineNumber
            || start.column !== range.startColumn
            || end.lineNumber !== range.endLineNumber
            || end.column !== range.endColumn) {
            return {
                startLineNumber: start.lineNumber,
                startColumn: start.column,
                endLineNumber: end.lineNumber,
                endColumn: end.column
            };
        }
        return range;
    }
    _validatePosition(position) {
        if (!_core_position_js__WEBPACK_IMPORTED_MODULE_3__.Position.isIPosition(position)) {
            throw new Error('bad position');
        }
        let { lineNumber, column } = position;
        let hasChanged = false;
        if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
        }
        else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
        }
        else {
            const maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
                column = 1;
                hasChanged = true;
            }
            else if (column > maxCharacter) {
                column = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        else {
            return { lineNumber, column };
        }
    }
}
/**
 * @internal
 */
class EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
        this._host = host;
        this._models = Object.create(null);
        this._foreignModuleFactory = foreignModuleFactory;
        this._foreignModule = null;
    }
    dispose() {
        this._models = Object.create(null);
    }
    _getModel(uri) {
        return this._models[uri];
    }
    _getModels() {
        const all = [];
        Object.keys(this._models).forEach((key) => all.push(this._models[key]));
        return all;
    }
    acceptNewModel(data) {
        this._models[data.url] = new MirrorModel(_base_common_uri_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e) {
        if (!this._models[strURL]) {
            return;
        }
        const model = this._models[strURL];
        model.onEvents(e);
    }
    acceptRemovedModel(strURL) {
        if (!this._models[strURL]) {
            return;
        }
        delete this._models[strURL];
    }
    computeUnicodeHighlights(url, options, range) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(url);
            if (!model) {
                return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
            }
            return _unicodeTextModelHighlighter_js__WEBPACK_IMPORTED_MODULE_13__.UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
        });
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const original = this._getModel(originalUrl);
            const modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            const originalLines = original.getLinesContent();
            const modifiedLines = modified.getLinesContent();
            const diffComputer = new _diff_diffComputer_js__WEBPACK_IMPORTED_MODULE_5__.DiffComputer(originalLines, modifiedLines, {
                shouldComputeCharChanges: true,
                shouldPostProcessCharChanges: true,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldMakePrettyDiff: true,
                maxComputationTime: maxComputationTime
            });
            const diffResult = diffComputer.computeDiff();
            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));
            return {
                quitEarly: diffResult.quitEarly,
                identical: identical,
                changes: diffResult.changes
            };
        });
    }
    _modelsAreIdentical(original, modified) {
        const originalLineCount = original.getLineCount();
        const modifiedLineCount = modified.getLineCount();
        if (originalLineCount !== modifiedLineCount) {
            return false;
        }
        for (let line = 1; line <= originalLineCount; line++) {
            const originalLine = original.getLineContent(line);
            const modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
                return false;
            }
        }
        return true;
    }
    computeMoreMinimalEdits(modelUrl, edits) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return edits;
            }
            const result = [];
            let lastEol = undefined;
            edits = edits.slice(0).sort((a, b) => {
                if (a.range && b.range) {
                    return _core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range.compareRangesUsingStarts(a.range, b.range);
                }
                // eol only changes should go to the end
                const aRng = a.range ? 0 : 1;
                const bRng = b.range ? 0 : 1;
                return aRng - bRng;
            });
            for (let { range, text, eol } of edits) {
                if (typeof eol === 'number') {
                    lastEol = eol;
                }
                if (_core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range.isEmpty(range) && !text) {
                    // empty change
                    continue;
                }
                const original = model.getValueInRange(range);
                text = text.replace(/\r\n|\n|\r/g, model.eol);
                if (original === text) {
                    // noop
                    continue;
                }
                // make sure diff won't take too long
                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                    result.push({ range, text });
                    continue;
                }
                // compute diff between original and edit.text
                const changes = (0,_base_common_diff_diff_js__WEBPACK_IMPORTED_MODULE_0__.stringDiff)(original, text, false);
                const editOffset = model.offsetAt(_core_range_js__WEBPACK_IMPORTED_MODULE_4__.Range.lift(range).getStartPosition());
                for (const change of changes) {
                    const start = model.positionAt(editOffset + change.originalStart);
                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                    const newEdit = {
                        text: text.substr(change.modifiedStart, change.modifiedLength),
                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                    };
                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                        result.push(newEdit);
                    }
                }
            }
            if (typeof lastEol === 'number') {
                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
            }
            return result;
        });
    }
    // ---- END minimal edits ---------------------------------------------------------------
    computeLinks(modelUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            return (0,_languages_linkComputer_js__WEBPACK_IMPORTED_MODULE_8__.computeLinks)(model);
        });
    }
    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            const sw = new _base_common_stopwatch_js__WEBPACK_IMPORTED_MODULE_12__.StopWatch(true);
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const seen = new Set();
            outer: for (let url of modelUrls) {
                const model = this._getModel(url);
                if (!model) {
                    continue;
                }
                for (let word of model.words(wordDefRegExp)) {
                    if (word === leadingWord || !isNaN(Number(word))) {
                        continue;
                    }
                    seen.add(word);
                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {
                        break outer;
                    }
                }
            }
            return { words: Array.from(seen), duration: sw.elapsed() };
        });
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return Object.create(null);
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            const result = Object.create(null);
            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
                const words = model.getLineWords(line, wordDefRegExp);
                for (const word of words) {
                    if (!isNaN(Number(word.word))) {
                        continue;
                    }
                    let array = result[word.word];
                    if (!array) {
                        array = [];
                        result[word.word] = array;
                    }
                    array.push({
                        startLineNumber: line,
                        startColumn: word.startColumn,
                        endLineNumber: line,
                        endColumn: word.endColumn
                    });
                }
            }
            return result;
        });
    }
    //#endregion
    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
                range = {
                    startLineNumber: range.startLineNumber,
                    startColumn: range.startColumn,
                    endLineNumber: range.endLineNumber,
                    endColumn: range.endColumn + 1
                };
            }
            const selectionText = model.getValueInRange(range);
            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            if (!wordRange) {
                return null;
            }
            const word = model.getValueInRange(wordRange);
            const result = _languages_supports_inplaceReplaceSupport_js__WEBPACK_IMPORTED_MODULE_9__.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return result;
        });
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
        const proxyMethodRequest = (method, args) => {
            return this._host.fhr(method, args);
        };
        const foreignHost = _base_common_types_js__WEBPACK_IMPORTED_MODULE_11__.createProxyObject(foreignHostMethods, proxyMethodRequest);
        const ctx = {
            host: foreignHost,
            getMirrorModels: () => {
                return this._getModels();
            }
        };
        if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            // static foreing module
            return Promise.resolve(_base_common_types_js__WEBPACK_IMPORTED_MODULE_11__.getAllMethodNames(this._foreignModule));
        }
        // ESM-comment-begin
        // 		return new Promise<any>((resolve, reject) => {
        // 			require([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {
        // 				this._foreignModule = foreignModule.create(ctx, createData);
        // 
        // 				resolve(types.getAllMethodNames(this._foreignModule));
        // 
        // 			}, reject);
        // 		});
        // ESM-comment-end
        // ESM-uncomment-begin
        return Promise.reject(new Error(`Unexpected usage`));
        // ESM-uncomment-end
    }
    // foreign method request
    fmr(method, args) {
        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
}
// ---- END diff --------------------------------------------------------------------------
// ---- BEGIN minimal edits ---------------------------------------------------------------
EditorSimpleWorker._diffLimit = 100000;
// ---- BEGIN suggest --------------------------------------------------------------------------
EditorSimpleWorker._suggestionsLimit = 10000;
/**
 * Called on the worker side
 * @internal
 */
function create(host) {
    return new EditorSimpleWorker(host, null);
}
if (typeof importScripts === 'function') {
    // Running in a web worker
    _base_common_platform_js__WEBPACK_IMPORTED_MODULE_1__.globals.monaco = (0,_editorBaseApi_js__WEBPACK_IMPORTED_MODULE_10__.createMonacoBaseAPI)();
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnicodeTextModelHighlighter": () => (/* binding */ UnicodeTextModelHighlighter)
/* harmony export */ });
/* harmony import */ var _core_range_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/range.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js");
/* harmony import */ var _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/textModelSearch.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js");
/* harmony import */ var _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/strings.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js");
/* harmony import */ var _base_common_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/types.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/types.js");
/* harmony import */ var _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/wordHelper.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





class UnicodeTextModelHighlighter {
    static computeUnicodeHighlights(model, options, range) {
        const startLine = range ? range.startLineNumber : 1;
        const endLine = range ? range.endLineNumber : model.getLineCount();
        const codePointHighlighter = new CodePointHighlighter(options);
        const candidates = codePointHighlighter.getCandidateCodePoints();
        let regex;
        if (candidates === 'allNonBasicAscii') {
            regex = new RegExp('[^\\t\\n\\r\\x20-\\x7E]', 'g');
        }
        else {
            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');
        }
        const searcher = new _model_textModelSearch_js__WEBPACK_IMPORTED_MODULE_1__.Searcher(null, regex);
        const ranges = [];
        let hasMore = false;
        let m;
        let ambiguousCharacterCount = 0;
        let invisibleCharacterCount = 0;
        let nonBasicAsciiCharacterCount = 0;
        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
            const lineContent = model.getLineContent(lineNumber);
            const lineLength = lineContent.length;
            // Reset regex to search from the beginning
            searcher.reset(0);
            do {
                m = searcher.next(lineContent);
                if (m) {
                    let startIndex = m.index;
                    let endIndex = m.index + m[0].length;
                    // Extend range to entire code point
                    if (startIndex > 0) {
                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {
                            startIndex--;
                        }
                    }
                    if (endIndex + 1 < lineLength) {
                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                        if (_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isHighSurrogate(charCodeBefore)) {
                            endIndex++;
                        }
                    }
                    const str = lineContent.substring(startIndex, endIndex);
                    const word = (0,_core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.getWordAtText)(startIndex + 1, _core_wordHelper_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_WORD_REGEXP, lineContent, 0);
                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
                    if (highlightReason !== 0 /* None */) {
                        if (highlightReason === 3 /* Ambiguous */) {
                            ambiguousCharacterCount++;
                        }
                        else if (highlightReason === 2 /* Invisible */) {
                            invisibleCharacterCount++;
                        }
                        else if (highlightReason === 1 /* NonBasicASCII */) {
                            nonBasicAsciiCharacterCount++;
                        }
                        else {
                            (0,_base_common_types_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(highlightReason);
                        }
                        const MAX_RESULT_LENGTH = 1000;
                        if (ranges.length >= MAX_RESULT_LENGTH) {
                            hasMore = true;
                            break forLoop;
                        }
                        ranges.push(new _core_range_js__WEBPACK_IMPORTED_MODULE_0__.Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
                    }
                }
            } while (m);
        }
        return {
            ranges,
            hasMore,
            ambiguousCharacterCount,
            invisibleCharacterCount,
            nonBasicAsciiCharacterCount
        };
    }
    static computeUnicodeHighlightReason(char, options) {
        const codePointHighlighter = new CodePointHighlighter(options);
        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
        switch (reason) {
            case 0 /* None */:
                return null;
            case 2 /* Invisible */:
                return { kind: 1 /* Invisible */ };
            case 3 /* Ambiguous */: {
                const codePoint = char.codePointAt(0);
                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
                const notAmbiguousInLocales = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getLocales().filter((l) => !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
                return { kind: 0 /* Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
            }
            case 1 /* NonBasicASCII */:
                return { kind: 2 /* NonBasicAscii */ };
        }
    }
}
function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;
    return src;
}
class CodePointHighlighter {
    constructor(options) {
        this.options = options;
        this.allowedCodePoints = new Set(options.allowedCodePoints);
        this.ambiguousCharacters = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
        if (this.options.nonBasicASCII) {
            return 'allNonBasicAscii';
        }
        const set = new Set();
        if (this.options.invisibleCharacters) {
            for (const cp of _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.codePoints) {
                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
                    set.add(cp);
                }
            }
        }
        if (this.options.ambiguousCharacters) {
            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
                set.add(cp);
            }
        }
        for (const cp of this.allowedCodePoints) {
            set.delete(cp);
        }
        return set;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
        const codePoint = character.codePointAt(0);
        if (this.allowedCodePoints.has(codePoint)) {
            return 0 /* None */;
        }
        if (this.options.nonBasicASCII) {
            return 1 /* NonBasicASCII */;
        }
        let hasBasicASCIICharacters = false;
        let hasNonConfusableNonBasicAsciiCharacter = false;
        if (wordContext) {
            for (let char of wordContext) {
                const codePoint = char.codePointAt(0);
                const isBasicASCII = _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.isBasicASCII(char);
                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;
                if (!isBasicASCII &&
                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&
                    !_base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {
                    hasNonConfusableNonBasicAsciiCharacter = true;
                }
            }
        }
        if (
        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&
            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {
            return 0 /* None */;
        }
        if (this.options.invisibleCharacters) {
            // TODO check for emojis
            if (!isAllowedInvisibleCharacter(character) && _base_common_strings_js__WEBPACK_IMPORTED_MODULE_2__.InvisibleCharacters.isInvisibleCharacter(codePoint)) {
                return 2 /* Invisible */;
            }
        }
        if (this.options.ambiguousCharacters) {
            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
                return 3 /* Ambiguous */;
            }
        }
        return 0 /* None */;
    }
}
function isAllowedInvisibleCharacter(character) {
    return character === ' ' || character === '\n' || character === '\t';
}


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessibilitySupport": () => (/* binding */ AccessibilitySupport),
/* harmony export */   "CompletionItemInsertTextRule": () => (/* binding */ CompletionItemInsertTextRule),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionTriggerKind": () => (/* binding */ CompletionTriggerKind),
/* harmony export */   "ContentWidgetPositionPreference": () => (/* binding */ ContentWidgetPositionPreference),
/* harmony export */   "CursorChangeReason": () => (/* binding */ CursorChangeReason),
/* harmony export */   "DefaultEndOfLine": () => (/* binding */ DefaultEndOfLine),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "EditorAutoIndentStrategy": () => (/* binding */ EditorAutoIndentStrategy),
/* harmony export */   "EditorOption": () => (/* binding */ EditorOption),
/* harmony export */   "EndOfLinePreference": () => (/* binding */ EndOfLinePreference),
/* harmony export */   "EndOfLineSequence": () => (/* binding */ EndOfLineSequence),
/* harmony export */   "IndentAction": () => (/* binding */ IndentAction),
/* harmony export */   "InjectedTextCursorStops": () => (/* binding */ InjectedTextCursorStops),
/* harmony export */   "InlayHintKind": () => (/* binding */ InlayHintKind),
/* harmony export */   "InlineCompletionTriggerKind": () => (/* binding */ InlineCompletionTriggerKind),
/* harmony export */   "KeyCode": () => (/* binding */ KeyCode),
/* harmony export */   "MarkerSeverity": () => (/* binding */ MarkerSeverity),
/* harmony export */   "MarkerTag": () => (/* binding */ MarkerTag),
/* harmony export */   "MinimapPosition": () => (/* binding */ MinimapPosition),
/* harmony export */   "MouseTargetType": () => (/* binding */ MouseTargetType),
/* harmony export */   "OverlayWidgetPositionPreference": () => (/* binding */ OverlayWidgetPositionPreference),
/* harmony export */   "OverviewRulerLane": () => (/* binding */ OverviewRulerLane),
/* harmony export */   "PositionAffinity": () => (/* binding */ PositionAffinity),
/* harmony export */   "RenderLineNumbersType": () => (/* binding */ RenderLineNumbersType),
/* harmony export */   "RenderMinimap": () => (/* binding */ RenderMinimap),
/* harmony export */   "ScrollType": () => (/* binding */ ScrollType),
/* harmony export */   "ScrollbarVisibility": () => (/* binding */ ScrollbarVisibility),
/* harmony export */   "SelectionDirection": () => (/* binding */ SelectionDirection),
/* harmony export */   "SignatureHelpTriggerKind": () => (/* binding */ SignatureHelpTriggerKind),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextEditorCursorBlinkingStyle": () => (/* binding */ TextEditorCursorBlinkingStyle),
/* harmony export */   "TextEditorCursorStyle": () => (/* binding */ TextEditorCursorStyle),
/* harmony export */   "TrackedRangeStickiness": () => (/* binding */ TrackedRangeStickiness),
/* harmony export */   "WrappingIndent": () => (/* binding */ WrappingIndent)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.
var AccessibilitySupport;
(function (AccessibilitySupport) {
    /**
     * This should be the browser case where it is not known if a screen reader is attached or no.
     */
    AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
    AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
    AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CompletionItemInsertTextRule;
(function (CompletionItemInsertTextRule) {
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    /**
     * `insertText` is a snippet.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
    CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
    CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
    CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
    CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
    CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
    CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
    CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
    CompletionItemKind[CompletionItemKind["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * How a suggest provider was triggered.
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
/**
 * A positioning preference for rendering content widgets.
 */
var ContentWidgetPositionPreference;
(function (ContentWidgetPositionPreference) {
    /**
     * Place the content widget exactly at a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
    /**
     * Place the content widget above a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
    /**
     * Place the content widget below a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
/**
 * Describes the reason the cursor has changed its position.
 */
var CursorChangeReason;
(function (CursorChangeReason) {
    /**
     * Unknown or not set.
     */
    CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
    /**
     * A `model.setValue()` was called.
     */
    CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    /**
     * There was an explicit user gesture.
     */
    CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
    /**
     * There was a Paste.
     */
    CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
    /**
     * There was an Undo.
     */
    CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
    /**
     * There was a Redo.
     */
    CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
/**
 * The default end of line to use when instantiating models.
 */
var DefaultEndOfLine;
(function (DefaultEndOfLine) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * Configuration options for auto indentation in the editor
 */
var EditorAutoIndentStrategy;
(function (EditorAutoIndentStrategy) {
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["None"] = 0] = "None";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function (EditorOption) {
    EditorOption[EditorOption["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption[EditorOption["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption[EditorOption["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption[EditorOption["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption[EditorOption["ariaLabel"] = 4] = "ariaLabel";
    EditorOption[EditorOption["autoClosingBrackets"] = 5] = "autoClosingBrackets";
    EditorOption[EditorOption["autoClosingDelete"] = 6] = "autoClosingDelete";
    EditorOption[EditorOption["autoClosingOvertype"] = 7] = "autoClosingOvertype";
    EditorOption[EditorOption["autoClosingQuotes"] = 8] = "autoClosingQuotes";
    EditorOption[EditorOption["autoIndent"] = 9] = "autoIndent";
    EditorOption[EditorOption["automaticLayout"] = 10] = "automaticLayout";
    EditorOption[EditorOption["autoSurround"] = 11] = "autoSurround";
    EditorOption[EditorOption["bracketPairColorization"] = 12] = "bracketPairColorization";
    EditorOption[EditorOption["guides"] = 13] = "guides";
    EditorOption[EditorOption["codeLens"] = 14] = "codeLens";
    EditorOption[EditorOption["codeLensFontFamily"] = 15] = "codeLensFontFamily";
    EditorOption[EditorOption["codeLensFontSize"] = 16] = "codeLensFontSize";
    EditorOption[EditorOption["colorDecorators"] = 17] = "colorDecorators";
    EditorOption[EditorOption["columnSelection"] = 18] = "columnSelection";
    EditorOption[EditorOption["comments"] = 19] = "comments";
    EditorOption[EditorOption["contextmenu"] = 20] = "contextmenu";
    EditorOption[EditorOption["copyWithSyntaxHighlighting"] = 21] = "copyWithSyntaxHighlighting";
    EditorOption[EditorOption["cursorBlinking"] = 22] = "cursorBlinking";
    EditorOption[EditorOption["cursorSmoothCaretAnimation"] = 23] = "cursorSmoothCaretAnimation";
    EditorOption[EditorOption["cursorStyle"] = 24] = "cursorStyle";
    EditorOption[EditorOption["cursorSurroundingLines"] = 25] = "cursorSurroundingLines";
    EditorOption[EditorOption["cursorSurroundingLinesStyle"] = 26] = "cursorSurroundingLinesStyle";
    EditorOption[EditorOption["cursorWidth"] = 27] = "cursorWidth";
    EditorOption[EditorOption["disableLayerHinting"] = 28] = "disableLayerHinting";
    EditorOption[EditorOption["disableMonospaceOptimizations"] = 29] = "disableMonospaceOptimizations";
    EditorOption[EditorOption["domReadOnly"] = 30] = "domReadOnly";
    EditorOption[EditorOption["dragAndDrop"] = 31] = "dragAndDrop";
    EditorOption[EditorOption["emptySelectionClipboard"] = 32] = "emptySelectionClipboard";
    EditorOption[EditorOption["extraEditorClassName"] = 33] = "extraEditorClassName";
    EditorOption[EditorOption["fastScrollSensitivity"] = 34] = "fastScrollSensitivity";
    EditorOption[EditorOption["find"] = 35] = "find";
    EditorOption[EditorOption["fixedOverflowWidgets"] = 36] = "fixedOverflowWidgets";
    EditorOption[EditorOption["folding"] = 37] = "folding";
    EditorOption[EditorOption["foldingStrategy"] = 38] = "foldingStrategy";
    EditorOption[EditorOption["foldingHighlight"] = 39] = "foldingHighlight";
    EditorOption[EditorOption["foldingImportsByDefault"] = 40] = "foldingImportsByDefault";
    EditorOption[EditorOption["foldingMaximumRegions"] = 41] = "foldingMaximumRegions";
    EditorOption[EditorOption["unfoldOnClickAfterEndOfLine"] = 42] = "unfoldOnClickAfterEndOfLine";
    EditorOption[EditorOption["fontFamily"] = 43] = "fontFamily";
    EditorOption[EditorOption["fontInfo"] = 44] = "fontInfo";
    EditorOption[EditorOption["fontLigatures"] = 45] = "fontLigatures";
    EditorOption[EditorOption["fontSize"] = 46] = "fontSize";
    EditorOption[EditorOption["fontWeight"] = 47] = "fontWeight";
    EditorOption[EditorOption["formatOnPaste"] = 48] = "formatOnPaste";
    EditorOption[EditorOption["formatOnType"] = 49] = "formatOnType";
    EditorOption[EditorOption["glyphMargin"] = 50] = "glyphMargin";
    EditorOption[EditorOption["gotoLocation"] = 51] = "gotoLocation";
    EditorOption[EditorOption["hideCursorInOverviewRuler"] = 52] = "hideCursorInOverviewRuler";
    EditorOption[EditorOption["hover"] = 53] = "hover";
    EditorOption[EditorOption["inDiffEditor"] = 54] = "inDiffEditor";
    EditorOption[EditorOption["inlineSuggest"] = 55] = "inlineSuggest";
    EditorOption[EditorOption["letterSpacing"] = 56] = "letterSpacing";
    EditorOption[EditorOption["lightbulb"] = 57] = "lightbulb";
    EditorOption[EditorOption["lineDecorationsWidth"] = 58] = "lineDecorationsWidth";
    EditorOption[EditorOption["lineHeight"] = 59] = "lineHeight";
    EditorOption[EditorOption["lineNumbers"] = 60] = "lineNumbers";
    EditorOption[EditorOption["lineNumbersMinChars"] = 61] = "lineNumbersMinChars";
    EditorOption[EditorOption["linkedEditing"] = 62] = "linkedEditing";
    EditorOption[EditorOption["links"] = 63] = "links";
    EditorOption[EditorOption["matchBrackets"] = 64] = "matchBrackets";
    EditorOption[EditorOption["minimap"] = 65] = "minimap";
    EditorOption[EditorOption["mouseStyle"] = 66] = "mouseStyle";
    EditorOption[EditorOption["mouseWheelScrollSensitivity"] = 67] = "mouseWheelScrollSensitivity";
    EditorOption[EditorOption["mouseWheelZoom"] = 68] = "mouseWheelZoom";
    EditorOption[EditorOption["multiCursorMergeOverlapping"] = 69] = "multiCursorMergeOverlapping";
    EditorOption[EditorOption["multiCursorModifier"] = 70] = "multiCursorModifier";
    EditorOption[EditorOption["multiCursorPaste"] = 71] = "multiCursorPaste";
    EditorOption[EditorOption["occurrencesHighlight"] = 72] = "occurrencesHighlight";
    EditorOption[EditorOption["overviewRulerBorder"] = 73] = "overviewRulerBorder";
    EditorOption[EditorOption["overviewRulerLanes"] = 74] = "overviewRulerLanes";
    EditorOption[EditorOption["padding"] = 75] = "padding";
    EditorOption[EditorOption["parameterHints"] = 76] = "parameterHints";
    EditorOption[EditorOption["peekWidgetDefaultFocus"] = 77] = "peekWidgetDefaultFocus";
    EditorOption[EditorOption["definitionLinkOpensInPeek"] = 78] = "definitionLinkOpensInPeek";
    EditorOption[EditorOption["quickSuggestions"] = 79] = "quickSuggestions";
    EditorOption[EditorOption["quickSuggestionsDelay"] = 80] = "quickSuggestionsDelay";
    EditorOption[EditorOption["readOnly"] = 81] = "readOnly";
    EditorOption[EditorOption["renameOnType"] = 82] = "renameOnType";
    EditorOption[EditorOption["renderControlCharacters"] = 83] = "renderControlCharacters";
    EditorOption[EditorOption["renderFinalNewline"] = 84] = "renderFinalNewline";
    EditorOption[EditorOption["renderLineHighlight"] = 85] = "renderLineHighlight";
    EditorOption[EditorOption["renderLineHighlightOnlyWhenFocus"] = 86] = "renderLineHighlightOnlyWhenFocus";
    EditorOption[EditorOption["renderValidationDecorations"] = 87] = "renderValidationDecorations";
    EditorOption[EditorOption["renderWhitespace"] = 88] = "renderWhitespace";
    EditorOption[EditorOption["revealHorizontalRightPadding"] = 89] = "revealHorizontalRightPadding";
    EditorOption[EditorOption["roundedSelection"] = 90] = "roundedSelection";
    EditorOption[EditorOption["rulers"] = 91] = "rulers";
    EditorOption[EditorOption["scrollbar"] = 92] = "scrollbar";
    EditorOption[EditorOption["scrollBeyondLastColumn"] = 93] = "scrollBeyondLastColumn";
    EditorOption[EditorOption["scrollBeyondLastLine"] = 94] = "scrollBeyondLastLine";
    EditorOption[EditorOption["scrollPredominantAxis"] = 95] = "scrollPredominantAxis";
    EditorOption[EditorOption["selectionClipboard"] = 96] = "selectionClipboard";
    EditorOption[EditorOption["selectionHighlight"] = 97] = "selectionHighlight";
    EditorOption[EditorOption["selectOnLineNumbers"] = 98] = "selectOnLineNumbers";
    EditorOption[EditorOption["showFoldingControls"] = 99] = "showFoldingControls";
    EditorOption[EditorOption["showUnused"] = 100] = "showUnused";
    EditorOption[EditorOption["snippetSuggestions"] = 101] = "snippetSuggestions";
    EditorOption[EditorOption["smartSelect"] = 102] = "smartSelect";
    EditorOption[EditorOption["smoothScrolling"] = 103] = "smoothScrolling";
    EditorOption[EditorOption["stickyTabStops"] = 104] = "stickyTabStops";
    EditorOption[EditorOption["stopRenderingLineAfter"] = 105] = "stopRenderingLineAfter";
    EditorOption[EditorOption["suggest"] = 106] = "suggest";
    EditorOption[EditorOption["suggestFontSize"] = 107] = "suggestFontSize";
    EditorOption[EditorOption["suggestLineHeight"] = 108] = "suggestLineHeight";
    EditorOption[EditorOption["suggestOnTriggerCharacters"] = 109] = "suggestOnTriggerCharacters";
    EditorOption[EditorOption["suggestSelection"] = 110] = "suggestSelection";
    EditorOption[EditorOption["tabCompletion"] = 111] = "tabCompletion";
    EditorOption[EditorOption["tabIndex"] = 112] = "tabIndex";
    EditorOption[EditorOption["unicodeHighlighting"] = 113] = "unicodeHighlighting";
    EditorOption[EditorOption["unusualLineTerminators"] = 114] = "unusualLineTerminators";
    EditorOption[EditorOption["useShadowDOM"] = 115] = "useShadowDOM";
    EditorOption[EditorOption["useTabStops"] = 116] = "useTabStops";
    EditorOption[EditorOption["wordSeparators"] = 117] = "wordSeparators";
    EditorOption[EditorOption["wordWrap"] = 118] = "wordWrap";
    EditorOption[EditorOption["wordWrapBreakAfterCharacters"] = 119] = "wordWrapBreakAfterCharacters";
    EditorOption[EditorOption["wordWrapBreakBeforeCharacters"] = 120] = "wordWrapBreakBeforeCharacters";
    EditorOption[EditorOption["wordWrapColumn"] = 121] = "wordWrapColumn";
    EditorOption[EditorOption["wordWrapOverride1"] = 122] = "wordWrapOverride1";
    EditorOption[EditorOption["wordWrapOverride2"] = 123] = "wordWrapOverride2";
    EditorOption[EditorOption["wrappingIndent"] = 124] = "wrappingIndent";
    EditorOption[EditorOption["wrappingStrategy"] = 125] = "wrappingStrategy";
    EditorOption[EditorOption["showDeprecated"] = 126] = "showDeprecated";
    EditorOption[EditorOption["inlayHints"] = 127] = "inlayHints";
    EditorOption[EditorOption["editorClassName"] = 128] = "editorClassName";
    EditorOption[EditorOption["pixelRatio"] = 129] = "pixelRatio";
    EditorOption[EditorOption["tabFocusMode"] = 130] = "tabFocusMode";
    EditorOption[EditorOption["layoutInfo"] = 131] = "layoutInfo";
    EditorOption[EditorOption["wrappingInfo"] = 132] = "wrappingInfo";
})(EditorOption || (EditorOption = {}));
/**
 * End of line character preference.
 */
var EndOfLinePreference;
(function (EndOfLinePreference) {
    /**
     * Use the end of line character identified in the text buffer.
     */
    EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
/**
 * End of line character preference.
 */
var EndOfLineSequence;
(function (EndOfLineSequence) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var InjectedTextCursorStops;
(function (InjectedTextCursorStops) {
    InjectedTextCursorStops[InjectedTextCursorStops["Both"] = 0] = "Both";
    InjectedTextCursorStops[InjectedTextCursorStops["Right"] = 1] = "Right";
    InjectedTextCursorStops[InjectedTextCursorStops["Left"] = 2] = "Left";
    InjectedTextCursorStops[InjectedTextCursorStops["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
var KeyCode;
(function (KeyCode) {
    KeyCode[KeyCode["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    /**
     * Placed first to cover the 0 value of the enum.
     */
    KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
    KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
    KeyCode[KeyCode["Tab"] = 2] = "Tab";
    KeyCode[KeyCode["Enter"] = 3] = "Enter";
    KeyCode[KeyCode["Shift"] = 4] = "Shift";
    KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
    KeyCode[KeyCode["Alt"] = 6] = "Alt";
    KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
    KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
    KeyCode[KeyCode["Escape"] = 9] = "Escape";
    KeyCode[KeyCode["Space"] = 10] = "Space";
    KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
    KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
    KeyCode[KeyCode["End"] = 13] = "End";
    KeyCode[KeyCode["Home"] = 14] = "Home";
    KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
    KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
    KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
    KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
    KeyCode[KeyCode["Insert"] = 19] = "Insert";
    KeyCode[KeyCode["Delete"] = 20] = "Delete";
    KeyCode[KeyCode["Digit0"] = 21] = "Digit0";
    KeyCode[KeyCode["Digit1"] = 22] = "Digit1";
    KeyCode[KeyCode["Digit2"] = 23] = "Digit2";
    KeyCode[KeyCode["Digit3"] = 24] = "Digit3";
    KeyCode[KeyCode["Digit4"] = 25] = "Digit4";
    KeyCode[KeyCode["Digit5"] = 26] = "Digit5";
    KeyCode[KeyCode["Digit6"] = 27] = "Digit6";
    KeyCode[KeyCode["Digit7"] = 28] = "Digit7";
    KeyCode[KeyCode["Digit8"] = 29] = "Digit8";
    KeyCode[KeyCode["Digit9"] = 30] = "Digit9";
    KeyCode[KeyCode["KeyA"] = 31] = "KeyA";
    KeyCode[KeyCode["KeyB"] = 32] = "KeyB";
    KeyCode[KeyCode["KeyC"] = 33] = "KeyC";
    KeyCode[KeyCode["KeyD"] = 34] = "KeyD";
    KeyCode[KeyCode["KeyE"] = 35] = "KeyE";
    KeyCode[KeyCode["KeyF"] = 36] = "KeyF";
    KeyCode[KeyCode["KeyG"] = 37] = "KeyG";
    KeyCode[KeyCode["KeyH"] = 38] = "KeyH";
    KeyCode[KeyCode["KeyI"] = 39] = "KeyI";
    KeyCode[KeyCode["KeyJ"] = 40] = "KeyJ";
    KeyCode[KeyCode["KeyK"] = 41] = "KeyK";
    KeyCode[KeyCode["KeyL"] = 42] = "KeyL";
    KeyCode[KeyCode["KeyM"] = 43] = "KeyM";
    KeyCode[KeyCode["KeyN"] = 44] = "KeyN";
    KeyCode[KeyCode["KeyO"] = 45] = "KeyO";
    KeyCode[KeyCode["KeyP"] = 46] = "KeyP";
    KeyCode[KeyCode["KeyQ"] = 47] = "KeyQ";
    KeyCode[KeyCode["KeyR"] = 48] = "KeyR";
    KeyCode[KeyCode["KeyS"] = 49] = "KeyS";
    KeyCode[KeyCode["KeyT"] = 50] = "KeyT";
    KeyCode[KeyCode["KeyU"] = 51] = "KeyU";
    KeyCode[KeyCode["KeyV"] = 52] = "KeyV";
    KeyCode[KeyCode["KeyW"] = 53] = "KeyW";
    KeyCode[KeyCode["KeyX"] = 54] = "KeyX";
    KeyCode[KeyCode["KeyY"] = 55] = "KeyY";
    KeyCode[KeyCode["KeyZ"] = 56] = "KeyZ";
    KeyCode[KeyCode["Meta"] = 57] = "Meta";
    KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
    KeyCode[KeyCode["F1"] = 59] = "F1";
    KeyCode[KeyCode["F2"] = 60] = "F2";
    KeyCode[KeyCode["F3"] = 61] = "F3";
    KeyCode[KeyCode["F4"] = 62] = "F4";
    KeyCode[KeyCode["F5"] = 63] = "F5";
    KeyCode[KeyCode["F6"] = 64] = "F6";
    KeyCode[KeyCode["F7"] = 65] = "F7";
    KeyCode[KeyCode["F8"] = 66] = "F8";
    KeyCode[KeyCode["F9"] = 67] = "F9";
    KeyCode[KeyCode["F10"] = 68] = "F10";
    KeyCode[KeyCode["F11"] = 69] = "F11";
    KeyCode[KeyCode["F12"] = 70] = "F12";
    KeyCode[KeyCode["F13"] = 71] = "F13";
    KeyCode[KeyCode["F14"] = 72] = "F14";
    KeyCode[KeyCode["F15"] = 73] = "F15";
    KeyCode[KeyCode["F16"] = 74] = "F16";
    KeyCode[KeyCode["F17"] = 75] = "F17";
    KeyCode[KeyCode["F18"] = 76] = "F18";
    KeyCode[KeyCode["F19"] = 77] = "F19";
    KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
    KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ';:' key
     */
    KeyCode[KeyCode["Semicolon"] = 80] = "Semicolon";
    /**
     * For any country/region, the '+' key
     * For the US standard keyboard, the '=+' key
     */
    KeyCode[KeyCode["Equal"] = 81] = "Equal";
    /**
     * For any country/region, the ',' key
     * For the US standard keyboard, the ',<' key
     */
    KeyCode[KeyCode["Comma"] = 82] = "Comma";
    /**
     * For any country/region, the '-' key
     * For the US standard keyboard, the '-_' key
     */
    KeyCode[KeyCode["Minus"] = 83] = "Minus";
    /**
     * For any country/region, the '.' key
     * For the US standard keyboard, the '.>' key
     */
    KeyCode[KeyCode["Period"] = 84] = "Period";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '/?' key
     */
    KeyCode[KeyCode["Slash"] = 85] = "Slash";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '`~' key
     */
    KeyCode[KeyCode["Backquote"] = 86] = "Backquote";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '[{' key
     */
    KeyCode[KeyCode["BracketLeft"] = 87] = "BracketLeft";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '\|' key
     */
    KeyCode[KeyCode["Backslash"] = 88] = "Backslash";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ']}' key
     */
    KeyCode[KeyCode["BracketRight"] = 89] = "BracketRight";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ''"' key
     */
    KeyCode[KeyCode["Quote"] = 90] = "Quote";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     */
    KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
    /**
     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
     */
    KeyCode[KeyCode["IntlBackslash"] = 92] = "IntlBackslash";
    KeyCode[KeyCode["Numpad0"] = 93] = "Numpad0";
    KeyCode[KeyCode["Numpad1"] = 94] = "Numpad1";
    KeyCode[KeyCode["Numpad2"] = 95] = "Numpad2";
    KeyCode[KeyCode["Numpad3"] = 96] = "Numpad3";
    KeyCode[KeyCode["Numpad4"] = 97] = "Numpad4";
    KeyCode[KeyCode["Numpad5"] = 98] = "Numpad5";
    KeyCode[KeyCode["Numpad6"] = 99] = "Numpad6";
    KeyCode[KeyCode["Numpad7"] = 100] = "Numpad7";
    KeyCode[KeyCode["Numpad8"] = 101] = "Numpad8";
    KeyCode[KeyCode["Numpad9"] = 102] = "Numpad9";
    KeyCode[KeyCode["NumpadMultiply"] = 103] = "NumpadMultiply";
    KeyCode[KeyCode["NumpadAdd"] = 104] = "NumpadAdd";
    KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
    KeyCode[KeyCode["NumpadSubtract"] = 106] = "NumpadSubtract";
    KeyCode[KeyCode["NumpadDecimal"] = 107] = "NumpadDecimal";
    KeyCode[KeyCode["NumpadDivide"] = 108] = "NumpadDivide";
    /**
     * Cover all key codes when IME is processing input.
     */
    KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
    KeyCode[KeyCode["ABNT_C1"] = 110] = "ABNT_C1";
    KeyCode[KeyCode["ABNT_C2"] = 111] = "ABNT_C2";
    KeyCode[KeyCode["AudioVolumeMute"] = 112] = "AudioVolumeMute";
    KeyCode[KeyCode["AudioVolumeUp"] = 113] = "AudioVolumeUp";
    KeyCode[KeyCode["AudioVolumeDown"] = 114] = "AudioVolumeDown";
    KeyCode[KeyCode["BrowserSearch"] = 115] = "BrowserSearch";
    KeyCode[KeyCode["BrowserHome"] = 116] = "BrowserHome";
    KeyCode[KeyCode["BrowserBack"] = 117] = "BrowserBack";
    KeyCode[KeyCode["BrowserForward"] = 118] = "BrowserForward";
    KeyCode[KeyCode["MediaTrackNext"] = 119] = "MediaTrackNext";
    KeyCode[KeyCode["MediaTrackPrevious"] = 120] = "MediaTrackPrevious";
    KeyCode[KeyCode["MediaStop"] = 121] = "MediaStop";
    KeyCode[KeyCode["MediaPlayPause"] = 122] = "MediaPlayPause";
    KeyCode[KeyCode["LaunchMediaPlayer"] = 123] = "LaunchMediaPlayer";
    KeyCode[KeyCode["LaunchMail"] = 124] = "LaunchMail";
    KeyCode[KeyCode["LaunchApp2"] = 125] = "LaunchApp2";
    /**
     * VK_CLEAR, 0x0C, CLEAR key
     */
    KeyCode[KeyCode["Clear"] = 126] = "Clear";
    /**
     * Placed last to cover the length of the enum.
     * Please do not depend on this value!
     */
    KeyCode[KeyCode["MAX_VALUE"] = 127] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
/**
 * Position in the minimap to render the decoration.
 */
var MinimapPosition;
(function (MinimapPosition) {
    MinimapPosition[MinimapPosition["Inline"] = 1] = "Inline";
    MinimapPosition[MinimapPosition["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
/**
 * Type of hit element with the mouse in the editor.
 */
var MouseTargetType;
(function (MouseTargetType) {
    /**
     * Mouse is on top of an unknown element.
     */
    MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Mouse is on top of the textarea used for input.
     */
    MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
    /**
     * Mouse is on top of the glyph margin
     */
    MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    /**
     * Mouse is on top of the line numbers
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    /**
     * Mouse is on top of the line decorations
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    /**
     * Mouse is on top of text in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    /**
     * Mouse is on top of a view zone in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    /**
     * Mouse is on top of a content widget.
     */
    MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    /**
     * Mouse is on top of a scrollbar.
     */
    MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
    /**
     * Mouse is on top of an overlay widget.
     */
    MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    /**
     * Mouse is outside of the editor.
     */
    MouseTargetType[MouseTargetType["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
/**
 * A positioning preference for rendering overlay widgets.
 */
var OverlayWidgetPositionPreference;
(function (OverlayWidgetPositionPreference) {
    /**
     * Position the overlay widget in the top right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    /**
     * Position the overlay widget in the bottom right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    /**
     * Position the overlay widget in the top center
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var PositionAffinity;
(function (PositionAffinity) {
    /**
     * Prefers the left most position.
    */
    PositionAffinity[PositionAffinity["Left"] = 0] = "Left";
    /**
     * Prefers the right most position.
    */
    PositionAffinity[PositionAffinity["Right"] = 1] = "Right";
    /**
     * No preference.
    */
    PositionAffinity[PositionAffinity["None"] = 2] = "None";
})(PositionAffinity || (PositionAffinity = {}));
var RenderLineNumbersType;
(function (RenderLineNumbersType) {
    RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
    RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
    RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
    RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
    RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Text"] = 1] = "Text";
    RenderMinimap[RenderMinimap["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function (ScrollType) {
    ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
    ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function (ScrollbarVisibility) {
    ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
    ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
/**
 * The direction of a selection.
 */
var SelectionDirection;
(function (SelectionDirection) {
    /**
     * The selection starts above where it ends.
     */
    SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
    /**
     * The selection starts below where it ends.
     */
    SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
var TextEditorCursorBlinkingStyle;
(function (TextEditorCursorBlinkingStyle) {
    /**
     * Hidden
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
    /**
     * Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
    /**
     * Blinking with smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
    /**
     * Expand collapse animation on the y axis
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
    /**
     * No-Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
/**
 * Describes how to indent wrapped lines.
 */
var WrappingIndent;
(function (WrappingIndent) {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    WrappingIndent[WrappingIndent["None"] = 0] = "None";
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
    /**
     * Indent => wrapped lines get +1 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    /**
     * DeepIndent => wrapped lines get +2 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));


/***/ }),

/***/ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TokenizationRegistry": () => (/* binding */ TokenizationRegistry)
/* harmony export */ });
/* harmony import */ var _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/common/event.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js");
/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base/common/lifecycle.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class TokenizationRegistry {
    constructor() {
        this._map = new Map();
        this._factories = new Map();
        this._onDidChange = new _base_common_event_js__WEBPACK_IMPORTED_MODULE_0__.Emitter();
        this.onDidChange = this._onDidChange.event;
        this._colorMap = null;
    }
    fire(languages) {
        this._onDidChange.fire({
            changedLanguages: languages,
            changedColorMap: false
        });
    }
    register(language, support) {
        this._map.set(language, support);
        this.fire([language]);
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            if (this._map.get(language) !== support) {
                return;
            }
            this._map.delete(language);
            this.fire([language]);
        });
    }
    registerFactory(languageId, factory) {
        var _a;
        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();
        const myData = new TokenizationSupportFactoryData(this, languageId, factory);
        this._factories.set(languageId, myData);
        return (0,_base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.toDisposable)(() => {
            const v = this._factories.get(languageId);
            if (!v || v !== myData) {
                return;
            }
            this._factories.delete(languageId);
            v.dispose();
        });
    }
    getOrCreate(languageId) {
        return __awaiter(this, void 0, void 0, function* () {
            // check first if the support is already set
            const tokenizationSupport = this.get(languageId);
            if (tokenizationSupport) {
                return tokenizationSupport;
            }
            const factory = this._factories.get(languageId);
            if (!factory || factory.isResolved) {
                // no factory or factory.resolve already finished
                return null;
            }
            yield factory.resolve();
            return this.get(languageId);
        });
    }
    get(language) {
        return (this._map.get(language) || null);
    }
    isResolved(languageId) {
        const tokenizationSupport = this.get(languageId);
        if (tokenizationSupport) {
            return true;
        }
        const factory = this._factories.get(languageId);
        if (!factory || factory.isResolved) {
            return true;
        }
        return false;
    }
    setColorMap(colorMap) {
        this._colorMap = colorMap;
        this._onDidChange.fire({
            changedLanguages: Array.from(this._map.keys()),
            changedColorMap: true
        });
    }
    getColorMap() {
        return this._colorMap;
    }
    getDefaultBackground() {
        if (this._colorMap && this._colorMap.length > 2 /* DefaultBackground */) {
            return this._colorMap[2 /* DefaultBackground */];
        }
        return null;
    }
}
class TokenizationSupportFactoryData extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    constructor(_registry, _languageId, _factory) {
        super();
        this._registry = _registry;
        this._languageId = _languageId;
        this._factory = _factory;
        this._isDisposed = false;
        this._resolvePromise = null;
        this._isResolved = false;
    }
    get isResolved() {
        return this._isResolved;
    }
    dispose() {
        this._isDisposed = true;
        super.dispose();
    }
    resolve() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._resolvePromise) {
                this._resolvePromise = this._create();
            }
            return this._resolvePromise;
        });
    }
    _create() {
        return __awaiter(this, void 0, void 0, function* () {
            const value = yield Promise.resolve(this._factory.createTokenizationSupport());
            this._isResolved = true;
            if (value && !this._isDisposed) {
                this._register(this._registry.register(this._languageId, value));
            }
        });
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js ***!
  \***************************************************************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initialize": () => (/* binding */ initialize)
/* harmony export */ });
/* harmony import */ var _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/common/worker/simpleWorker.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js");
/* harmony import */ var _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/services/editorSimpleWorker.js */ "../../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


let initialized = false;
function initialize(foreignModule) {
    if (initialized) {
        return;
    }
    initialized = true;
    const simpleWorker = new _base_common_worker_simpleWorker_js__WEBPACK_IMPORTED_MODULE_0__.SimpleWorkerServer((msg) => {
        self.postMessage(msg);
    }, (host) => new _common_services_editorSimpleWorker_js__WEBPACK_IMPORTED_MODULE_1__.EditorSimpleWorker(host, foreignModule));
    self.onmessage = (e) => {
        simpleWorker.onmessage(e.data);
    };
}
self.onmessage = (e) => {
    // Ignore first message in this case and initialize if not yet initialized
    if (!initialized) {
        initialize(null);
    }
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVELDRCQUE0QixvREFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRDQUE0QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2w0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFtRDtBQUN2RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7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QUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSjdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQkFBc0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFNBQVMsbUJBQW1CLFlBQVk7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ25YQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VDO0FBQ0U7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsdUVBQXVFLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFFBQVEscURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsb0RBQUk7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLGlEQUFnQjtBQUNuQyxpQkFBaUIsaURB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L0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTyxtREFBbUQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBDQUFJO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0IsMHdtQkFBMHdtQjtBQUNseW1CLENBQUM7QUFDRCxnQ0FBZ0Msd0RBQWlCO0FBQ2pEO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsMENBQUk7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzV5QkE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCLEdBQUcsZUFBZSxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCLEdBQUcsZUFBZSxHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUN4QjtBQUNPO0FBQ0c7QUFDWDtBQUNJO0FBQ3pDO0FBQ0E7QUFDTztBQUNQLFNBQVMsK0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ047QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsNENBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDtBQUN4RCxzQ0FBc0Msd0VBQW1CO0FBQ2hFO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QlA7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnREFBZ0QsRUFBRSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSSxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUNEO0FBQzNEO0FBQ0E7QUFDQSx5QkFBeUIsOERBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0o7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0RUFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyRUFBOEI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRTtBQUMzRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3REO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUNsQztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDeEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7Ozs7O1VDdklBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDRTtBQUM3RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWtCO0FBQy9DO0FBQ0EsS0FBSyxnQkFBZ0Isc0ZBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hcnJheXMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jYWNoZS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2NvZGljb25zLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmQ2hhbmdlLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXJyb3JzLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9mdW5jdGlvbmFsLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaGFzaC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24va2V5Q29kZXMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9sYXp5LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL29iamVjdHMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wYXRoLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wcm9jZXNzLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3R5cGVzLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdWludC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VyaS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvY2hhcmFjdGVyQ2xhc3NpZmllci5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9yYW5nZS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9zZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvd29yZENoYXJhY3RlckNsYXNzaWZpZXIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvd29yZEhlbHBlci5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kaWZmQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL2xpbmtDb21wdXRlci5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL3N1cHBvcnRzL2lucGxhY2VSZXBsYWNlU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvcHJlZml4U3VtQ29tcHV0ZXIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3RleHRNb2RlbFNlYXJjaC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yQmFzZUFwaS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbW9uYWNvLWVkaXRvckAwLjMzLjAvbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yU2ltcGxlV29ya2VyLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3N0YW5kYWxvbmUvc3RhbmRhbG9uZUVudW1zLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94Ly4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tb25hY28tZWRpdG9yQDAuMzMuMC9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi90b2tlbml6YXRpb25SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtc2FuZGJveC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy1zYW5kYm94L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXNhbmRib3gvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21vbmFjby1lZGl0b3JAMC4zMy4wL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvZWRpdG9yLndvcmtlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXG4gKiBAcGFyYW0gbiBXaGljaCBlbGVtZW50IGZyb20gdGhlIGVuZCAoZGVmYXVsdCBpcyB6ZXJvKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhaWwoYXJyYXksIG4gPSAwKSB7XG4gICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtICgxICsgbildO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRhaWwyKGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWlsIGNhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIFthcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIDEpLCBhcnJbYXJyLmxlbmd0aCAtIDFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlciwgaXRlbUVxdWFscyA9IChhLCBiKSA9PiBhID09PSBiKSB7XG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb25lIHx8ICFvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb25lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghaXRlbUVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwga2V5LCBjb21wYXJhdG9yKSB7XG4gICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSAoKGxvdyArIGhpZ2gpIC8gMikgfCAwO1xuICAgICAgICBjb25zdCBjb21wID0gY29tcGFyYXRvcihhcnJheVttaWRdLCBrZXkpO1xuICAgICAgICBpZiAoY29tcCA8IDApIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA+IDApIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLShsb3cgKyAxKTtcbn1cbi8qKlxuICogVGFrZXMgYSBzb3J0ZWQgYXJyYXkgYW5kIGEgZnVuY3Rpb24gcC4gVGhlIGFycmF5IGlzIHNvcnRlZCBpbiBzdWNoIGEgd2F5IHRoYXQgYWxsIGVsZW1lbnRzIHdoZXJlIHAoeCkgaXMgZmFsc2VcbiAqIGFyZSBsb2NhdGVkIGJlZm9yZSBhbGwgZWxlbWVudHMgd2hlcmUgcCh4KSBpcyB0cnVlLlxuICogQHJldHVybnMgdGhlIGxlYXN0IHggZm9yIHdoaWNoIHAoeCkgaXMgdHJ1ZSBvciBhcnJheS5sZW5ndGggaWYgbm8gZWxlbWVudCBmdWxsZmlsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0SW5Tb3J0ZWQoYXJyYXksIHApIHtcbiAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDsgLy8gbm8gY2hpbGRyZW5cbiAgICB9XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgaWYgKHAoYXJyYXlbbWlkXSkpIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG59XG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTZWxlY3QobnRoLCBkYXRhLCBjb21wYXJlKSB7XG4gICAgbnRoID0gbnRoIHwgMDtcbiAgICBpZiAobnRoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW5kZXgnKTtcbiAgICB9XG4gICAgbGV0IHBpdm90VmFsdWUgPSBkYXRhW01hdGguZmxvb3IoZGF0YS5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV07XG4gICAgbGV0IGxvd2VyID0gW107XG4gICAgbGV0IGhpZ2hlciA9IFtdO1xuICAgIGxldCBwaXZvdHMgPSBbXTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGNvbXBhcmUodmFsdWUsIHBpdm90VmFsdWUpO1xuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgbG93ZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgaGlnaGVyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGl2b3RzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChudGggPCBsb3dlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHF1aWNrU2VsZWN0KG50aCwgbG93ZXIsIGNvbXBhcmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChudGggPCBsb3dlci5sZW5ndGggKyBwaXZvdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwaXZvdHNbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcXVpY2tTZWxlY3QobnRoIC0gKGxvd2VyLmxlbmd0aCArIHBpdm90cy5sZW5ndGgpLCBoaWdoZXIsIGNvbXBhcmUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5KGRhdGEsIGNvbXBhcmUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgY3VycmVudEdyb3VwID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkYXRhLnNsaWNlKDApLnNvcnQoY29tcGFyZSkpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50R3JvdXAgfHwgY29tcGFyZShjdXJyZW50R3JvdXBbMF0sIGVsZW1lbnQpICE9PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBbZWxlbWVudF07XG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHJldHVybnMgTmV3IGFycmF5IHdpdGggYWxsIGZhbHN5IHZhbHVlcyByZW1vdmVkLiBUaGUgb3JpZ2luYWwgYXJyYXkgSVMgTk9UIG1vZGlmaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29hbGVzY2UoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGUgPT4gISFlKTtcbn1cbi8qKlxuICogQHJldHVybnMgZmFsc2UgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhbiBhcnJheSBhbmQgbm90IGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGYWxzeU9yRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KG9iaikgfHwgb2JqLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gdGhlIGdpdmVuIGFycmF5LiBUaGUgb3B0aW9uYWwga2V5Rm4gYWxsb3dzIHRvIHNwZWNpZnlcbiAqIGhvdyBlbGVtZW50cyBhcmUgY2hlY2tlZCBmb3IgZXF1YWxpdHkgYnkgcmV0dXJuaW5nIGFuIGFsdGVybmF0ZSB2YWx1ZSBmb3IgZWFjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0KGFycmF5LCBrZXlGbiA9IHZhbHVlID0+IHZhbHVlKSB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlGbihlbGVtZW50KTtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGFzdChhcnIsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IGlkeCA9IGxhc3RJbmRleChhcnIsIHByZWRpY2F0ZSk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFycltpZHhdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RJbmRleChhcnJheSwgZm4pIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoZm4oZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdE9yRGVmYXVsdChhcnJheSwgbm90Rm91bmRWYWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbMF0gOiBub3RGb3VuZFZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5hcnIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKGFyZywgdG8pIHtcbiAgICBsZXQgZnJvbSA9IHR5cGVvZiB0byA9PT0gJ251bWJlcicgPyBhcmcgOiAwO1xuICAgIGlmICh0eXBlb2YgdG8gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgdG8gPSBhcmc7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChmcm9tIDw9IHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpID4gdG87IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zZXJ0IGBpbnNlcnRBcnJgIGluc2lkZSBgdGFyZ2V0YCBhdCBgaW5zZXJ0SW5kZXhgLlxuICogUGxlYXNlIGRvbid0IHRvdWNoIHVubGVzcyB5b3UgdW5kZXJzdGFuZCBodHRwczovL2pzcGVyZi5jb20vaW5zZXJ0aW5nLWFuLWFycmF5LXdpdGhpbi1hbi1hcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlJbnNlcnQodGFyZ2V0LCBpbnNlcnRJbmRleCwgaW5zZXJ0QXJyKSB7XG4gICAgY29uc3QgYmVmb3JlID0gdGFyZ2V0LnNsaWNlKDAsIGluc2VydEluZGV4KTtcbiAgICBjb25zdCBhZnRlciA9IHRhcmdldC5zbGljZShpbnNlcnRJbmRleCk7XG4gICAgcmV0dXJuIGJlZm9yZS5jb25jYXQoaW5zZXJ0QXJyLCBhZnRlcik7XG59XG4vKipcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBzdGFydCBvZiB0aGUgYXJyYXksIGlmIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRvU3RhcnQoYXJyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBhcnIudW5zaGlmdCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBQdXNoZXMgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSwgaWYgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoVG9FbmQoYXJyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XTtcbn1cbi8qKlxuICogSW5zZXJ0IHRoZSBuZXcgaXRlbXMgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIGFycmF5IFRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcgZWxlbWVudHMuXG4gKiBAcGFyYW0gbmV3SXRlbXMgVGhlIGl0ZW1zIHRvIGJlIGluc2VydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRJbnRvKGFycmF5LCBzdGFydCwgbmV3SXRlbXMpIHtcbiAgICBjb25zdCBzdGFydElkeCA9IGdldEFjdHVhbFN0YXJ0SW5kZXgoYXJyYXksIHN0YXJ0KTtcbiAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCBuZXdJdGVtc0xlbmd0aCA9IG5ld0l0ZW1zLmxlbmd0aDtcbiAgICBhcnJheS5sZW5ndGggPSBvcmlnaW5hbExlbmd0aCArIG5ld0l0ZW1zTGVuZ3RoO1xuICAgIC8vIE1vdmUgdGhlIGl0ZW1zIGFmdGVyIHRoZSBzdGFydCBpbmRleCwgc3RhcnQgZnJvbSB0aGUgZW5kIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGFueSB2YWx1ZS5cbiAgICBmb3IgKGxldCBpID0gb3JpZ2luYWxMZW5ndGggLSAxOyBpID49IHN0YXJ0SWR4OyBpLS0pIHtcbiAgICAgICAgYXJyYXlbaSArIG5ld0l0ZW1zTGVuZ3RoXSA9IGFycmF5W2ldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0l0ZW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSArIHN0YXJ0SWR4XSA9IG5ld0l0ZW1zW2ldO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGFuZCBpbnNlcnRzIG5ldyBlbGVtZW50cyBpbiB0aGVpciBwbGFjZSwgcmV0dXJuaW5nIHRoZSBkZWxldGVkIGVsZW1lbnRzLiBBbHRlcm5hdGl2ZSB0byB0aGUgbmF0aXZlIEFycmF5LnNwbGljZSBtZXRob2QsIGl0XG4gKiBjYW4gb25seSBzdXBwb3J0IGxpbWl0ZWQgbnVtYmVyIG9mIGl0ZW1zIGR1ZSB0byB0aGUgbWF4aW11bSBjYWxsIHN0YWNrIHNpemUgbGltaXQuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIHN0YXJ0IFRoZSB6ZXJvLWJhc2VkIGxvY2F0aW9uIGluIHRoZSBhcnJheSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzLlxuICogQHBhcmFtIGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZWxlbWVudHMgdGhhdCB3ZXJlIGRlbGV0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpY2UoYXJyYXksIHN0YXJ0LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldEFjdHVhbFN0YXJ0SW5kZXgoYXJyYXksIHN0YXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSBhcnJheS5zcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KTtcbiAgICBpbnNlcnRJbnRvKGFycmF5LCBpbmRleCwgbmV3SXRlbXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgYWN0dWFsIHN0YXJ0IGluZGV4IChzYW1lIGxvZ2ljIGFzIHRoZSBuYXRpdmUgc3BsaWNlKCkgb3Igc2xpY2UoKSlcbiAqIElmIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSwgc3RhcnQgd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIEluIHRoaXMgY2FzZSwgbm8gZWxlbWVudCB3aWxsIGJlIGRlbGV0ZWQgYnV0IHRoZSBtZXRob2Qgd2lsbCBiZWhhdmUgYXMgYW4gYWRkaW5nIGZ1bmN0aW9uLCBhZGRpbmcgYXMgbWFueSBlbGVtZW50IGFzIGl0ZW1bbipdIHByb3ZpZGVkLlxuICogSWYgbmVnYXRpdmUsIGl0IHdpbGwgYmVnaW4gdGhhdCBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuIChJbiB0aGlzIGNhc2UsIHRoZSBvcmlnaW4gLTEsIG1lYW5pbmcgLW4gaXMgdGhlIGluZGV4IG9mIHRoZSBudGggbGFzdCBlbGVtZW50LCBhbmQgaXMgdGhlcmVmb3JlIGVxdWl2YWxlbnQgdG8gdGhlIGluZGV4IG9mIGFycmF5Lmxlbmd0aCAtIG4uKSBJZiBhcnJheS5sZW5ndGggKyBzdGFydCBpcyBsZXNzIHRoYW4gMCwgaXQgd2lsbCBiZWdpbiBmcm9tIGluZGV4IDAuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIHRhcmdldCBhcnJheS5cbiAqIEBwYXJhbSBzdGFydCBUaGUgb3BlcmF0aW9uIGluZGV4LlxuICovXG5mdW5jdGlvbiBnZXRBY3R1YWxTdGFydEluZGV4KGFycmF5LCBzdGFydCkge1xuICAgIHJldHVybiBzdGFydCA8IDAgPyBNYXRoLm1heChzdGFydCArIGFycmF5Lmxlbmd0aCwgMCkgOiBNYXRoLm1pbihzdGFydCwgYXJyYXkubGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnkoc2VsZWN0b3IsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGNvbXBhcmF0b3Ioc2VsZWN0b3IoYSksIHNlbGVjdG9yKGIpKTtcbn1cbi8qKlxuICogVGhlIG5hdHVyYWwgb3JkZXIgb24gbnVtYmVycy5cbiovXG5leHBvcnQgY29uc3QgbnVtYmVyQ29tcGFyYXRvciA9IChhLCBiKSA9PiBhIC0gYjtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBldmVyeSBvdGhlciBpdGVtLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF4QnkoaXRlbXMsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBtYXggPSBpdGVtc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+IDApIHtcbiAgICAgICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIGV2ZXJ5IG90aGVyIGl0ZW0uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0TWF4QnkoaXRlbXMsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBtYXggPSBpdGVtc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+PSAwKSB7XG4gICAgICAgICAgICBtYXggPSBpdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhhdCBpcyBlcXVhbCB0byBvciBsZXNzIHRoYW4gZXZlcnkgb3RoZXIgaXRlbS5cbiovXG5leHBvcnQgZnVuY3Rpb24gZmluZE1pbkJ5KGl0ZW1zLCBjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGZpbmRNYXhCeShpdGVtcywgKGEsIGIpID0+IC1jb21wYXJhdG9yKGEsIGIpKTtcbn1cbmV4cG9ydCBjbGFzcyBBcnJheVF1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgcXVldWUgdGhhdCBpcyBiYWNrZWQgYnkgdGhlIGdpdmVuIGFycmF5LiBSdW50aW1lIGlzIE8oMSkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZmlyc3RJZHggPSAwO1xuICAgICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgcXVldWUgYXMgbG9uZyBhcyB0aGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBJZiBubyBlbGVtZW50cyB3ZXJlIGNvbnN1bWVkLCBgbnVsbGAgaXMgcmV0dXJuZWQuIEhhcyBhIHJ1bnRpbWUgb2YgTyhyZXN1bHQubGVuZ3RoKS5cbiAgICAqL1xuICAgIHRha2VXaGlsZShwcmVkaWNhdGUpIHtcbiAgICAgICAgLy8gUChrKSA6PSBrIDw9IHRoaXMubGFzdElkeCAmJiBwcmVkaWNhdGUodGhpcy5pdGVtc1trXSlcbiAgICAgICAgLy8gRmluZCBzIDo9IG1pbiB7IGsgfCBrID49IHRoaXMuZmlyc3RJZHggJiYgIVAoaykgfSBhbmQgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmZpcnN0SWR4Li4ucylcbiAgICAgICAgbGV0IHN0YXJ0SWR4ID0gdGhpcy5maXJzdElkeDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0SWR4IDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgc3RhcnRJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdGFydElkeCA9PT0gdGhpcy5maXJzdElkeCA/IG51bGwgOiB0aGlzLml0ZW1zLnNsaWNlKHRoaXMuZmlyc3RJZHgsIHN0YXJ0SWR4KTtcbiAgICAgICAgdGhpcy5maXJzdElkeCA9IHN0YXJ0SWR4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIGFzIGxvbmcgYXMgdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXG4gICAgICogSWYgbm8gZWxlbWVudHMgd2VyZSBjb25zdW1lZCwgYG51bGxgIGlzIHJldHVybmVkLlxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1bmRlcmx5aW5nIGFycmF5IVxuICAgICovXG4gICAgdGFrZUZyb21FbmRXaGlsZShwcmVkaWNhdGUpIHtcbiAgICAgICAgLy8gUChrKSA6PSB0aGlzLmZpcnN0SWR4ID49IGsgJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNba10pXG4gICAgICAgIC8vIEZpbmQgcyA6PSBtYXggeyBrIHwgayA8PSB0aGlzLmxhc3RJZHggJiYgIVAoaykgfSBhbmQgcmV0dXJuIHRoaXMuZGF0YShzLi4udGhpcy5sYXN0SWR4XVxuICAgICAgICBsZXQgZW5kSWR4ID0gdGhpcy5sYXN0SWR4O1xuICAgICAgICB3aGlsZSAoZW5kSWR4ID49IDAgJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNbZW5kSWR4XSkpIHtcbiAgICAgICAgICAgIGVuZElkeC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVuZElkeCA9PT0gdGhpcy5sYXN0SWR4ID8gbnVsbCA6IHRoaXMuaXRlbXMuc2xpY2UoZW5kSWR4ICsgMSwgdGhpcy5sYXN0SWR4ICsgMSk7XG4gICAgICAgIHRoaXMubGFzdElkeCA9IGVuZElkeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5maXJzdElkeF07XG4gICAgfVxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXRlbXNbdGhpcy5maXJzdElkeF07XG4gICAgICAgIHRoaXMuZmlyc3RJZHgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGFrZUNvdW50KGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaXRlbXMuc2xpY2UodGhpcy5maXJzdElkeCwgdGhpcy5maXJzdElkeCArIGNvdW50KTtcbiAgICAgICAgdGhpcy5maXJzdElkeCArPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCIvKipcbiAqIFVzZXMgYSBMUlUgY2FjaGUgdG8gbWFrZSBhIGdpdmVuIHBhcmFtZXRyaXplZCBmdW5jdGlvbiBjYWNoZWQuXG4gKiBDYWNoZXMganVzdCB0aGUgbGFzdCB2YWx1ZS5cbiAqIFRoZSBrZXkgbXVzdCBiZSBKU09OIHNlcmlhbGl6YWJsZS5cbiovXG5leHBvcnQgY2xhc3MgTFJVQ2FjaGVkQ29tcHV0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbXB1dGVGbikge1xuICAgICAgICB0aGlzLmNvbXB1dGVGbiA9IGNvbXB1dGVGbjtcbiAgICAgICAgdGhpcy5sYXN0Q2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdEFyZ0tleSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0KGFyZykge1xuICAgICAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICBpZiAodGhpcy5sYXN0QXJnS2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFyZ0tleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMubGFzdENhY2hlID0gdGhpcy5jb21wdXRlRm4oYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2FjaGU7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbWl0dGVyLCBFdmVudCB9IGZyb20gJy4vZXZlbnQuanMnO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBjbGVhclRpbWVvdXQoaGFuZGxlKTsgfSB9O1xufSk7XG5leHBvcnQgdmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uVG9rZW4odGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lIHx8IHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGluZy5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uVG9rZW4gPSBpc0NhbmNlbGxhdGlvblRva2VuO1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHNob3J0Y3V0RXZlbnRcbiAgICB9KTtcbn0pKENhbmNlbGxhdGlvblRva2VuIHx8IChDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XG5jbGFzcyBNdXRhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGFyZW50TGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gcGFyZW50ICYmIHBhcmVudC5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCh0aGlzLmNhbmNlbCwgdGhpcyk7XG4gICAgfVxuICAgIGdldCB0b2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNhbmNlbFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZShjYW5jZWwgPSBmYWxzZSkge1xuICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gU2VsZWN0cyBhbGwgY29kaWNvbiBuYW1lcyBlbmNhcHN1bGF0ZWQgaW4gdGhlIGAkKClgIHN5bnRheCBhbmQgd3JhcHMgdGhlXG4vLyByZXN1bHRzIHdpdGggc3BhY2VzIHNvIHRoYXQgc2NyZWVuIHJlYWRlcnMgY2FuIHJlYWQgdGhlIHRleHQgYmV0dGVyLlxuZXhwb3J0IGZ1bmN0aW9uIGdldENvZGljb25BcmlhTGFiZWwodGV4dCkge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcJFxcKCguKj8pXFwpL2csIChfbWF0Y2gsIGNvZGljb25OYW1lKSA9PiBgICR7Y29kaWNvbk5hbWV9IGApLnRyaW0oKTtcbn1cbi8qKlxuICogVGhlIENvZGljb24gbGlicmFyeSBpcyBhIHNldCBvZiBkZWZhdWx0IGljb25zIHRoYXQgYXJlIGJ1aWx0LWluIGluIFZTIENvZGUuXG4gKlxuICogSW4gdGhlIHByb2R1Y3QgKG91dHNpZGUgb2YgYmFzZSkgQ29kaWNvbnMgc2hvdWxkIG9ubHkgYmUgdXNlZCBhcyBkZWZhdWx0cy4gSW4gb3JkZXIgdG8gaGF2ZSBhbGwgaWNvbnMgaW4gVlMgQ29kZVxuICogdGhlbWVhYmxlLCBjb21wb25lbnQgc2hvdWxkIGRlZmluZSBuZXcsIFVJIGNvbXBvbmVudCBzcGVjaWZpYyBpY29ucyB1c2luZyBgaWNvblJlZ2lzdHJ5LnJlZ2lzdGVySWNvbmAuXG4gKiBJbiB0aGF0IGNhbGwgYSBDb2RpY29uIGNhbiBiZSBuYW1lZCBhcyBkZWZhdWx0LlxuICovXG5leHBvcnQgY2xhc3MgQ29kaWNvbiB7XG4gICAgY29uc3RydWN0b3IoaWQsIGRlZmluaXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICBDb2RpY29uLl9hbGxDb2RpY29ucy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgY2xhc3NOYW1lcygpIHsgcmV0dXJuICdjb2RpY29uIGNvZGljb24tJyArIHRoaXMuaWQ7IH1cbiAgICAvLyBjbGFzc05hbWVzQXJyYXkgaXMgdXNlZnVsIGZvciBtaWdyYXRpbmcgdG8gRVM2IGNsYXNzbGlzdFxuICAgIGdldCBjbGFzc05hbWVzQXJyYXkoKSB7IHJldHVybiBbJ2NvZGljb24nLCAnY29kaWNvbi0nICsgdGhpcy5pZF07IH1cbiAgICBnZXQgY3NzU2VsZWN0b3IoKSB7IHJldHVybiAnLmNvZGljb24uY29kaWNvbi0nICsgdGhpcy5pZDsgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYWxsIGRlZmF1bHQgaWNvbnMgY292ZXJlZCBieSB0aGUgY29kaWNvbiBmb250LiBPbmx5IHRvIGJlIHVzZWQgYnkgdGhlIGljb24gcmVnaXN0cnkgaW4gcGxhdGZvcm0uXG4gICAgICovXG4gICAgc3RhdGljIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIENvZGljb24uX2FsbENvZGljb25zO1xuICAgIH1cbn1cbi8vIHJlZ2lzdHJ5XG5Db2RpY29uLl9hbGxDb2RpY29ucyA9IFtdO1xuLy8gYnVpbHQtaW4gaWNvbnMsIHdpdGggaW1hZ2UgbmFtZVxuQ29kaWNvbi5hZGQgPSBuZXcgQ29kaWNvbignYWRkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjAnIH0pO1xuQ29kaWNvbi5wbHVzID0gbmV3IENvZGljb24oJ3BsdXMnLCBDb2RpY29uLmFkZC5kZWZpbml0aW9uKTtcbkNvZGljb24uZ2lzdE5ldyA9IG5ldyBDb2RpY29uKCdnaXN0LW5ldycsIENvZGljb24uYWRkLmRlZmluaXRpb24pO1xuQ29kaWNvbi5yZXBvQ3JlYXRlID0gbmV3IENvZGljb24oJ3JlcG8tY3JlYXRlJywgQ29kaWNvbi5hZGQuZGVmaW5pdGlvbik7XG5Db2RpY29uLmxpZ2h0YnVsYiA9IG5ldyBDb2RpY29uKCdsaWdodGJ1bGInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2MScgfSk7XG5Db2RpY29uLmxpZ2h0QnVsYiA9IG5ldyBDb2RpY29uKCdsaWdodC1idWxiJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjEnIH0pO1xuQ29kaWNvbi5yZXBvID0gbmV3IENvZGljb24oJ3JlcG8nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2MicgfSk7XG5Db2RpY29uLnJlcG9EZWxldGUgPSBuZXcgQ29kaWNvbigncmVwby1kZWxldGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2MicgfSk7XG5Db2RpY29uLmdpc3RGb3JrID0gbmV3IENvZGljb24oJ2dpc3QtZm9yaycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTYzJyB9KTtcbkNvZGljb24ucmVwb0ZvcmtlZCA9IG5ldyBDb2RpY29uKCdyZXBvLWZvcmtlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTYzJyB9KTtcbkNvZGljb24uZ2l0UHVsbFJlcXVlc3QgPSBuZXcgQ29kaWNvbignZ2l0LXB1bGwtcmVxdWVzdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTY0JyB9KTtcbkNvZGljb24uZ2l0UHVsbFJlcXVlc3RBYmFuZG9uZWQgPSBuZXcgQ29kaWNvbignZ2l0LXB1bGwtcmVxdWVzdC1hYmFuZG9uZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2NCcgfSk7XG5Db2RpY29uLnJlY29yZEtleXMgPSBuZXcgQ29kaWNvbigncmVjb3JkLWtleXMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2NScgfSk7XG5Db2RpY29uLmtleWJvYXJkID0gbmV3IENvZGljb24oJ2tleWJvYXJkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjUnIH0pO1xuQ29kaWNvbi50YWcgPSBuZXcgQ29kaWNvbigndGFnJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjYnIH0pO1xuQ29kaWNvbi50YWdBZGQgPSBuZXcgQ29kaWNvbigndGFnLWFkZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTY2JyB9KTtcbkNvZGljb24udGFnUmVtb3ZlID0gbmV3IENvZGljb24oJ3RhZy1yZW1vdmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2NicgfSk7XG5Db2RpY29uLnBlcnNvbiA9IG5ldyBDb2RpY29uKCdwZXJzb24nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2NycgfSk7XG5Db2RpY29uLnBlcnNvbkZvbGxvdyA9IG5ldyBDb2RpY29uKCdwZXJzb24tZm9sbG93JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjcnIH0pO1xuQ29kaWNvbi5wZXJzb25PdXRsaW5lID0gbmV3IENvZGljb24oJ3BlcnNvbi1vdXRsaW5lJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjcnIH0pO1xuQ29kaWNvbi5wZXJzb25GaWxsZWQgPSBuZXcgQ29kaWNvbigncGVyc29uLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTY3JyB9KTtcbkNvZGljb24uZ2l0QnJhbmNoID0gbmV3IENvZGljb24oJ2dpdC1icmFuY2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE2OCcgfSk7XG5Db2RpY29uLmdpdEJyYW5jaENyZWF0ZSA9IG5ldyBDb2RpY29uKCdnaXQtYnJhbmNoLWNyZWF0ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTY4JyB9KTtcbkNvZGljb24uZ2l0QnJhbmNoRGVsZXRlID0gbmV3IENvZGljb24oJ2dpdC1icmFuY2gtZGVsZXRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjgnIH0pO1xuQ29kaWNvbi5zb3VyY2VDb250cm9sID0gbmV3IENvZGljb24oJ3NvdXJjZS1jb250cm9sJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjgnIH0pO1xuQ29kaWNvbi5taXJyb3IgPSBuZXcgQ29kaWNvbignbWlycm9yJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNjknIH0pO1xuQ29kaWNvbi5taXJyb3JQdWJsaWMgPSBuZXcgQ29kaWNvbignbWlycm9yLXB1YmxpYycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTY5JyB9KTtcbkNvZGljb24uc3RhciA9IG5ldyBDb2RpY29uKCdzdGFyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmEnIH0pO1xuQ29kaWNvbi5zdGFyQWRkID0gbmV3IENvZGljb24oJ3N0YXItYWRkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmEnIH0pO1xuQ29kaWNvbi5zdGFyRGVsZXRlID0gbmV3IENvZGljb24oJ3N0YXItZGVsZXRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmEnIH0pO1xuQ29kaWNvbi5zdGFyRW1wdHkgPSBuZXcgQ29kaWNvbignc3Rhci1lbXB0eScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTZhJyB9KTtcbkNvZGljb24uY29tbWVudCA9IG5ldyBDb2RpY29uKCdjb21tZW50JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmInIH0pO1xuQ29kaWNvbi5jb21tZW50QWRkID0gbmV3IENvZGljb24oJ2NvbW1lbnQtYWRkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmInIH0pO1xuQ29kaWNvbi5hbGVydCA9IG5ldyBDb2RpY29uKCdhbGVydCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTZjJyB9KTtcbkNvZGljb24ud2FybmluZyA9IG5ldyBDb2RpY29uKCd3YXJuaW5nJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmMnIH0pO1xuQ29kaWNvbi5zZWFyY2ggPSBuZXcgQ29kaWNvbignc2VhcmNoJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmQnIH0pO1xuQ29kaWNvbi5zZWFyY2hTYXZlID0gbmV3IENvZGljb24oJ3NlYXJjaC1zYXZlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmQnIH0pO1xuQ29kaWNvbi5sb2dPdXQgPSBuZXcgQ29kaWNvbignbG9nLW91dCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTZlJyB9KTtcbkNvZGljb24uc2lnbk91dCA9IG5ldyBDb2RpY29uKCdzaWduLW91dCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTZlJyB9KTtcbkNvZGljb24ubG9nSW4gPSBuZXcgQ29kaWNvbignbG9nLWluJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNmYnIH0pO1xuQ29kaWNvbi5zaWduSW4gPSBuZXcgQ29kaWNvbignc2lnbi1pbicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTZmJyB9KTtcbkNvZGljb24uZXllID0gbmV3IENvZGljb24oJ2V5ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTcwJyB9KTtcbkNvZGljb24uZXllVW53YXRjaCA9IG5ldyBDb2RpY29uKCdleWUtdW53YXRjaCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTcwJyB9KTtcbkNvZGljb24uZXllV2F0Y2ggPSBuZXcgQ29kaWNvbignZXllLXdhdGNoJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzAnIH0pO1xuQ29kaWNvbi5jaXJjbGVGaWxsZWQgPSBuZXcgQ29kaWNvbignY2lyY2xlLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTcxJyB9KTtcbkNvZGljb24ucHJpbWl0aXZlRG90ID0gbmV3IENvZGljb24oJ3ByaW1pdGl2ZS1kb3QnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3MScgfSk7XG5Db2RpY29uLmNsb3NlRGlydHkgPSBuZXcgQ29kaWNvbignY2xvc2UtZGlydHknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3MScgfSk7XG5Db2RpY29uLmRlYnVnQnJlYWtwb2ludCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzEnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnREaXNhYmxlZCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50LWRpc2FibGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzEnIH0pO1xuQ29kaWNvbi5kZWJ1Z0hpbnQgPSBuZXcgQ29kaWNvbignZGVidWctaGludCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTcxJyB9KTtcbkNvZGljb24ucHJpbWl0aXZlU3F1YXJlID0gbmV3IENvZGljb24oJ3ByaW1pdGl2ZS1zcXVhcmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3MicgfSk7XG5Db2RpY29uLmVkaXQgPSBuZXcgQ29kaWNvbignZWRpdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTczJyB9KTtcbkNvZGljb24ucGVuY2lsID0gbmV3IENvZGljb24oJ3BlbmNpbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTczJyB9KTtcbkNvZGljb24uaW5mbyA9IG5ldyBDb2RpY29uKCdpbmZvJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzQnIH0pO1xuQ29kaWNvbi5pc3N1ZU9wZW5lZCA9IG5ldyBDb2RpY29uKCdpc3N1ZS1vcGVuZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3NCcgfSk7XG5Db2RpY29uLmdpc3RQcml2YXRlID0gbmV3IENvZGljb24oJ2dpc3QtcHJpdmF0ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc1JyB9KTtcbkNvZGljb24uZ2l0Rm9ya1ByaXZhdGUgPSBuZXcgQ29kaWNvbignZ2l0LWZvcmstcHJpdmF0ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc1JyB9KTtcbkNvZGljb24ubG9jayA9IG5ldyBDb2RpY29uKCdsb2NrJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzUnIH0pO1xuQ29kaWNvbi5taXJyb3JQcml2YXRlID0gbmV3IENvZGljb24oJ21pcnJvci1wcml2YXRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzUnIH0pO1xuQ29kaWNvbi5jbG9zZSA9IG5ldyBDb2RpY29uKCdjbG9zZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc2JyB9KTtcbkNvZGljb24ucmVtb3ZlQ2xvc2UgPSBuZXcgQ29kaWNvbigncmVtb3ZlLWNsb3NlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzYnIH0pO1xuQ29kaWNvbi54ID0gbmV3IENvZGljb24oJ3gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3NicgfSk7XG5Db2RpY29uLnJlcG9TeW5jID0gbmV3IENvZGljb24oJ3JlcG8tc3luYycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc3JyB9KTtcbkNvZGljb24uc3luYyA9IG5ldyBDb2RpY29uKCdzeW5jJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhNzcnIH0pO1xuQ29kaWNvbi5jbG9uZSA9IG5ldyBDb2RpY29uKCdjbG9uZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc4JyB9KTtcbkNvZGljb24uZGVza3RvcERvd25sb2FkID0gbmV3IENvZGljb24oJ2Rlc2t0b3AtZG93bmxvYWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3OCcgfSk7XG5Db2RpY29uLmJlYWtlciA9IG5ldyBDb2RpY29uKCdiZWFrZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3OScgfSk7XG5Db2RpY29uLm1pY3Jvc2NvcGUgPSBuZXcgQ29kaWNvbignbWljcm9zY29wZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTc5JyB9KTtcbkNvZGljb24udm0gPSBuZXcgQ29kaWNvbigndm0nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3YScgfSk7XG5Db2RpY29uLmRldmljZURlc2t0b3AgPSBuZXcgQ29kaWNvbignZGV2aWNlLWRlc2t0b3AnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3YScgfSk7XG5Db2RpY29uLmZpbGUgPSBuZXcgQ29kaWNvbignZmlsZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdiJyB9KTtcbkNvZGljb24uZmlsZVRleHQgPSBuZXcgQ29kaWNvbignZmlsZS10ZXh0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhN2InIH0pO1xuQ29kaWNvbi5tb3JlID0gbmV3IENvZGljb24oJ21vcmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3YycgfSk7XG5Db2RpY29uLmVsbGlwc2lzID0gbmV3IENvZGljb24oJ2VsbGlwc2lzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhN2MnIH0pO1xuQ29kaWNvbi5rZWJhYkhvcml6b250YWwgPSBuZXcgQ29kaWNvbigna2ViYWItaG9yaXpvbnRhbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdjJyB9KTtcbkNvZGljb24ubWFpbFJlcGx5ID0gbmV3IENvZGljb24oJ21haWwtcmVwbHknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE3ZCcgfSk7XG5Db2RpY29uLnJlcGx5ID0gbmV3IENvZGljb24oJ3JlcGx5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhN2QnIH0pO1xuQ29kaWNvbi5vcmdhbml6YXRpb24gPSBuZXcgQ29kaWNvbignb3JnYW5pemF0aW9uJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhN2UnIH0pO1xuQ29kaWNvbi5vcmdhbml6YXRpb25GaWxsZWQgPSBuZXcgQ29kaWNvbignb3JnYW5pemF0aW9uLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdlJyB9KTtcbkNvZGljb24ub3JnYW5pemF0aW9uT3V0bGluZSA9IG5ldyBDb2RpY29uKCdvcmdhbml6YXRpb24tb3V0bGluZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdlJyB9KTtcbkNvZGljb24ubmV3RmlsZSA9IG5ldyBDb2RpY29uKCduZXctZmlsZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdmJyB9KTtcbkNvZGljb24uZmlsZUFkZCA9IG5ldyBDb2RpY29uKCdmaWxlLWFkZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTdmJyB9KTtcbkNvZGljb24ubmV3Rm9sZGVyID0gbmV3IENvZGljb24oJ25ldy1mb2xkZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4MCcgfSk7XG5Db2RpY29uLmZpbGVEaXJlY3RvcnlDcmVhdGUgPSBuZXcgQ29kaWNvbignZmlsZS1kaXJlY3RvcnktY3JlYXRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODAnIH0pO1xuQ29kaWNvbi50cmFzaCA9IG5ldyBDb2RpY29uKCd0cmFzaCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTgxJyB9KTtcbkNvZGljb24udHJhc2hjYW4gPSBuZXcgQ29kaWNvbigndHJhc2hjYW4nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4MScgfSk7XG5Db2RpY29uLmhpc3RvcnkgPSBuZXcgQ29kaWNvbignaGlzdG9yeScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTgyJyB9KTtcbkNvZGljb24uY2xvY2sgPSBuZXcgQ29kaWNvbignY2xvY2snLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4MicgfSk7XG5Db2RpY29uLmZvbGRlciA9IG5ldyBDb2RpY29uKCdmb2xkZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4MycgfSk7XG5Db2RpY29uLmZpbGVEaXJlY3RvcnkgPSBuZXcgQ29kaWNvbignZmlsZS1kaXJlY3RvcnknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4MycgfSk7XG5Db2RpY29uLnN5bWJvbEZvbGRlciA9IG5ldyBDb2RpY29uKCdzeW1ib2wtZm9sZGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODMnIH0pO1xuQ29kaWNvbi5sb2dvR2l0aHViID0gbmV3IENvZGljb24oJ2xvZ28tZ2l0aHViJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODQnIH0pO1xuQ29kaWNvbi5tYXJrR2l0aHViID0gbmV3IENvZGljb24oJ21hcmstZ2l0aHViJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODQnIH0pO1xuQ29kaWNvbi5naXRodWIgPSBuZXcgQ29kaWNvbignZ2l0aHViJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODQnIH0pO1xuQ29kaWNvbi50ZXJtaW5hbCA9IG5ldyBDb2RpY29uKCd0ZXJtaW5hbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTg1JyB9KTtcbkNvZGljb24uY29uc29sZSA9IG5ldyBDb2RpY29uKCdjb25zb2xlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhODUnIH0pO1xuQ29kaWNvbi5yZXBsID0gbmV3IENvZGljb24oJ3JlcGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4NScgfSk7XG5Db2RpY29uLnphcCA9IG5ldyBDb2RpY29uKCd6YXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4NicgfSk7XG5Db2RpY29uLnN5bWJvbEV2ZW50ID0gbmV3IENvZGljb24oJ3N5bWJvbC1ldmVudCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTg2JyB9KTtcbkNvZGljb24uZXJyb3IgPSBuZXcgQ29kaWNvbignZXJyb3InLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4NycgfSk7XG5Db2RpY29uLnN0b3AgPSBuZXcgQ29kaWNvbignc3RvcCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTg3JyB9KTtcbkNvZGljb24udmFyaWFibGUgPSBuZXcgQ29kaWNvbigndmFyaWFibGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4OCcgfSk7XG5Db2RpY29uLnN5bWJvbFZhcmlhYmxlID0gbmV3IENvZGljb24oJ3N5bWJvbC12YXJpYWJsZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTg4JyB9KTtcbkNvZGljb24uYXJyYXkgPSBuZXcgQ29kaWNvbignYXJyYXknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4YScgfSk7XG5Db2RpY29uLnN5bWJvbEFycmF5ID0gbmV3IENvZGljb24oJ3N5bWJvbC1hcnJheScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYThhJyB9KTtcbkNvZGljb24uc3ltYm9sTW9kdWxlID0gbmV3IENvZGljb24oJ3N5bWJvbC1tb2R1bGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4YicgfSk7XG5Db2RpY29uLnN5bWJvbFBhY2thZ2UgPSBuZXcgQ29kaWNvbignc3ltYm9sLXBhY2thZ2UnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4YicgfSk7XG5Db2RpY29uLnN5bWJvbE5hbWVzcGFjZSA9IG5ldyBDb2RpY29uKCdzeW1ib2wtbmFtZXNwYWNlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOGInIH0pO1xuQ29kaWNvbi5zeW1ib2xPYmplY3QgPSBuZXcgQ29kaWNvbignc3ltYm9sLW9iamVjdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYThiJyB9KTtcbkNvZGljb24uc3ltYm9sTWV0aG9kID0gbmV3IENvZGljb24oJ3N5bWJvbC1tZXRob2QnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE4YycgfSk7XG5Db2RpY29uLnN5bWJvbEZ1bmN0aW9uID0gbmV3IENvZGljb24oJ3N5bWJvbC1mdW5jdGlvbicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYThjJyB9KTtcbkNvZGljb24uc3ltYm9sQ29uc3RydWN0b3IgPSBuZXcgQ29kaWNvbignc3ltYm9sLWNvbnN0cnVjdG9yJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOGMnIH0pO1xuQ29kaWNvbi5zeW1ib2xCb29sZWFuID0gbmV3IENvZGljb24oJ3N5bWJvbC1ib29sZWFuJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOGYnIH0pO1xuQ29kaWNvbi5zeW1ib2xOdWxsID0gbmV3IENvZGljb24oJ3N5bWJvbC1udWxsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOGYnIH0pO1xuQ29kaWNvbi5zeW1ib2xOdW1lcmljID0gbmV3IENvZGljb24oJ3N5bWJvbC1udW1lcmljJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOTAnIH0pO1xuQ29kaWNvbi5zeW1ib2xOdW1iZXIgPSBuZXcgQ29kaWNvbignc3ltYm9sLW51bWJlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTkwJyB9KTtcbkNvZGljb24uc3ltYm9sU3RydWN0dXJlID0gbmV3IENvZGljb24oJ3N5bWJvbC1zdHJ1Y3R1cmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5MScgfSk7XG5Db2RpY29uLnN5bWJvbFN0cnVjdCA9IG5ldyBDb2RpY29uKCdzeW1ib2wtc3RydWN0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOTEnIH0pO1xuQ29kaWNvbi5zeW1ib2xQYXJhbWV0ZXIgPSBuZXcgQ29kaWNvbignc3ltYm9sLXBhcmFtZXRlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTkyJyB9KTtcbkNvZGljb24uc3ltYm9sVHlwZVBhcmFtZXRlciA9IG5ldyBDb2RpY29uKCdzeW1ib2wtdHlwZS1wYXJhbWV0ZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5MicgfSk7XG5Db2RpY29uLnN5bWJvbEtleSA9IG5ldyBDb2RpY29uKCdzeW1ib2wta2V5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOTMnIH0pO1xuQ29kaWNvbi5zeW1ib2xUZXh0ID0gbmV3IENvZGljb24oJ3N5bWJvbC10ZXh0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOTMnIH0pO1xuQ29kaWNvbi5zeW1ib2xSZWZlcmVuY2UgPSBuZXcgQ29kaWNvbignc3ltYm9sLXJlZmVyZW5jZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTk0JyB9KTtcbkNvZGljb24uZ29Ub0ZpbGUgPSBuZXcgQ29kaWNvbignZ28tdG8tZmlsZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTk0JyB9KTtcbkNvZGljb24uc3ltYm9sRW51bSA9IG5ldyBDb2RpY29uKCdzeW1ib2wtZW51bScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTk1JyB9KTtcbkNvZGljb24uc3ltYm9sVmFsdWUgPSBuZXcgQ29kaWNvbignc3ltYm9sLXZhbHVlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOTUnIH0pO1xuQ29kaWNvbi5zeW1ib2xSdWxlciA9IG5ldyBDb2RpY29uKCdzeW1ib2wtcnVsZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5NicgfSk7XG5Db2RpY29uLnN5bWJvbFVuaXQgPSBuZXcgQ29kaWNvbignc3ltYm9sLXVuaXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5NicgfSk7XG5Db2RpY29uLmFjdGl2YXRlQnJlYWtwb2ludHMgPSBuZXcgQ29kaWNvbignYWN0aXZhdGUtYnJlYWtwb2ludHMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5NycgfSk7XG5Db2RpY29uLmFyY2hpdmUgPSBuZXcgQ29kaWNvbignYXJjaGl2ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTk4JyB9KTtcbkNvZGljb24uYXJyb3dCb3RoID0gbmV3IENvZGljb24oJ2Fycm93LWJvdGgnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWE5OScgfSk7XG5Db2RpY29uLmFycm93RG93biA9IG5ldyBDb2RpY29uKCdhcnJvdy1kb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOWEnIH0pO1xuQ29kaWNvbi5hcnJvd0xlZnQgPSBuZXcgQ29kaWNvbignYXJyb3ctbGVmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTliJyB9KTtcbkNvZGljb24uYXJyb3dSaWdodCA9IG5ldyBDb2RpY29uKCdhcnJvdy1yaWdodCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTljJyB9KTtcbkNvZGljb24uYXJyb3dTbWFsbERvd24gPSBuZXcgQ29kaWNvbignYXJyb3ctc21hbGwtZG93bicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTlkJyB9KTtcbkNvZGljb24uYXJyb3dTbWFsbExlZnQgPSBuZXcgQ29kaWNvbignYXJyb3ctc21hbGwtbGVmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYTllJyB9KTtcbkNvZGljb24uYXJyb3dTbWFsbFJpZ2h0ID0gbmV3IENvZGljb24oJ2Fycm93LXNtYWxsLXJpZ2h0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhOWYnIH0pO1xuQ29kaWNvbi5hcnJvd1NtYWxsVXAgPSBuZXcgQ29kaWNvbignYXJyb3ctc21hbGwtdXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhMCcgfSk7XG5Db2RpY29uLmFycm93VXAgPSBuZXcgQ29kaWNvbignYXJyb3ctdXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhMScgfSk7XG5Db2RpY29uLmJlbGwgPSBuZXcgQ29kaWNvbignYmVsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWEyJyB9KTtcbkNvZGljb24uYm9sZCA9IG5ldyBDb2RpY29uKCdib2xkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYTMnIH0pO1xuQ29kaWNvbi5ib29rID0gbmV3IENvZGljb24oJ2Jvb2snLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhNCcgfSk7XG5Db2RpY29uLmJvb2ttYXJrID0gbmV3IENvZGljb24oJ2Jvb2ttYXJrJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYTUnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbFVudmVyaWZpZWQgPSBuZXcgQ29kaWNvbignZGVidWctYnJlYWtwb2ludC1jb25kaXRpb25hbC11bnZlcmlmaWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYTYnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50LWNvbmRpdGlvbmFsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYTcnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbERpc2FibGVkID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwtZGlzYWJsZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhNycgfSk7XG5Db2RpY29uLmRlYnVnQnJlYWtwb2ludERhdGFVbnZlcmlmaWVkID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YS11bnZlcmlmaWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYTgnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnREYXRhID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWE5JyB9KTtcbkNvZGljb24uZGVidWdCcmVha3BvaW50RGF0YURpc2FibGVkID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YS1kaXNhYmxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWE5JyB9KTtcbkNvZGljb24uZGVidWdCcmVha3BvaW50TG9nVW52ZXJpZmllZCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50LWxvZy11bnZlcmlmaWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYWEnIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnRMb2cgPSBuZXcgQ29kaWNvbignZGVidWctYnJlYWtwb2ludC1sb2cnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhYicgfSk7XG5Db2RpY29uLmRlYnVnQnJlYWtwb2ludExvZ0Rpc2FibGVkID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtbG9nLWRpc2FibGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYWInIH0pO1xuQ29kaWNvbi5icmllZmNhc2UgPSBuZXcgQ29kaWNvbignYnJpZWZjYXNlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYWMnIH0pO1xuQ29kaWNvbi5icm9hZGNhc3QgPSBuZXcgQ29kaWNvbignYnJvYWRjYXN0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYWQnIH0pO1xuQ29kaWNvbi5icm93c2VyID0gbmV3IENvZGljb24oJ2Jyb3dzZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhZScgfSk7XG5Db2RpY29uLmJ1ZyA9IG5ldyBDb2RpY29uKCdidWcnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFhZicgfSk7XG5Db2RpY29uLmNhbGVuZGFyID0gbmV3IENvZGljb24oJ2NhbGVuZGFyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYjAnIH0pO1xuQ29kaWNvbi5jYXNlU2Vuc2l0aXZlID0gbmV3IENvZGljb24oJ2Nhc2Utc2Vuc2l0aXZlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYjEnIH0pO1xuQ29kaWNvbi5jaGVjayA9IG5ldyBDb2RpY29uKCdjaGVjaycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWIyJyB9KTtcbkNvZGljb24uY2hlY2tsaXN0ID0gbmV3IENvZGljb24oJ2NoZWNrbGlzdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWIzJyB9KTtcbkNvZGljb24uY2hldnJvbkRvd24gPSBuZXcgQ29kaWNvbignY2hldnJvbi1kb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYjQnIH0pO1xuQ29kaWNvbi5kcm9wRG93bkJ1dHRvbiA9IG5ldyBDb2RpY29uKCdkcm9wLWRvd24tYnV0dG9uJywgQ29kaWNvbi5jaGV2cm9uRG93bi5kZWZpbml0aW9uKTtcbkNvZGljb24uY2hldnJvbkxlZnQgPSBuZXcgQ29kaWNvbignY2hldnJvbi1sZWZ0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYjUnIH0pO1xuQ29kaWNvbi5jaGV2cm9uUmlnaHQgPSBuZXcgQ29kaWNvbignY2hldnJvbi1yaWdodCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWI2JyB9KTtcbkNvZGljb24uY2hldnJvblVwID0gbmV3IENvZGljb24oJ2NoZXZyb24tdXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiNycgfSk7XG5Db2RpY29uLmNocm9tZUNsb3NlID0gbmV3IENvZGljb24oJ2Nocm9tZS1jbG9zZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWI4JyB9KTtcbkNvZGljb24uY2hyb21lTWF4aW1pemUgPSBuZXcgQ29kaWNvbignY2hyb21lLW1heGltaXplJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYjknIH0pO1xuQ29kaWNvbi5jaHJvbWVNaW5pbWl6ZSA9IG5ldyBDb2RpY29uKCdjaHJvbWUtbWluaW1pemUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiYScgfSk7XG5Db2RpY29uLmNocm9tZVJlc3RvcmUgPSBuZXcgQ29kaWNvbignY2hyb21lLXJlc3RvcmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiYicgfSk7XG5Db2RpY29uLmNpcmNsZU91dGxpbmUgPSBuZXcgQ29kaWNvbignY2lyY2xlLW91dGxpbmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiYycgfSk7XG5Db2RpY29uLmRlYnVnQnJlYWtwb2ludFVudmVyaWZpZWQgPSBuZXcgQ29kaWNvbignZGVidWctYnJlYWtwb2ludC11bnZlcmlmaWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYmMnIH0pO1xuQ29kaWNvbi5jaXJjbGVTbGFzaCA9IG5ldyBDb2RpY29uKCdjaXJjbGUtc2xhc2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiZCcgfSk7XG5Db2RpY29uLmNpcmN1aXRCb2FyZCA9IG5ldyBDb2RpY29uKCdjaXJjdWl0LWJvYXJkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYmUnIH0pO1xuQ29kaWNvbi5jbGVhckFsbCA9IG5ldyBDb2RpY29uKCdjbGVhci1hbGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFiZicgfSk7XG5Db2RpY29uLmNsaXBweSA9IG5ldyBDb2RpY29uKCdjbGlwcHknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFjMCcgfSk7XG5Db2RpY29uLmNsb3NlQWxsID0gbmV3IENvZGljb24oJ2Nsb3NlLWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWMxJyB9KTtcbkNvZGljb24uY2xvdWREb3dubG9hZCA9IG5ldyBDb2RpY29uKCdjbG91ZC1kb3dubG9hZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWMyJyB9KTtcbkNvZGljb24uY2xvdWRVcGxvYWQgPSBuZXcgQ29kaWNvbignY2xvdWQtdXBsb2FkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYzMnIH0pO1xuQ29kaWNvbi5jb2RlID0gbmV3IENvZGljb24oJ2NvZGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFjNCcgfSk7XG5Db2RpY29uLmNvbGxhcHNlQWxsID0gbmV3IENvZGljb24oJ2NvbGxhcHNlLWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWM1JyB9KTtcbkNvZGljb24uY29sb3JNb2RlID0gbmV3IENvZGljb24oJ2NvbG9yLW1vZGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFjNicgfSk7XG5Db2RpY29uLmNvbW1lbnREaXNjdXNzaW9uID0gbmV3IENvZGljb24oJ2NvbW1lbnQtZGlzY3Vzc2lvbicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWM3JyB9KTtcbkNvZGljb24uY29tcGFyZUNoYW5nZXMgPSBuZXcgQ29kaWNvbignY29tcGFyZS1jaGFuZ2VzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZmQnIH0pO1xuQ29kaWNvbi5jcmVkaXRDYXJkID0gbmV3IENvZGljb24oJ2NyZWRpdC1jYXJkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhYzknIH0pO1xuQ29kaWNvbi5kYXNoID0gbmV3IENvZGljb24oJ2Rhc2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFjYycgfSk7XG5Db2RpY29uLmRhc2hib2FyZCA9IG5ldyBDb2RpY29uKCdkYXNoYm9hcmQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFjZCcgfSk7XG5Db2RpY29uLmRhdGFiYXNlID0gbmV3IENvZGljb24oJ2RhdGFiYXNlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhY2UnIH0pO1xuQ29kaWNvbi5kZWJ1Z0NvbnRpbnVlID0gbmV3IENvZGljb24oJ2RlYnVnLWNvbnRpbnVlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhY2YnIH0pO1xuQ29kaWNvbi5kZWJ1Z0Rpc2Nvbm5lY3QgPSBuZXcgQ29kaWNvbignZGVidWctZGlzY29ubmVjdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWQwJyB9KTtcbkNvZGljb24uZGVidWdQYXVzZSA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1wYXVzZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWQxJyB9KTtcbkNvZGljb24uZGVidWdSZXN0YXJ0ID0gbmV3IENvZGljb24oJ2RlYnVnLXJlc3RhcnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkMicgfSk7XG5Db2RpY29uLmRlYnVnU3RhcnQgPSBuZXcgQ29kaWNvbignZGVidWctc3RhcnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkMycgfSk7XG5Db2RpY29uLmRlYnVnU3RlcEludG8gPSBuZXcgQ29kaWNvbignZGVidWctc3RlcC1pbnRvJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZDQnIH0pO1xuQ29kaWNvbi5kZWJ1Z1N0ZXBPdXQgPSBuZXcgQ29kaWNvbignZGVidWctc3RlcC1vdXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkNScgfSk7XG5Db2RpY29uLmRlYnVnU3RlcE92ZXIgPSBuZXcgQ29kaWNvbignZGVidWctc3RlcC1vdmVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZDYnIH0pO1xuQ29kaWNvbi5kZWJ1Z1N0b3AgPSBuZXcgQ29kaWNvbignZGVidWctc3RvcCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWQ3JyB9KTtcbkNvZGljb24uZGVidWcgPSBuZXcgQ29kaWNvbignZGVidWcnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkOCcgfSk7XG5Db2RpY29uLmRldmljZUNhbWVyYVZpZGVvID0gbmV3IENvZGljb24oJ2RldmljZS1jYW1lcmEtdmlkZW8nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkOScgfSk7XG5Db2RpY29uLmRldmljZUNhbWVyYSA9IG5ldyBDb2RpY29uKCdkZXZpY2UtY2FtZXJhJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZGEnIH0pO1xuQ29kaWNvbi5kZXZpY2VNb2JpbGUgPSBuZXcgQ29kaWNvbignZGV2aWNlLW1vYmlsZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWRiJyB9KTtcbkNvZGljb24uZGlmZkFkZGVkID0gbmV3IENvZGljb24oJ2RpZmYtYWRkZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkYycgfSk7XG5Db2RpY29uLmRpZmZJZ25vcmVkID0gbmV3IENvZGljb24oJ2RpZmYtaWdub3JlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWRkJyB9KTtcbkNvZGljb24uZGlmZk1vZGlmaWVkID0gbmV3IENvZGljb24oJ2RpZmYtbW9kaWZpZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFkZScgfSk7XG5Db2RpY29uLmRpZmZSZW1vdmVkID0gbmV3IENvZGljb24oJ2RpZmYtcmVtb3ZlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWRmJyB9KTtcbkNvZGljb24uZGlmZlJlbmFtZWQgPSBuZXcgQ29kaWNvbignZGlmZi1yZW5hbWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZTAnIH0pO1xuQ29kaWNvbi5kaWZmID0gbmV3IENvZGljb24oJ2RpZmYnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlMScgfSk7XG5Db2RpY29uLmRpc2NhcmQgPSBuZXcgQ29kaWNvbignZGlzY2FyZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWUyJyB9KTtcbkNvZGljb24uZWRpdG9yTGF5b3V0ID0gbmV3IENvZGljb24oJ2VkaXRvci1sYXlvdXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlMycgfSk7XG5Db2RpY29uLmVtcHR5V2luZG93ID0gbmV3IENvZGljb24oJ2VtcHR5LXdpbmRvdycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWU0JyB9KTtcbkNvZGljb24uZXhjbHVkZSA9IG5ldyBDb2RpY29uKCdleGNsdWRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZTUnIH0pO1xuQ29kaWNvbi5leHRlbnNpb25zID0gbmV3IENvZGljb24oJ2V4dGVuc2lvbnMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlNicgfSk7XG5Db2RpY29uLmV5ZUNsb3NlZCA9IG5ldyBDb2RpY29uKCdleWUtY2xvc2VkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZTcnIH0pO1xuQ29kaWNvbi5maWxlQmluYXJ5ID0gbmV3IENvZGljb24oJ2ZpbGUtYmluYXJ5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZTgnIH0pO1xuQ29kaWNvbi5maWxlQ29kZSA9IG5ldyBDb2RpY29uKCdmaWxlLWNvZGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlOScgfSk7XG5Db2RpY29uLmZpbGVNZWRpYSA9IG5ldyBDb2RpY29uKCdmaWxlLW1lZGlhJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZWEnIH0pO1xuQ29kaWNvbi5maWxlUGRmID0gbmV3IENvZGljb24oJ2ZpbGUtcGRmJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZWInIH0pO1xuQ29kaWNvbi5maWxlU3VibW9kdWxlID0gbmV3IENvZGljb24oJ2ZpbGUtc3VibW9kdWxlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZWMnIH0pO1xuQ29kaWNvbi5maWxlU3ltbGlua0RpcmVjdG9yeSA9IG5ldyBDb2RpY29uKCdmaWxlLXN5bWxpbmstZGlyZWN0b3J5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZWQnIH0pO1xuQ29kaWNvbi5maWxlU3ltbGlua0ZpbGUgPSBuZXcgQ29kaWNvbignZmlsZS1zeW1saW5rLWZpbGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlZScgfSk7XG5Db2RpY29uLmZpbGVaaXAgPSBuZXcgQ29kaWNvbignZmlsZS16aXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFlZicgfSk7XG5Db2RpY29uLmZpbGVzID0gbmV3IENvZGljb24oJ2ZpbGVzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZjAnIH0pO1xuQ29kaWNvbi5maWx0ZXIgPSBuZXcgQ29kaWNvbignZmlsdGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZjEnIH0pO1xuQ29kaWNvbi5mbGFtZSA9IG5ldyBDb2RpY29uKCdmbGFtZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWYyJyB9KTtcbkNvZGljb24uZm9sZERvd24gPSBuZXcgQ29kaWNvbignZm9sZC1kb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZjMnIH0pO1xuQ29kaWNvbi5mb2xkVXAgPSBuZXcgQ29kaWNvbignZm9sZC11cCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWY0JyB9KTtcbkNvZGljb24uZm9sZCA9IG5ldyBDb2RpY29uKCdmb2xkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZjUnIH0pO1xuQ29kaWNvbi5mb2xkZXJBY3RpdmUgPSBuZXcgQ29kaWNvbignZm9sZGVyLWFjdGl2ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWY2JyB9KTtcbkNvZGljb24uZm9sZGVyT3BlbmVkID0gbmV3IENvZGljb24oJ2ZvbGRlci1vcGVuZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFmNycgfSk7XG5Db2RpY29uLmdlYXIgPSBuZXcgQ29kaWNvbignZ2VhcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYWY4JyB9KTtcbkNvZGljb24uZ2lmdCA9IG5ldyBDb2RpY29uKCdnaWZ0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZjknIH0pO1xuQ29kaWNvbi5naXN0U2VjcmV0ID0gbmV3IENvZGljb24oJ2dpc3Qtc2VjcmV0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZmEnIH0pO1xuQ29kaWNvbi5naXN0ID0gbmV3IENvZGljb24oJ2dpc3QnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFmYicgfSk7XG5Db2RpY29uLmdpdENvbW1pdCA9IG5ldyBDb2RpY29uKCdnaXQtY29tbWl0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZmMnIH0pO1xuQ29kaWNvbi5naXRDb21wYXJlID0gbmV3IENvZGljb24oJ2dpdC1jb21wYXJlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZmQnIH0pO1xuQ29kaWNvbi5naXRNZXJnZSA9IG5ldyBDb2RpY29uKCdnaXQtbWVyZ2UnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWFmZScgfSk7XG5Db2RpY29uLmdpdGh1YkFjdGlvbiA9IG5ldyBDb2RpY29uKCdnaXRodWItYWN0aW9uJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGVhZmYnIH0pO1xuQ29kaWNvbi5naXRodWJBbHQgPSBuZXcgQ29kaWNvbignZ2l0aHViLWFsdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjAwJyB9KTtcbkNvZGljb24uZ2xvYmUgPSBuZXcgQ29kaWNvbignZ2xvYmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIwMScgfSk7XG5Db2RpY29uLmdyYWJiZXIgPSBuZXcgQ29kaWNvbignZ3JhYmJlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjAyJyB9KTtcbkNvZGljb24uZ3JhcGggPSBuZXcgQ29kaWNvbignZ3JhcGgnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIwMycgfSk7XG5Db2RpY29uLmdyaXBwZXIgPSBuZXcgQ29kaWNvbignZ3JpcHBlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjA0JyB9KTtcbkNvZGljb24uaGVhcnQgPSBuZXcgQ29kaWNvbignaGVhcnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIwNScgfSk7XG5Db2RpY29uLmhvbWUgPSBuZXcgQ29kaWNvbignaG9tZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjA2JyB9KTtcbkNvZGljb24uaG9yaXpvbnRhbFJ1bGUgPSBuZXcgQ29kaWNvbignaG9yaXpvbnRhbC1ydWxlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMDcnIH0pO1xuQ29kaWNvbi5odWJvdCA9IG5ldyBDb2RpY29uKCdodWJvdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjA4JyB9KTtcbkNvZGljb24uaW5ib3ggPSBuZXcgQ29kaWNvbignaW5ib3gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIwOScgfSk7XG5Db2RpY29uLmlzc3VlQ2xvc2VkID0gbmV3IENvZGljb24oJ2lzc3VlLWNsb3NlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmE0JyB9KTtcbkNvZGljb24uaXNzdWVSZW9wZW5lZCA9IG5ldyBDb2RpY29uKCdpc3N1ZS1yZW9wZW5lZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjBiJyB9KTtcbkNvZGljb24uaXNzdWVzID0gbmV3IENvZGljb24oJ2lzc3VlcycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjBjJyB9KTtcbkNvZGljb24uaXRhbGljID0gbmV3IENvZGljb24oJ2l0YWxpYycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjBkJyB9KTtcbkNvZGljb24uamVyc2V5ID0gbmV3IENvZGljb24oJ2plcnNleScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjBlJyB9KTtcbkNvZGljb24uanNvbiA9IG5ldyBDb2RpY29uKCdqc29uJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMGYnIH0pO1xuQ29kaWNvbi5rZWJhYlZlcnRpY2FsID0gbmV3IENvZGljb24oJ2tlYmFiLXZlcnRpY2FsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTAnIH0pO1xuQ29kaWNvbi5rZXkgPSBuZXcgQ29kaWNvbigna2V5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTEnIH0pO1xuQ29kaWNvbi5sYXcgPSBuZXcgQ29kaWNvbignbGF3JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTInIH0pO1xuQ29kaWNvbi5saWdodGJ1bGJBdXRvZml4ID0gbmV3IENvZGljb24oJ2xpZ2h0YnVsYi1hdXRvZml4JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTMnIH0pO1xuQ29kaWNvbi5saW5rRXh0ZXJuYWwgPSBuZXcgQ29kaWNvbignbGluay1leHRlcm5hbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjE0JyB9KTtcbkNvZGljb24ubGluayA9IG5ldyBDb2RpY29uKCdsaW5rJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTUnIH0pO1xuQ29kaWNvbi5saXN0T3JkZXJlZCA9IG5ldyBDb2RpY29uKCdsaXN0LW9yZGVyZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxNicgfSk7XG5Db2RpY29uLmxpc3RVbm9yZGVyZWQgPSBuZXcgQ29kaWNvbignbGlzdC11bm9yZGVyZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxNycgfSk7XG5Db2RpY29uLmxpdmVTaGFyZSA9IG5ldyBDb2RpY29uKCdsaXZlLXNoYXJlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMTgnIH0pO1xuQ29kaWNvbi5sb2FkaW5nID0gbmV3IENvZGljb24oJ2xvYWRpbmcnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxOScgfSk7XG5Db2RpY29uLmxvY2F0aW9uID0gbmV3IENvZGljb24oJ2xvY2F0aW9uJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMWEnIH0pO1xuQ29kaWNvbi5tYWlsUmVhZCA9IG5ldyBDb2RpY29uKCdtYWlsLXJlYWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxYicgfSk7XG5Db2RpY29uLm1haWwgPSBuZXcgQ29kaWNvbignbWFpbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjFjJyB9KTtcbkNvZGljb24ubWFya2Rvd24gPSBuZXcgQ29kaWNvbignbWFya2Rvd24nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxZCcgfSk7XG5Db2RpY29uLm1lZ2FwaG9uZSA9IG5ldyBDb2RpY29uKCdtZWdhcGhvbmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIxZScgfSk7XG5Db2RpY29uLm1lbnRpb24gPSBuZXcgQ29kaWNvbignbWVudGlvbicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjFmJyB9KTtcbkNvZGljb24ubWlsZXN0b25lID0gbmV3IENvZGljb24oJ21pbGVzdG9uZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjIwJyB9KTtcbkNvZGljb24ubW9ydGFyQm9hcmQgPSBuZXcgQ29kaWNvbignbW9ydGFyLWJvYXJkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMjEnIH0pO1xuQ29kaWNvbi5tb3ZlID0gbmV3IENvZGljb24oJ21vdmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyMicgfSk7XG5Db2RpY29uLm11bHRpcGxlV2luZG93cyA9IG5ldyBDb2RpY29uKCdtdWx0aXBsZS13aW5kb3dzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMjMnIH0pO1xuQ29kaWNvbi5tdXRlID0gbmV3IENvZGljb24oJ211dGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyNCcgfSk7XG5Db2RpY29uLm5vTmV3bGluZSA9IG5ldyBDb2RpY29uKCduby1uZXdsaW5lJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMjUnIH0pO1xuQ29kaWNvbi5ub3RlID0gbmV3IENvZGljb24oJ25vdGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyNicgfSk7XG5Db2RpY29uLm9jdG9mYWNlID0gbmV3IENvZGljb24oJ29jdG9mYWNlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMjcnIH0pO1xuQ29kaWNvbi5vcGVuUHJldmlldyA9IG5ldyBDb2RpY29uKCdvcGVuLXByZXZpZXcnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyOCcgfSk7XG5Db2RpY29uLnBhY2thZ2VfID0gbmV3IENvZGljb24oJ3BhY2thZ2UnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyOScgfSk7XG5Db2RpY29uLnBhaW50Y2FuID0gbmV3IENvZGljb24oJ3BhaW50Y2FuJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMmEnIH0pO1xuQ29kaWNvbi5waW4gPSBuZXcgQ29kaWNvbigncGluJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMmInIH0pO1xuQ29kaWNvbi5wbGF5ID0gbmV3IENvZGljb24oJ3BsYXknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyYycgfSk7XG5Db2RpY29uLnJ1biA9IG5ldyBDb2RpY29uKCdydW4nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyYycgfSk7XG5Db2RpY29uLnBsdWcgPSBuZXcgQ29kaWNvbigncGx1ZycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjJkJyB9KTtcbkNvZGljb24ucHJlc2VydmVDYXNlID0gbmV3IENvZGljb24oJ3ByZXNlcnZlLWNhc2UnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIyZScgfSk7XG5Db2RpY29uLnByZXZpZXcgPSBuZXcgQ29kaWNvbigncHJldmlldycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjJmJyB9KTtcbkNvZGljb24ucHJvamVjdCA9IG5ldyBDb2RpY29uKCdwcm9qZWN0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMzAnIH0pO1xuQ29kaWNvbi5wdWxzZSA9IG5ldyBDb2RpY29uKCdwdWxzZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjMxJyB9KTtcbkNvZGljb24ucXVlc3Rpb24gPSBuZXcgQ29kaWNvbigncXVlc3Rpb24nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIzMicgfSk7XG5Db2RpY29uLnF1b3RlID0gbmV3IENvZGljb24oJ3F1b3RlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMzMnIH0pO1xuQ29kaWNvbi5yYWRpb1Rvd2VyID0gbmV3IENvZGljb24oJ3JhZGlvLXRvd2VyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMzQnIH0pO1xuQ29kaWNvbi5yZWFjdGlvbnMgPSBuZXcgQ29kaWNvbigncmVhY3Rpb25zJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViMzUnIH0pO1xuQ29kaWNvbi5yZWZlcmVuY2VzID0gbmV3IENvZGljb24oJ3JlZmVyZW5jZXMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIzNicgfSk7XG5Db2RpY29uLnJlZnJlc2ggPSBuZXcgQ29kaWNvbigncmVmcmVzaCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjM3JyB9KTtcbkNvZGljb24ucmVnZXggPSBuZXcgQ29kaWNvbigncmVnZXgnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIzOCcgfSk7XG5Db2RpY29uLnJlbW90ZUV4cGxvcmVyID0gbmV3IENvZGljb24oJ3JlbW90ZS1leHBsb3JlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjM5JyB9KTtcbkNvZGljb24ucmVtb3RlID0gbmV3IENvZGljb24oJ3JlbW90ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjNhJyB9KTtcbkNvZGljb24ucmVtb3ZlID0gbmV3IENvZGljb24oJ3JlbW92ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjNiJyB9KTtcbkNvZGljb24ucmVwbGFjZUFsbCA9IG5ldyBDb2RpY29uKCdyZXBsYWNlLWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjNjJyB9KTtcbkNvZGljb24ucmVwbGFjZSA9IG5ldyBDb2RpY29uKCdyZXBsYWNlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViM2QnIH0pO1xuQ29kaWNvbi5yZXBvQ2xvbmUgPSBuZXcgQ29kaWNvbigncmVwby1jbG9uZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjNlJyB9KTtcbkNvZGljb24ucmVwb0ZvcmNlUHVzaCA9IG5ldyBDb2RpY29uKCdyZXBvLWZvcmNlLXB1c2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWIzZicgfSk7XG5Db2RpY29uLnJlcG9QdWxsID0gbmV3IENvZGljb24oJ3JlcG8tcHVsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjQwJyB9KTtcbkNvZGljb24ucmVwb1B1c2ggPSBuZXcgQ29kaWNvbigncmVwby1wdXNoJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNDEnIH0pO1xuQ29kaWNvbi5yZXBvcnQgPSBuZXcgQ29kaWNvbigncmVwb3J0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNDInIH0pO1xuQ29kaWNvbi5yZXF1ZXN0Q2hhbmdlcyA9IG5ldyBDb2RpY29uKCdyZXF1ZXN0LWNoYW5nZXMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0MycgfSk7XG5Db2RpY29uLnJvY2tldCA9IG5ldyBDb2RpY29uKCdyb2NrZXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0NCcgfSk7XG5Db2RpY29uLnJvb3RGb2xkZXJPcGVuZWQgPSBuZXcgQ29kaWNvbigncm9vdC1mb2xkZXItb3BlbmVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNDUnIH0pO1xuQ29kaWNvbi5yb290Rm9sZGVyID0gbmV3IENvZGljb24oJ3Jvb3QtZm9sZGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNDYnIH0pO1xuQ29kaWNvbi5yc3MgPSBuZXcgQ29kaWNvbigncnNzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNDcnIH0pO1xuQ29kaWNvbi5ydWJ5ID0gbmV3IENvZGljb24oJ3J1YnknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0OCcgfSk7XG5Db2RpY29uLnNhdmVBbGwgPSBuZXcgQ29kaWNvbignc2F2ZS1hbGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0OScgfSk7XG5Db2RpY29uLnNhdmVBcyA9IG5ldyBDb2RpY29uKCdzYXZlLWFzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNGEnIH0pO1xuQ29kaWNvbi5zYXZlID0gbmV3IENvZGljb24oJ3NhdmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0YicgfSk7XG5Db2RpY29uLnNjcmVlbkZ1bGwgPSBuZXcgQ29kaWNvbignc2NyZWVuLWZ1bGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI0YycgfSk7XG5Db2RpY29uLnNjcmVlbk5vcm1hbCA9IG5ldyBDb2RpY29uKCdzY3JlZW4tbm9ybWFsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNGQnIH0pO1xuQ29kaWNvbi5zZWFyY2hTdG9wID0gbmV3IENvZGljb24oJ3NlYXJjaC1zdG9wJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNGUnIH0pO1xuQ29kaWNvbi5zZXJ2ZXIgPSBuZXcgQ29kaWNvbignc2VydmVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNTAnIH0pO1xuQ29kaWNvbi5zZXR0aW5nc0dlYXIgPSBuZXcgQ29kaWNvbignc2V0dGluZ3MtZ2VhcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjUxJyB9KTtcbkNvZGljb24uc2V0dGluZ3MgPSBuZXcgQ29kaWNvbignc2V0dGluZ3MnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1MicgfSk7XG5Db2RpY29uLnNoaWVsZCA9IG5ldyBDb2RpY29uKCdzaGllbGQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1MycgfSk7XG5Db2RpY29uLnNtaWxleSA9IG5ldyBDb2RpY29uKCdzbWlsZXknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1NCcgfSk7XG5Db2RpY29uLnNvcnRQcmVjZWRlbmNlID0gbmV3IENvZGljb24oJ3NvcnQtcHJlY2VkZW5jZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjU1JyB9KTtcbkNvZGljb24uc3BsaXRIb3Jpem9udGFsID0gbmV3IENvZGljb24oJ3NwbGl0LWhvcml6b250YWwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1NicgfSk7XG5Db2RpY29uLnNwbGl0VmVydGljYWwgPSBuZXcgQ29kaWNvbignc3BsaXQtdmVydGljYWwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1NycgfSk7XG5Db2RpY29uLnNxdWlycmVsID0gbmV3IENvZGljb24oJ3NxdWlycmVsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNTgnIH0pO1xuQ29kaWNvbi5zdGFyRnVsbCA9IG5ldyBDb2RpY29uKCdzdGFyLWZ1bGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1OScgfSk7XG5Db2RpY29uLnN0YXJIYWxmID0gbmV3IENvZGljb24oJ3N0YXItaGFsZicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjVhJyB9KTtcbkNvZGljb24uc3ltYm9sQ2xhc3MgPSBuZXcgQ29kaWNvbignc3ltYm9sLWNsYXNzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNWInIH0pO1xuQ29kaWNvbi5zeW1ib2xDb2xvciA9IG5ldyBDb2RpY29uKCdzeW1ib2wtY29sb3InLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI1YycgfSk7XG5Db2RpY29uLnN5bWJvbEN1c3RvbUNvbG9yID0gbmV3IENvZGljb24oJ3N5bWJvbC1jdXN0b21jb2xvcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjVjJyB9KTtcbkNvZGljb24uc3ltYm9sQ29uc3RhbnQgPSBuZXcgQ29kaWNvbignc3ltYm9sLWNvbnN0YW50JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNWQnIH0pO1xuQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyID0gbmV3IENvZGljb24oJ3N5bWJvbC1lbnVtLW1lbWJlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjVlJyB9KTtcbkNvZGljb24uc3ltYm9sRmllbGQgPSBuZXcgQ29kaWNvbignc3ltYm9sLWZpZWxkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNWYnIH0pO1xuQ29kaWNvbi5zeW1ib2xGaWxlID0gbmV3IENvZGljb24oJ3N5bWJvbC1maWxlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNjAnIH0pO1xuQ29kaWNvbi5zeW1ib2xJbnRlcmZhY2UgPSBuZXcgQ29kaWNvbignc3ltYm9sLWludGVyZmFjZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjYxJyB9KTtcbkNvZGljb24uc3ltYm9sS2V5d29yZCA9IG5ldyBDb2RpY29uKCdzeW1ib2wta2V5d29yZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjYyJyB9KTtcbkNvZGljb24uc3ltYm9sTWlzYyA9IG5ldyBDb2RpY29uKCdzeW1ib2wtbWlzYycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjYzJyB9KTtcbkNvZGljb24uc3ltYm9sT3BlcmF0b3IgPSBuZXcgQ29kaWNvbignc3ltYm9sLW9wZXJhdG9yJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNjQnIH0pO1xuQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eSA9IG5ldyBDb2RpY29uKCdzeW1ib2wtcHJvcGVydHknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI2NScgfSk7XG5Db2RpY29uLndyZW5jaCA9IG5ldyBDb2RpY29uKCd3cmVuY2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI2NScgfSk7XG5Db2RpY29uLndyZW5jaFN1YmFjdGlvbiA9IG5ldyBDb2RpY29uKCd3cmVuY2gtc3ViYWN0aW9uJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNjUnIH0pO1xuQ29kaWNvbi5zeW1ib2xTbmlwcGV0ID0gbmV3IENvZGljb24oJ3N5bWJvbC1zbmlwcGV0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNjYnIH0pO1xuQ29kaWNvbi50YXNrbGlzdCA9IG5ldyBDb2RpY29uKCd0YXNrbGlzdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjY3JyB9KTtcbkNvZGljb24udGVsZXNjb3BlID0gbmV3IENvZGljb24oJ3RlbGVzY29wZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjY4JyB9KTtcbkNvZGljb24udGV4dFNpemUgPSBuZXcgQ29kaWNvbigndGV4dC1zaXplJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNjknIH0pO1xuQ29kaWNvbi50aHJlZUJhcnMgPSBuZXcgQ29kaWNvbigndGhyZWUtYmFycycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjZhJyB9KTtcbkNvZGljb24udGh1bWJzZG93biA9IG5ldyBDb2RpY29uKCd0aHVtYnNkb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNmInIH0pO1xuQ29kaWNvbi50aHVtYnN1cCA9IG5ldyBDb2RpY29uKCd0aHVtYnN1cCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjZjJyB9KTtcbkNvZGljb24udG9vbHMgPSBuZXcgQ29kaWNvbigndG9vbHMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI2ZCcgfSk7XG5Db2RpY29uLnRyaWFuZ2xlRG93biA9IG5ldyBDb2RpY29uKCd0cmlhbmdsZS1kb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNmUnIH0pO1xuQ29kaWNvbi50cmlhbmdsZUxlZnQgPSBuZXcgQ29kaWNvbigndHJpYW5nbGUtbGVmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjZmJyB9KTtcbkNvZGljb24udHJpYW5nbGVSaWdodCA9IG5ldyBDb2RpY29uKCd0cmlhbmdsZS1yaWdodCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjcwJyB9KTtcbkNvZGljb24udHJpYW5nbGVVcCA9IG5ldyBDb2RpY29uKCd0cmlhbmdsZS11cCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjcxJyB9KTtcbkNvZGljb24udHdpdHRlciA9IG5ldyBDb2RpY29uKCd0d2l0dGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzInIH0pO1xuQ29kaWNvbi51bmZvbGQgPSBuZXcgQ29kaWNvbigndW5mb2xkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzMnIH0pO1xuQ29kaWNvbi51bmxvY2sgPSBuZXcgQ29kaWNvbigndW5sb2NrJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzQnIH0pO1xuQ29kaWNvbi51bm11dGUgPSBuZXcgQ29kaWNvbigndW5tdXRlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzUnIH0pO1xuQ29kaWNvbi51bnZlcmlmaWVkID0gbmV3IENvZGljb24oJ3VudmVyaWZpZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI3NicgfSk7XG5Db2RpY29uLnZlcmlmaWVkID0gbmV3IENvZGljb24oJ3ZlcmlmaWVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzcnIH0pO1xuQ29kaWNvbi52ZXJzaW9ucyA9IG5ldyBDb2RpY29uKCd2ZXJzaW9ucycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjc4JyB9KTtcbkNvZGljb24udm1BY3RpdmUgPSBuZXcgQ29kaWNvbigndm0tYWN0aXZlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViNzknIH0pO1xuQ29kaWNvbi52bU91dGxpbmUgPSBuZXcgQ29kaWNvbigndm0tb3V0bGluZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjdhJyB9KTtcbkNvZGljb24udm1SdW5uaW5nID0gbmV3IENvZGljb24oJ3ZtLXJ1bm5pbmcnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI3YicgfSk7XG5Db2RpY29uLndhdGNoID0gbmV3IENvZGljb24oJ3dhdGNoJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViN2MnIH0pO1xuQ29kaWNvbi53aGl0ZXNwYWNlID0gbmV3IENvZGljb24oJ3doaXRlc3BhY2UnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI3ZCcgfSk7XG5Db2RpY29uLndob2xlV29yZCA9IG5ldyBDb2RpY29uKCd3aG9sZS13b3JkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViN2UnIH0pO1xuQ29kaWNvbi53aW5kb3cgPSBuZXcgQ29kaWNvbignd2luZG93JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViN2YnIH0pO1xuQ29kaWNvbi53b3JkV3JhcCA9IG5ldyBDb2RpY29uKCd3b3JkLXdyYXAnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4MCcgfSk7XG5Db2RpY29uLnpvb21JbiA9IG5ldyBDb2RpY29uKCd6b29tLWluJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViODEnIH0pO1xuQ29kaWNvbi56b29tT3V0ID0gbmV3IENvZGljb24oJ3pvb20tb3V0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViODInIH0pO1xuQ29kaWNvbi5saXN0RmlsdGVyID0gbmV3IENvZGljb24oJ2xpc3QtZmlsdGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViODMnIH0pO1xuQ29kaWNvbi5saXN0RmxhdCA9IG5ldyBDb2RpY29uKCdsaXN0LWZsYXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4NCcgfSk7XG5Db2RpY29uLmxpc3RTZWxlY3Rpb24gPSBuZXcgQ29kaWNvbignbGlzdC1zZWxlY3Rpb24nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4NScgfSk7XG5Db2RpY29uLnNlbGVjdGlvbiA9IG5ldyBDb2RpY29uKCdzZWxlY3Rpb24nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4NScgfSk7XG5Db2RpY29uLmxpc3RUcmVlID0gbmV3IENvZGljb24oJ2xpc3QtdHJlZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjg2JyB9KTtcbkNvZGljb24uZGVidWdCcmVha3BvaW50RnVuY3Rpb25VbnZlcmlmaWVkID0gbmV3IENvZGljb24oJ2RlYnVnLWJyZWFrcG9pbnQtZnVuY3Rpb24tdW52ZXJpZmllZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjg3JyB9KTtcbkNvZGljb24uZGVidWdCcmVha3BvaW50RnVuY3Rpb24gPSBuZXcgQ29kaWNvbignZGVidWctYnJlYWtwb2ludC1mdW5jdGlvbicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjg4JyB9KTtcbkNvZGljb24uZGVidWdCcmVha3BvaW50RnVuY3Rpb25EaXNhYmxlZCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uLWRpc2FibGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViODgnIH0pO1xuQ29kaWNvbi5kZWJ1Z1N0YWNrZnJhbWVBY3RpdmUgPSBuZXcgQ29kaWNvbignZGVidWctc3RhY2tmcmFtZS1hY3RpdmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4OScgfSk7XG5Db2RpY29uLmRlYnVnU3RhY2tmcmFtZURvdCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1zdGFja2ZyYW1lLWRvdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjhhJyB9KTtcbkNvZGljb24uZGVidWdTdGFja2ZyYW1lID0gbmV3IENvZGljb24oJ2RlYnVnLXN0YWNrZnJhbWUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4YicgfSk7XG5Db2RpY29uLmRlYnVnU3RhY2tmcmFtZUZvY3VzZWQgPSBuZXcgQ29kaWNvbignZGVidWctc3RhY2tmcmFtZS1mb2N1c2VkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViOGInIH0pO1xuQ29kaWNvbi5kZWJ1Z0JyZWFrcG9pbnRVbnN1cHBvcnRlZCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1icmVha3BvaW50LXVuc3VwcG9ydGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViOGMnIH0pO1xuQ29kaWNvbi5zeW1ib2xTdHJpbmcgPSBuZXcgQ29kaWNvbignc3ltYm9sLXN0cmluZycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjhkJyB9KTtcbkNvZGljb24uZGVidWdSZXZlcnNlQ29udGludWUgPSBuZXcgQ29kaWNvbignZGVidWctcmV2ZXJzZS1jb250aW51ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjhlJyB9KTtcbkNvZGljb24uZGVidWdTdGVwQmFjayA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1zdGVwLWJhY2snLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI4ZicgfSk7XG5Db2RpY29uLmRlYnVnUmVzdGFydEZyYW1lID0gbmV3IENvZGljb24oJ2RlYnVnLXJlc3RhcnQtZnJhbWUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5MCcgfSk7XG5Db2RpY29uLmNhbGxJbmNvbWluZyA9IG5ldyBDb2RpY29uKCdjYWxsLWluY29taW5nJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViOTInIH0pO1xuQ29kaWNvbi5jYWxsT3V0Z29pbmcgPSBuZXcgQ29kaWNvbignY2FsbC1vdXRnb2luZycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjkzJyB9KTtcbkNvZGljb24ubWVudSA9IG5ldyBDb2RpY29uKCdtZW51JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViOTQnIH0pO1xuQ29kaWNvbi5leHBhbmRBbGwgPSBuZXcgQ29kaWNvbignZXhwYW5kLWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjk1JyB9KTtcbkNvZGljb24uZmVlZGJhY2sgPSBuZXcgQ29kaWNvbignZmVlZGJhY2snLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5NicgfSk7XG5Db2RpY29uLmdyb3VwQnlSZWZUeXBlID0gbmV3IENvZGljb24oJ2dyb3VwLWJ5LXJlZi10eXBlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViOTcnIH0pO1xuQ29kaWNvbi51bmdyb3VwQnlSZWZUeXBlID0gbmV3IENvZGljb24oJ3VuZ3JvdXAtYnktcmVmLXR5cGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5OCcgfSk7XG5Db2RpY29uLmFjY291bnQgPSBuZXcgQ29kaWNvbignYWNjb3VudCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjk5JyB9KTtcbkNvZGljb24uYmVsbERvdCA9IG5ldyBDb2RpY29uKCdiZWxsLWRvdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjlhJyB9KTtcbkNvZGljb24uZGVidWdDb25zb2xlID0gbmV3IENvZGljb24oJ2RlYnVnLWNvbnNvbGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5YicgfSk7XG5Db2RpY29uLmxpYnJhcnkgPSBuZXcgQ29kaWNvbignbGlicmFyeScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjljJyB9KTtcbkNvZGljb24ub3V0cHV0ID0gbmV3IENvZGljb24oJ291dHB1dCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjlkJyB9KTtcbkNvZGljb24ucnVuQWxsID0gbmV3IENvZGljb24oJ3J1bi1hbGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5ZScgfSk7XG5Db2RpY29uLnN5bmNJZ25vcmVkID0gbmV3IENvZGljb24oJ3N5bmMtaWdub3JlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYjlmJyB9KTtcbkNvZGljb24ucGlubmVkID0gbmV3IENvZGljb24oJ3Bpbm5lZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmEwJyB9KTtcbkNvZGljb24uZ2l0aHViSW52ZXJ0ZWQgPSBuZXcgQ29kaWNvbignZ2l0aHViLWludmVydGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYTEnIH0pO1xuQ29kaWNvbi5kZWJ1Z0FsdCA9IG5ldyBDb2RpY29uKCdkZWJ1Zy1hbHQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWI5MScgfSk7XG5Db2RpY29uLnNlcnZlclByb2Nlc3MgPSBuZXcgQ29kaWNvbignc2VydmVyLXByb2Nlc3MnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJhMicgfSk7XG5Db2RpY29uLnNlcnZlckVudmlyb25tZW50ID0gbmV3IENvZGljb24oJ3NlcnZlci1lbnZpcm9ubWVudCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmEzJyB9KTtcbkNvZGljb24ucGFzcyA9IG5ldyBDb2RpY29uKCdwYXNzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYTQnIH0pO1xuQ29kaWNvbi5zdG9wQ2lyY2xlID0gbmV3IENvZGljb24oJ3N0b3AtY2lyY2xlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYTUnIH0pO1xuQ29kaWNvbi5wbGF5Q2lyY2xlID0gbmV3IENvZGljb24oJ3BsYXktY2lyY2xlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYTYnIH0pO1xuQ29kaWNvbi5yZWNvcmQgPSBuZXcgQ29kaWNvbigncmVjb3JkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYTcnIH0pO1xuQ29kaWNvbi5kZWJ1Z0FsdFNtYWxsID0gbmV3IENvZGljb24oJ2RlYnVnLWFsdC1zbWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmE4JyB9KTtcbkNvZGljb24udm1Db25uZWN0ID0gbmV3IENvZGljb24oJ3ZtLWNvbm5lY3QnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJhOScgfSk7XG5Db2RpY29uLmNsb3VkID0gbmV3IENvZGljb24oJ2Nsb3VkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYWEnIH0pO1xuQ29kaWNvbi5tZXJnZSA9IG5ldyBDb2RpY29uKCdtZXJnZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmFiJyB9KTtcbkNvZGljb24uZXhwb3J0SWNvbiA9IG5ldyBDb2RpY29uKCdleHBvcnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJhYycgfSk7XG5Db2RpY29uLmdyYXBoTGVmdCA9IG5ldyBDb2RpY29uKCdncmFwaC1sZWZ0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYWQnIH0pO1xuQ29kaWNvbi5tYWduZXQgPSBuZXcgQ29kaWNvbignbWFnbmV0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYWUnIH0pO1xuQ29kaWNvbi5ub3RlYm9vayA9IG5ldyBDb2RpY29uKCdub3RlYm9vaycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmFmJyB9KTtcbkNvZGljb24ucmVkbyA9IG5ldyBDb2RpY29uKCdyZWRvJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYjAnIH0pO1xuQ29kaWNvbi5jaGVja0FsbCA9IG5ldyBDb2RpY29uKCdjaGVjay1hbGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJiMScgfSk7XG5Db2RpY29uLnBpbm5lZERpcnR5ID0gbmV3IENvZGljb24oJ3Bpbm5lZC1kaXJ0eScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmIyJyB9KTtcbkNvZGljb24ucGFzc0ZpbGxlZCA9IG5ldyBDb2RpY29uKCdwYXNzLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmIzJyB9KTtcbkNvZGljb24uY2lyY2xlTGFyZ2VGaWxsZWQgPSBuZXcgQ29kaWNvbignY2lyY2xlLWxhcmdlLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmI0JyB9KTtcbkNvZGljb24uY2lyY2xlTGFyZ2VPdXRsaW5lID0gbmV3IENvZGljb24oJ2NpcmNsZS1sYXJnZS1vdXRsaW5lJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYjUnIH0pO1xuQ29kaWNvbi5jb21iaW5lID0gbmV3IENvZGljb24oJ2NvbWJpbmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJiNicgfSk7XG5Db2RpY29uLmdhdGhlciA9IG5ldyBDb2RpY29uKCdnYXRoZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJiNicgfSk7XG5Db2RpY29uLnRhYmxlID0gbmV3IENvZGljb24oJ3RhYmxlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYjcnIH0pO1xuQ29kaWNvbi52YXJpYWJsZUdyb3VwID0gbmV3IENvZGljb24oJ3ZhcmlhYmxlLWdyb3VwJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYjgnIH0pO1xuQ29kaWNvbi50eXBlSGllcmFyY2h5ID0gbmV3IENvZGljb24oJ3R5cGUtaGllcmFyY2h5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYjknIH0pO1xuQ29kaWNvbi50eXBlSGllcmFyY2h5U3ViID0gbmV3IENvZGljb24oJ3R5cGUtaGllcmFyY2h5LXN1YicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmJhJyB9KTtcbkNvZGljb24udHlwZUhpZXJhcmNoeVN1cGVyID0gbmV3IENvZGljb24oJ3R5cGUtaGllcmFyY2h5LXN1cGVyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYmInIH0pO1xuQ29kaWNvbi5naXRQdWxsUmVxdWVzdENyZWF0ZSA9IG5ldyBDb2RpY29uKCdnaXQtcHVsbC1yZXF1ZXN0LWNyZWF0ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmJjJyB9KTtcbkNvZGljb24ucnVuQWJvdmUgPSBuZXcgQ29kaWNvbigncnVuLWFib3ZlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYmQnIH0pO1xuQ29kaWNvbi5ydW5CZWxvdyA9IG5ldyBDb2RpY29uKCdydW4tYmVsb3cnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJiZScgfSk7XG5Db2RpY29uLm5vdGVib29rVGVtcGxhdGUgPSBuZXcgQ29kaWNvbignbm90ZWJvb2stdGVtcGxhdGUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJiZicgfSk7XG5Db2RpY29uLmRlYnVnUmVydW4gPSBuZXcgQ29kaWNvbignZGVidWctcmVydW4nLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjMCcgfSk7XG5Db2RpY29uLndvcmtzcGFjZVRydXN0ZWQgPSBuZXcgQ29kaWNvbignd29ya3NwYWNlLXRydXN0ZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjMScgfSk7XG5Db2RpY29uLndvcmtzcGFjZVVudHJ1c3RlZCA9IG5ldyBDb2RpY29uKCd3b3Jrc3BhY2UtdW50cnVzdGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYzInIH0pO1xuQ29kaWNvbi53b3Jrc3BhY2VVbnNwZWNpZmllZCA9IG5ldyBDb2RpY29uKCd3b3Jrc3BhY2UtdW5zcGVjaWZpZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjMycgfSk7XG5Db2RpY29uLnRlcm1pbmFsQ21kID0gbmV3IENvZGljb24oJ3Rlcm1pbmFsLWNtZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmM0JyB9KTtcbkNvZGljb24udGVybWluYWxEZWJpYW4gPSBuZXcgQ29kaWNvbigndGVybWluYWwtZGViaWFuJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYzUnIH0pO1xuQ29kaWNvbi50ZXJtaW5hbExpbnV4ID0gbmV3IENvZGljb24oJ3Rlcm1pbmFsLWxpbnV4JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViYzYnIH0pO1xuQ29kaWNvbi50ZXJtaW5hbFBvd2Vyc2hlbGwgPSBuZXcgQ29kaWNvbigndGVybWluYWwtcG93ZXJzaGVsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmM3JyB9KTtcbkNvZGljb24udGVybWluYWxUbXV4ID0gbmV3IENvZGljb24oJ3Rlcm1pbmFsLXRtdXgnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjOCcgfSk7XG5Db2RpY29uLnRlcm1pbmFsVWJ1bnR1ID0gbmV3IENvZGljb24oJ3Rlcm1pbmFsLXVidW50dScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmM5JyB9KTtcbkNvZGljb24udGVybWluYWxCYXNoID0gbmV3IENvZGljb24oJ3Rlcm1pbmFsLWJhc2gnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjYScgfSk7XG5Db2RpY29uLmFycm93U3dhcCA9IG5ldyBDb2RpY29uKCdhcnJvdy1zd2FwJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViY2InIH0pO1xuQ29kaWNvbi5jb3B5ID0gbmV3IENvZGljb24oJ2NvcHknLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJjYycgfSk7XG5Db2RpY29uLnBlcnNvbkFkZCA9IG5ldyBDb2RpY29uKCdwZXJzb24tYWRkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViY2QnIH0pO1xuQ29kaWNvbi5maWx0ZXJGaWxsZWQgPSBuZXcgQ29kaWNvbignZmlsdGVyLWZpbGxlZCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmNlJyB9KTtcbkNvZGljb24ud2FuZCA9IG5ldyBDb2RpY29uKCd3YW5kJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViY2YnIH0pO1xuQ29kaWNvbi5kZWJ1Z0xpbmVCeUxpbmUgPSBuZXcgQ29kaWNvbignZGVidWctbGluZS1ieS1saW5lJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZDAnIH0pO1xuQ29kaWNvbi5pbnNwZWN0ID0gbmV3IENvZGljb24oJ2luc3BlY3QnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJkMScgfSk7XG5Db2RpY29uLmxheWVycyA9IG5ldyBDb2RpY29uKCdsYXllcnMnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJkMicgfSk7XG5Db2RpY29uLmxheWVyc0RvdCA9IG5ldyBDb2RpY29uKCdsYXllcnMtZG90JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZDMnIH0pO1xuQ29kaWNvbi5sYXllcnNBY3RpdmUgPSBuZXcgQ29kaWNvbignbGF5ZXJzLWFjdGl2ZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmQ0JyB9KTtcbkNvZGljb24uY29tcGFzcyA9IG5ldyBDb2RpY29uKCdjb21wYXNzJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZDUnIH0pO1xuQ29kaWNvbi5jb21wYXNzRG90ID0gbmV3IENvZGljb24oJ2NvbXBhc3MtZG90JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZDYnIH0pO1xuQ29kaWNvbi5jb21wYXNzQWN0aXZlID0gbmV3IENvZGljb24oJ2NvbXBhc3MtYWN0aXZlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZDcnIH0pO1xuQ29kaWNvbi5henVyZSA9IG5ldyBDb2RpY29uKCdhenVyZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmQ4JyB9KTtcbkNvZGljb24uaXNzdWVEcmFmdCA9IG5ldyBDb2RpY29uKCdpc3N1ZS1kcmFmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmQ5JyB9KTtcbkNvZGljb24uZ2l0UHVsbFJlcXVlc3RDbG9zZWQgPSBuZXcgQ29kaWNvbignZ2l0LXB1bGwtcmVxdWVzdC1jbG9zZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJkYScgfSk7XG5Db2RpY29uLmdpdFB1bGxSZXF1ZXN0RHJhZnQgPSBuZXcgQ29kaWNvbignZ2l0LXB1bGwtcmVxdWVzdC1kcmFmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmRiJyB9KTtcbkNvZGljb24uZGVidWdBbGwgPSBuZXcgQ29kaWNvbignZGVidWctYWxsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZGMnIH0pO1xuQ29kaWNvbi5kZWJ1Z0NvdmVyYWdlID0gbmV3IENvZGljb24oJ2RlYnVnLWNvdmVyYWdlJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZGQnIH0pO1xuQ29kaWNvbi5ydW5FcnJvcnMgPSBuZXcgQ29kaWNvbigncnVuLWVycm9ycycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmRlJyB9KTtcbkNvZGljb24uZm9sZGVyTGlicmFyeSA9IG5ldyBDb2RpY29uKCdmb2xkZXItbGlicmFyeScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmRmJyB9KTtcbkNvZGljb24uZGVidWdDb250aW51ZVNtYWxsID0gbmV3IENvZGljb24oJ2RlYnVnLWNvbnRpbnVlLXNtYWxsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZTAnIH0pO1xuQ29kaWNvbi5iZWFrZXJTdG9wID0gbmV3IENvZGljb24oJ2JlYWtlci1zdG9wJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZTEnIH0pO1xuQ29kaWNvbi5ncmFwaExpbmUgPSBuZXcgQ29kaWNvbignZ3JhcGgtbGluZScsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmUyJyB9KTtcbkNvZGljb24uZ3JhcGhTY2F0dGVyID0gbmV3IENvZGljb24oJ2dyYXBoLXNjYXR0ZXInLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJlMycgfSk7XG5Db2RpY29uLnBpZUNoYXJ0ID0gbmV3IENvZGljb24oJ3BpZS1jaGFydCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmU0JyB9KTtcbkNvZGljb24uYnJhY2tldCA9IG5ldyBDb2RpY29uKCdicmFja2V0JywgQ29kaWNvbi5qc29uLmRlZmluaXRpb24pO1xuQ29kaWNvbi5icmFja2V0RG90ID0gbmV3IENvZGljb24oJ2JyYWNrZXQtZG90JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZTUnIH0pO1xuQ29kaWNvbi5icmFja2V0RXJyb3IgPSBuZXcgQ29kaWNvbignYnJhY2tldC1lcnJvcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmU2JyB9KTtcbkNvZGljb24ubG9ja1NtYWxsID0gbmV3IENvZGljb24oJ2xvY2stc21hbGwnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJlNycgfSk7XG5Db2RpY29uLmF6dXJlRGV2b3BzID0gbmV3IENvZGljb24oJ2F6dXJlLWRldm9wcycsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmU4JyB9KTtcbkNvZGljb24udmVyaWZpZWRGaWxsZWQgPSBuZXcgQ29kaWNvbigndmVyaWZpZWQtZmlsbGVkJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZTknIH0pO1xuQ29kaWNvbi5uZXdMaW5lID0gbmV3IENvZGljb24oJ25ld2xpbmUnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJlYScgfSk7XG5Db2RpY29uLmxheW91dCA9IG5ldyBDb2RpY29uKCdsYXlvdXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJlYicgfSk7XG5Db2RpY29uLmxheW91dEFjdGl2aXR5YmFyTGVmdCA9IG5ldyBDb2RpY29uKCdsYXlvdXQtYWN0aXZpdHliYXItbGVmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmVjJyB9KTtcbkNvZGljb24ubGF5b3V0QWN0aXZpdHliYXJSaWdodCA9IG5ldyBDb2RpY29uKCdsYXlvdXQtYWN0aXZpdHliYXItcmlnaHQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJlZCcgfSk7XG5Db2RpY29uLmxheW91dFBhbmVsTGVmdCA9IG5ldyBDb2RpY29uKCdsYXlvdXQtcGFuZWwtbGVmdCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmVlJyB9KTtcbkNvZGljb24ubGF5b3V0UGFuZWxDZW50ZXIgPSBuZXcgQ29kaWNvbignbGF5b3V0LXBhbmVsLWNlbnRlcicsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmVmJyB9KTtcbkNvZGljb24ubGF5b3V0UGFuZWxKdXN0aWZ5ID0gbmV3IENvZGljb24oJ2xheW91dC1wYW5lbC1qdXN0aWZ5JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZjAnIH0pO1xuQ29kaWNvbi5sYXlvdXRQYW5lbFJpZ2h0ID0gbmV3IENvZGljb24oJ2xheW91dC1wYW5lbC1yaWdodCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmYxJyB9KTtcbkNvZGljb24ubGF5b3V0UGFuZWwgPSBuZXcgQ29kaWNvbignbGF5b3V0LXBhbmVsJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZjInIH0pO1xuQ29kaWNvbi5sYXlvdXRTaWRlYmFyTGVmdCA9IG5ldyBDb2RpY29uKCdsYXlvdXQtc2lkZWJhci1sZWZ0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZjMnIH0pO1xuQ29kaWNvbi5sYXlvdXRTaWRlYmFyUmlnaHQgPSBuZXcgQ29kaWNvbignbGF5b3V0LXNpZGViYXItcmlnaHQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJmNCcgfSk7XG5Db2RpY29uLmxheW91dFN0YXR1c2JhciA9IG5ldyBDb2RpY29uKCdsYXlvdXQtc3RhdHVzYmFyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZjUnIH0pO1xuQ29kaWNvbi5sYXlvdXRNZW51YmFyID0gbmV3IENvZGljb24oJ2xheW91dC1tZW51YmFyJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZjYnIH0pO1xuQ29kaWNvbi5sYXlvdXRDZW50ZXJlZCA9IG5ldyBDb2RpY29uKCdsYXlvdXQtY2VudGVyZWQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJmNycgfSk7XG5Db2RpY29uLnRhcmdldCA9IG5ldyBDb2RpY29uKCd0YXJnZXQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJmOCcgfSk7XG5Db2RpY29uLmluZGVudCA9IG5ldyBDb2RpY29uKCdpbmRlbnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJmOScgfSk7XG5Db2RpY29uLnJlY29yZFNtYWxsID0gbmV3IENvZGljb24oJ3JlY29yZC1zbWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmZhJyB9KTtcbkNvZGljb24uZXJyb3JTbWFsbCA9IG5ldyBDb2RpY29uKCdlcnJvci1zbWFsbCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmZiJyB9KTtcbkNvZGljb24uYXJyb3dDaXJjbGVEb3duID0gbmV3IENvZGljb24oJ2Fycm93LWNpcmNsZS1kb3duJywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZmMnIH0pO1xuQ29kaWNvbi5hcnJvd0NpcmNsZUxlZnQgPSBuZXcgQ29kaWNvbignYXJyb3ctY2lyY2xlLWxlZnQnLCB7IGZvbnRDaGFyYWN0ZXI6ICdcXFxcZWJmZCcgfSk7XG5Db2RpY29uLmFycm93Q2lyY2xlUmlnaHQgPSBuZXcgQ29kaWNvbignYXJyb3ctY2lyY2xlLXJpZ2h0JywgeyBmb250Q2hhcmFjdGVyOiAnXFxcXGViZmUnIH0pO1xuQ29kaWNvbi5hcnJvd0NpcmNsZVVwID0gbmV3IENvZGljb24oJ2Fycm93LWNpcmNsZS11cCcsIHsgZm9udENoYXJhY3RlcjogJ1xcXFxlYmZmJyB9KTtcbi8vIGRlcml2ZWQgaWNvbnMsIHRoYXQgY291bGQgYmVjb21lIHNlcGFyYXRlIGljb25zXG5Db2RpY29uLmRpYWxvZ0Vycm9yID0gbmV3IENvZGljb24oJ2RpYWxvZy1lcnJvcicsIENvZGljb24uZXJyb3IuZGVmaW5pdGlvbik7XG5Db2RpY29uLmRpYWxvZ1dhcm5pbmcgPSBuZXcgQ29kaWNvbignZGlhbG9nLXdhcm5pbmcnLCBDb2RpY29uLndhcm5pbmcuZGVmaW5pdGlvbik7XG5Db2RpY29uLmRpYWxvZ0luZm8gPSBuZXcgQ29kaWNvbignZGlhbG9nLWluZm8nLCBDb2RpY29uLmluZm8uZGVmaW5pdGlvbik7XG5Db2RpY29uLmRpYWxvZ0Nsb3NlID0gbmV3IENvZGljb24oJ2RpYWxvZy1jbG9zZScsIENvZGljb24uY2xvc2UuZGVmaW5pdGlvbik7XG5Db2RpY29uLnRyZWVJdGVtRXhwYW5kZWQgPSBuZXcgQ29kaWNvbigndHJlZS1pdGVtLWV4cGFuZGVkJywgQ29kaWNvbi5jaGV2cm9uRG93bi5kZWZpbml0aW9uKTsgLy8gY29sbGFwc2VkIGlzIGRvbmUgd2l0aCByb3RhdGlvblxuQ29kaWNvbi50cmVlRmlsdGVyT25UeXBlT24gPSBuZXcgQ29kaWNvbigndHJlZS1maWx0ZXItb24tdHlwZS1vbicsIENvZGljb24ubGlzdEZpbHRlci5kZWZpbml0aW9uKTtcbkNvZGljb24udHJlZUZpbHRlck9uVHlwZU9mZiA9IG5ldyBDb2RpY29uKCd0cmVlLWZpbHRlci1vbi10eXBlLW9mZicsIENvZGljb24ubGlzdFNlbGVjdGlvbi5kZWZpbml0aW9uKTtcbkNvZGljb24udHJlZUZpbHRlckNsZWFyID0gbmV3IENvZGljb24oJ3RyZWUtZmlsdGVyLWNsZWFyJywgQ29kaWNvbi5jbG9zZS5kZWZpbml0aW9uKTtcbkNvZGljb24udHJlZUl0ZW1Mb2FkaW5nID0gbmV3IENvZGljb24oJ3RyZWUtaXRlbS1sb2FkaW5nJywgQ29kaWNvbi5sb2FkaW5nLmRlZmluaXRpb24pO1xuQ29kaWNvbi5tZW51U2VsZWN0aW9uID0gbmV3IENvZGljb24oJ21lbnUtc2VsZWN0aW9uJywgQ29kaWNvbi5jaGVjay5kZWZpbml0aW9uKTtcbkNvZGljb24ubWVudVN1Ym1lbnUgPSBuZXcgQ29kaWNvbignbWVudS1zdWJtZW51JywgQ29kaWNvbi5jaGV2cm9uUmlnaHQuZGVmaW5pdGlvbik7XG5Db2RpY29uLm1lbnVCYXJNb3JlID0gbmV3IENvZGljb24oJ21lbnViYXItbW9yZScsIENvZGljb24ubW9yZS5kZWZpbml0aW9uKTtcbkNvZGljb24uc2Nyb2xsYmFyQnV0dG9uTGVmdCA9IG5ldyBDb2RpY29uKCdzY3JvbGxiYXItYnV0dG9uLWxlZnQnLCBDb2RpY29uLnRyaWFuZ2xlTGVmdC5kZWZpbml0aW9uKTtcbkNvZGljb24uc2Nyb2xsYmFyQnV0dG9uUmlnaHQgPSBuZXcgQ29kaWNvbignc2Nyb2xsYmFyLWJ1dHRvbi1yaWdodCcsIENvZGljb24udHJpYW5nbGVSaWdodC5kZWZpbml0aW9uKTtcbkNvZGljb24uc2Nyb2xsYmFyQnV0dG9uVXAgPSBuZXcgQ29kaWNvbignc2Nyb2xsYmFyLWJ1dHRvbi11cCcsIENvZGljb24udHJpYW5nbGVVcC5kZWZpbml0aW9uKTtcbkNvZGljb24uc2Nyb2xsYmFyQnV0dG9uRG93biA9IG5ldyBDb2RpY29uKCdzY3JvbGxiYXItYnV0dG9uLWRvd24nLCBDb2RpY29uLnRyaWFuZ2xlRG93bi5kZWZpbml0aW9uKTtcbkNvZGljb24udG9vbEJhck1vcmUgPSBuZXcgQ29kaWNvbigndG9vbGJhci1tb3JlJywgQ29kaWNvbi5tb3JlLmRlZmluaXRpb24pO1xuQ29kaWNvbi5xdWlja0lucHV0QmFjayA9IG5ldyBDb2RpY29uKCdxdWljay1pbnB1dC1iYWNrJywgQ29kaWNvbi5hcnJvd0xlZnQuZGVmaW5pdGlvbik7XG5leHBvcnQgdmFyIENTU0ljb247XG4oZnVuY3Rpb24gKENTU0ljb24pIHtcbiAgICBDU1NJY29uLmljb25OYW1lU2VnbWVudCA9ICdbQS1aYS16MC05XSsnO1xuICAgIENTU0ljb24uaWNvbk5hbWVFeHByZXNzaW9uID0gJ1tBLVphLXowLTktXSsnO1xuICAgIENTU0ljb24uaWNvbk1vZGlmaWVyRXhwcmVzc2lvbiA9ICd+W0EtWmEtel0rJztcbiAgICBDU1NJY29uLmljb25OYW1lQ2hhcmFjdGVyID0gJ1tBLVphLXowLTl+LV0nO1xuICAgIGNvbnN0IGNzc0ljb25JZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXigke0NTU0ljb24uaWNvbk5hbWVFeHByZXNzaW9ufSkoJHtDU1NJY29uLmljb25Nb2RpZmllckV4cHJlc3Npb259KT8kYCk7XG4gICAgZnVuY3Rpb24gYXNDbGFzc05hbWVBcnJheShpY29uKSB7XG4gICAgICAgIGlmIChpY29uIGluc3RhbmNlb2YgQ29kaWNvbikge1xuICAgICAgICAgICAgcmV0dXJuIFsnY29kaWNvbicsICdjb2RpY29uLScgKyBpY29uLmlkXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9IGNzc0ljb25JZFJlZ2V4LmV4ZWMoaWNvbi5pZCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBhc0NsYXNzTmFtZUFycmF5KENvZGljb24uZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbLCBpZCwgbW9kaWZpZXJdID0gbWF0Y2g7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbJ2NvZGljb24nLCAnY29kaWNvbi0nICsgaWRdO1xuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY29kaWNvbi1tb2RpZmllci0nICsgbW9kaWZpZXIuc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcbiAgICB9XG4gICAgQ1NTSWNvbi5hc0NsYXNzTmFtZUFycmF5ID0gYXNDbGFzc05hbWVBcnJheTtcbiAgICBmdW5jdGlvbiBhc0NsYXNzTmFtZShpY29uKSB7XG4gICAgICAgIHJldHVybiBhc0NsYXNzTmFtZUFycmF5KGljb24pLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgQ1NTSWNvbi5hc0NsYXNzTmFtZSA9IGFzQ2xhc3NOYW1lO1xuICAgIGZ1bmN0aW9uIGFzQ1NTU2VsZWN0b3IoaWNvbikge1xuICAgICAgICByZXR1cm4gJy4nICsgYXNDbGFzc05hbWVBcnJheShpY29uKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIENTU0ljb24uYXNDU1NTZWxlY3RvciA9IGFzQ1NTU2VsZWN0b3I7XG59KShDU1NJY29uIHx8IChDU1NJY29uID0ge30pKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRGlmZkNoYW5nZSB9IGZyb20gJy4vZGlmZkNoYW5nZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdIYXNoIH0gZnJvbSAnLi4vaGFzaC5qcyc7XG5leHBvcnQgY2xhc3MgU3RyaW5nRGlmZlNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5ldyBJbnQzMkFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gc291cmNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlcnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0RpZmYob3JpZ2luYWwsIG1vZGlmaWVkLCBwcmV0dHkpIHtcbiAgICByZXR1cm4gbmV3IExjc0RpZmYobmV3IFN0cmluZ0RpZmZTZXF1ZW5jZShvcmlnaW5hbCksIG5ldyBTdHJpbmdEaWZmU2VxdWVuY2UobW9kaWZpZWQpKS5Db21wdXRlRGlmZihwcmV0dHkpLmNoYW5nZXM7XG59XG4vL1xuLy8gVGhlIGNvZGUgYmVsb3cgaGFzIGJlZW4gcG9ydGVkIGZyb20gYSBDIyBpbXBsZW1lbnRhdGlvbiBpbiBWU1xuLy9cbmV4cG9ydCBjbGFzcyBEZWJ1ZyB7XG4gICAgc3RhdGljIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNeUFycmF5IHtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSByYW5nZSBvZiBlbGVtZW50cyBmcm9tIGFuIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgc291cmNlIGluZGV4IGFuZCBwYXN0ZXNcbiAgICAgKiB0aGVtIHRvIGFub3RoZXIgQXJyYXkgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBpbmRleC4gVGhlIGxlbmd0aCBhbmQgdGhlIGluZGV4ZXNcbiAgICAgKiBhcmUgc3BlY2lmaWVkIGFzIDY0LWJpdCBpbnRlZ2Vycy5cbiAgICAgKiBzb3VyY2VBcnJheTpcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgZGF0YSB0byBjb3B5LlxuICAgICAqIHNvdXJjZUluZGV4OlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgc291cmNlQXJyYXkgYXQgd2hpY2ggY29weWluZyBiZWdpbnMuXG4gICAgICogZGVzdGluYXRpb25BcnJheTpcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCByZWNlaXZlcyB0aGUgZGF0YS5cbiAgICAgKiBkZXN0aW5hdGlvbkluZGV4OlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgZGVzdGluYXRpb25BcnJheSBhdCB3aGljaCBzdG9yaW5nIGJlZ2lucy5cbiAgICAgKiBsZW5ndGg6XG4gICAgICpcdFx0QSA2NC1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LlxuICAgICAqL1xuICAgIHN0YXRpYyBDb3B5KHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgQ29weTIoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb25BcnJheVtkZXN0aW5hdGlvbkluZGV4ICsgaV0gPSBzb3VyY2VBcnJheVtzb3VyY2VJbmRleCArIGldO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3Mgd2hpY2ggaGVscHMgdG8gY3JlYXRlIHRoZSBzZXQgb2YgRGlmZkNoYW5nZXMgZnJvbVxuICogYSBkaWZmZXJlbmNlIG9wZXJhdGlvbi4gVGhpcyBjbGFzcyBhY2NlcHRzIG9yaWdpbmFsIERpZmZFbGVtZW50cyBhbmRcbiAqIG1vZGlmaWVkIERpZmZFbGVtZW50cyB0aGF0IGFyZSBpbnZvbHZlZCBpbiBhIHBhcnRpY3VsYXIgY2hhbmdlLiBUaGVcbiAqIE1hcmtOZXh0Q2hhbmdlKCkgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gbWFyayB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuXG4gKiBkaXN0aW5jdCBjaGFuZ2VzLiBBdCB0aGUgZW5kLCB0aGUgQ2hhbmdlcyBwcm9wZXJ0eSBjYW4gYmUgY2FsbGVkIHRvIHJldHJpZXZlXG4gKiB0aGUgY29uc3RydWN0ZWQgY2hhbmdlcy5cbiAqL1xuY2xhc3MgRGlmZkNoYW5nZUhlbHBlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBEaWZmQ2hhbmdlSGVscGVyIGZvciB0aGUgZ2l2ZW4gRGlmZlNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tX2NoYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBNQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBjaGFuZ2UgaW4gdGhlIHNldCBvZiBkaWZmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBNYXJrTmV4dENoYW5nZSgpIHtcbiAgICAgICAgLy8gT25seSBhZGQgdG8gdGhlIGxpc3QgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGFkZFxuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgY2hhbmdlIHRvIG91ciBsaXN0XG4gICAgICAgICAgICB0aGlzLm1fY2hhbmdlcy5wdXNoKG5ldyBEaWZmQ2hhbmdlKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCB0aGlzLm1fb3JpZ2luYWxDb3VudCwgdGhpcy5tX21vZGlmaWVkU3RhcnQsIHRoaXMubV9tb2RpZmllZENvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZVxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBNQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBvcmlnaW5hbCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcbiAgICAgKiBhZmZlY3RlZCBieSB0aGUgY3VycmVudCBjaGFuZ2UuIFRoZSBtb2RpZmllZCBpbmRleCBnaXZlcyBjb250ZXh0XG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0byBhZGQuXG4gICAgICogQHBhcmFtIG1vZGlmaWVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb2RpZmllZCBlbGVtZW50IHRoYXQgcHJvdmlkZXMgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhlICd0cnVlJyBzdGFydCBpbmRleCBpcyB0aGUgc21hbGxlc3Qgb2YgdGhlIG9uZXMgd2UndmUgc2VlblxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIG1vZGlmaWVkIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50c1xuICAgICAqIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IGNoYW5nZS4gVGhlIG9yaWdpbmFsIGluZGV4IGdpdmVzIGNvbnRleHRcbiAgICAgKiB0byB0aGUgY2hhbmdlIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIG9yaWdpbmFsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgcHJvdmlkZXMgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIG1vZGlmaWVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb2RpZmllZCBlbGVtZW50IHRvIGFkZC5cbiAgICAgKi9cbiAgICBBZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkge1xuICAgICAgICAvLyBUaGUgJ3RydWUnIHN0YXJ0IGluZGV4IGlzIHRoZSBzbWFsbGVzdCBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX29yaWdpbmFsU3RhcnQsIG9yaWdpbmFsSW5kZXgpO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE1hdGgubWluKHRoaXMubV9tb2RpZmllZFN0YXJ0LCBtb2RpZmllZEluZGV4KTtcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzLlxuICAgICAqL1xuICAgIGdldENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggdXAgb24gd2hhdGV2ZXIgaXMgbGVmdFxuICAgICAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1fY2hhbmdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzIGluIHRoZSByZXZlcnNlIG9yZGVyXG4gICAgICovXG4gICAgZ2V0UmV2ZXJzZUNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggdXAgb24gd2hhdGV2ZXIgaXMgbGVmdFxuICAgICAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV9jaGFuZ2VzLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xuICAgIH1cbn1cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGRpZmZlcmVuY2UgYWxnb3JpdGhtIGRlc2NyaWJlZCBpblxuICogXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIHZhcmlhdGlvbnNcIiBieSBFdWdlbmUgVy4gTXllcnNcbiAqL1xuZXhwb3J0IGNsYXNzIExjc0RpZmYge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIERpZmZGaW5kZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFNlcXVlbmNlID0gb3JpZ2luYWxTZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRTZXF1ZW5jZSA9IG1vZGlmaWVkU2VxdWVuY2U7XG4gICAgICAgIGNvbnN0IFtvcmlnaW5hbFN0cmluZ0VsZW1lbnRzLCBvcmlnaW5hbEVsZW1lbnRzT3JIYXNoLCBvcmlnaW5hbEhhc1N0cmluZ3NdID0gTGNzRGlmZi5fZ2V0RWxlbWVudHMob3JpZ2luYWxTZXF1ZW5jZSk7XG4gICAgICAgIGNvbnN0IFttb2RpZmllZFN0cmluZ0VsZW1lbnRzLCBtb2RpZmllZEVsZW1lbnRzT3JIYXNoLCBtb2RpZmllZEhhc1N0cmluZ3NdID0gTGNzRGlmZi5fZ2V0RWxlbWVudHMobW9kaWZpZWRTZXF1ZW5jZSk7XG4gICAgICAgIHRoaXMuX2hhc1N0cmluZ3MgPSAob3JpZ2luYWxIYXNTdHJpbmdzICYmIG1vZGlmaWVkSGFzU3RyaW5ncyk7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHMgPSBvcmlnaW5hbFN0cmluZ0VsZW1lbnRzO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoID0gb3JpZ2luYWxFbGVtZW50c09ySGFzaDtcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50cyA9IG1vZGlmaWVkU3RyaW5nRWxlbWVudHM7XG4gICAgICAgIHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2ggPSBtb2RpZmllZEVsZW1lbnRzT3JIYXNoO1xuICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5tX3JldmVyc2VIaXN0b3J5ID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBfaXNTdHJpbmdBcnJheShhcnIpIHtcbiAgICAgICAgcmV0dXJuIChhcnIubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJyk7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0RWxlbWVudHMoc2VxdWVuY2UpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBzZXF1ZW5jZS5nZXRFbGVtZW50cygpO1xuICAgICAgICBpZiAoTGNzRGlmZi5faXNTdHJpbmdBcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlcyA9IG5ldyBJbnQzMkFycmF5KGVsZW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoYXNoZXNbaV0gPSBzdHJpbmdIYXNoKGVsZW1lbnRzW2ldLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWxlbWVudHMsIGhhc2hlcywgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIFtbXSwgZWxlbWVudHMsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBuZXcgSW50MzJBcnJheShlbGVtZW50cyksIGZhbHNlXTtcbiAgICB9XG4gICAgRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4LCBuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtvcmlnaW5hbEluZGV4XSAhPT0gdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaFtuZXdJbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgPyB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW29yaWdpbmFsSW5kZXhdID09PSB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW25ld0luZGV4XSA6IHRydWUpO1xuICAgIH1cbiAgICBFbGVtZW50c0FyZVN0cmljdEVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRWxlbWVudCA9IExjc0RpZmYuX2dldFN0cmljdEVsZW1lbnQodGhpcy5fb3JpZ2luYWxTZXF1ZW5jZSwgb3JpZ2luYWxJbmRleCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRWxlbWVudCA9IExjc0RpZmYuX2dldFN0cmljdEVsZW1lbnQodGhpcy5fbW9kaWZpZWRTZXF1ZW5jZSwgbmV3SW5kZXgpO1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsRWxlbWVudCA9PT0gbW9kaWZpZWRFbGVtZW50KTtcbiAgICB9XG4gICAgc3RhdGljIF9nZXRTdHJpY3RFbGVtZW50KHNlcXVlbmNlLCBpbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlcXVlbmNlLmdldFN0cmljdEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZW5jZS5nZXRTdHJpY3RFbGVtZW50KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZSk7XG4gICAgfVxuICAgIE1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChpbmRleDEsIGluZGV4Mikge1xuICAgICAgICBpZiAodGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaFtpbmRleDFdICE9PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4Ml0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgPyB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4MV0gPT09IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgyXSA6IHRydWUpO1xuICAgIH1cbiAgICBDb21wdXRlRGlmZihwcmV0dHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX0NvbXB1dGVEaWZmKDAsIHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSwgMCwgdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxLCBwcmV0dHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgb3JpZ2luYWwgYW5kIG1vZGlmaWVkIGlucHV0XG4gICAgICogc2VxdWVuY2VzIG9uIHRoZSBib3VuZGVkIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIF9Db21wdXRlRGlmZihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHByZXR0eSkge1xuICAgICAgICBjb25zdCBxdWl0RWFybHlBcnIgPSBbZmFsc2VdO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNsZWFuIHVwIHRoZSBjb21wdXRlZCBkaWZmIHRvIGJlIG1vcmUgaW50dWl0aXZlXG4gICAgICAgICAgICAvLyBidXQgaXQgdHVybnMgb3V0IHRoaXMgY2Fubm90IGJlIGRvbmUgY29ycmVjdGx5IHVudGlsIHRoZSBlbnRpcmUgc2V0XG4gICAgICAgICAgICAvLyBvZiBkaWZmcyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLlByZXR0aWZ5Q2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHlBcnJbMF0sXG4gICAgICAgICAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB3aGljaCBjb21wdXRlcyB0aGUgZGlmZmVyZW5jZXMgb24gdGhlIGJvdW5kZWQgcmFuZ2VcbiAgICAgKiByZWN1cnNpdmVseS5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBDb21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycikge1xuICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTtcbiAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIGRpZmZlcmVuY2VzXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Kys7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIHRoZSBkaWZmZXJlbmNlc1xuICAgICAgICB3aGlsZSAob3JpZ2luYWxFbmQgPj0gb3JpZ2luYWxTdGFydCAmJiBtb2RpZmllZEVuZCA+PSBtb2RpZmllZFN0YXJ0ICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZC0tO1xuICAgICAgICAgICAgbW9kaWZpZWRFbmQtLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGVpdGhlciBoYXZlIGFsbCBpbnNlcnRpb25zIG9yIGFsbCBkZWxldGlvbnMgb3IgdGhlIHNlcXVlbmNlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0ID4gb3JpZ2luYWxFbmQgfHwgbW9kaWZpZWRTdGFydCA+IG1vZGlmaWVkRW5kKSB7XG4gICAgICAgICAgICBsZXQgY2hhbmdlcztcbiAgICAgICAgICAgIGlmIChtb2RpZmllZFN0YXJ0IDw9IG1vZGlmaWVkRW5kKSB7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsRW5kICsgMSwgJ29yaWdpbmFsU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBvcmlnaW5hbEVuZCcpO1xuICAgICAgICAgICAgICAgIC8vIEFsbCBpbnNlcnRpb25zXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgMCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxTdGFydCA8PSBvcmlnaW5hbEVuZCkge1xuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZEVuZCArIDEsICdtb2RpZmllZFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gbW9kaWZpZWRFbmQnKTtcbiAgICAgICAgICAgICAgICAvLyBBbGwgZGVsZXRpb25zXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgMClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsRW5kICsgMSwgJ29yaWdpbmFsU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBvcmlnaW5hbEVuZCcpO1xuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZEVuZCArIDEsICdtb2RpZmllZFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gbW9kaWZpZWRFbmQnKTtcbiAgICAgICAgICAgICAgICAvLyBJZGVudGljYWwgc2VxdWVuY2VzIC0gTm8gZGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHByb2JsZW0gY2FuIGJlIHNvbHZlZCB1c2luZyB0aGUgRGl2aWRlLUFuZC1Db25xdWVyIHRlY2huaXF1ZS5cbiAgICAgICAgY29uc3QgbWlkT3JpZ2luYWxBcnIgPSBbMF07XG4gICAgICAgIGNvbnN0IG1pZE1vZGlmaWVkQXJyID0gWzBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLkNvbXB1dGVSZWN1cnNpb25Qb2ludChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIG1pZE9yaWdpbmFsQXJyLCBtaWRNb2RpZmllZEFyciwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgY29uc3QgbWlkT3JpZ2luYWwgPSBtaWRPcmlnaW5hbEFyclswXTtcbiAgICAgICAgY29uc3QgbWlkTW9kaWZpZWQgPSBtaWRNb2RpZmllZEFyclswXTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVzdWx0IGlzIG5vdC1udWxsIHdoZW4gdGhlcmUgd2FzIGVub3VnaCBtZW1vcnkgdG8gY29tcHV0ZSB0aGUgY2hhbmdlcyB3aGlsZVxuICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGZvciB0aGUgcmVjdXJzaW9uIHBvaW50XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBicmVhayB0aGUgcHJvYmxlbSBkb3duIHJlY3Vyc2l2ZWx5IGJ5IGZpbmRpbmcgdGhlIGNoYW5nZXMgaW4gdGhlXG4gICAgICAgICAgICAvLyBGaXJzdCBIYWxmOiAgIChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KSB0byAobWlkT3JpZ2luYWwsIG1pZE1vZGlmaWVkKVxuICAgICAgICAgICAgLy8gU2Vjb25kIEhhbGY6ICAobWlkT3JpZ2luYWwgKyAxLCBtaW5Nb2RpZmllZCArIDEpIHRvIChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXG4gICAgICAgICAgICAvLyBOT1RFOiBDb21wdXRlRGlmZigpIGlzIGluY2x1c2l2ZSwgdGhlcmVmb3JlIHRoZSBzZWNvbmQgcmFuZ2Ugc3RhcnRzIG9uIHRoZSBuZXh0IHBvaW50XG4gICAgICAgICAgICBjb25zdCBsZWZ0Q2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgbWlkT3JpZ2luYWwsIG1vZGlmaWVkU3RhcnQsIG1pZE1vZGlmaWVkLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcbiAgICAgICAgICAgICAgICByaWdodENoYW5nZXMgPSB0aGlzLkNvbXB1dGVEaWZmUmVjdXJzaXZlKG1pZE9yaWdpbmFsICsgMSwgb3JpZ2luYWxFbmQsIG1pZE1vZGlmaWVkICsgMSwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgaGF2ZSB0aW1lIHRvIGZpbmlzaCB0aGUgZmlyc3QgaGFsZiwgc28gd2UgZG9uJ3QgaGF2ZSB0aW1lIHRvIGNvbXB1dGUgdGhpcyBoYWxmLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZSBlbnRpcmUgcmVzdCBvZiB0aGUgc2VxdWVuY2UgZGlmZmVyZW50LlxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2UobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCAtIChtaWRPcmlnaW5hbCArIDEpICsgMSwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCAtIChtaWRNb2RpZmllZCArIDEpICsgMSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnRDaGFuZ2VzLCByaWdodENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhpdCBoZXJlLCB3ZSBxdWl0IGVhcmx5LCBhbmQgc28gY2FuJ3QgcmV0dXJuIGFueXRoaW5nIG1lYW5pbmdmdWxcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXG4gICAgICAgIF07XG4gICAgfVxuICAgIFdBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpIHtcbiAgICAgICAgbGV0IGZvcndhcmRDaGFuZ2VzID0gbnVsbDtcbiAgICAgICAgbGV0IHJldmVyc2VDaGFuZ2VzID0gbnVsbDtcbiAgICAgICAgLy8gRmlyc3QsIHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgZm9yd2FyZCBkaWFnb25hbHMgaGlzdG9yeVxuICAgICAgICBsZXQgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcbiAgICAgICAgbGV0IGRpYWdvbmFsTWluID0gZGlhZ29uYWxGb3J3YXJkU3RhcnQ7XG4gICAgICAgIGxldCBkaWFnb25hbE1heCA9IGRpYWdvbmFsRm9yd2FyZEVuZDtcbiAgICAgICAgbGV0IGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgIGxldCBsYXN0T3JpZ2luYWxJbmRleCA9IC0xMDczNzQxODI0IC8qIE1JTl9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIGxldCBoaXN0b3J5SW5kZXggPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXJcbiAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsRm9yd2FyZEJhc2U7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbE1pbiB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYW4gaW5zZXJ0KVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDwgbGFzdE9yaWdpbmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4KTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbilcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsIC0gMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHMgPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnlbaGlzdG9yeUluZGV4XTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbEZvcndhcmRCYXNlID0gZm9yd2FyZFBvaW50c1swXTsgLy9XZSBzdG9yZWQgdGhpcyBpbiB0aGUgZmlyc3Qgc3BvdFxuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbE1heCA9IGZvcndhcmRQb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpO1xuICAgICAgICAvLyBJcm9uaWNhbGx5LCB3ZSBnZXQgdGhlIGZvcndhcmQgY2hhbmdlcyBhcyB0aGUgcmV2ZXJzZSBvZiB0aGVcbiAgICAgICAgLy8gb3JkZXIgd2UgYWRkZWQgdGhlbSBzaW5jZSB3ZSB0ZWNobmljYWxseSBhZGRlZCB0aGVtIGJhY2t3YXJkc1xuICAgICAgICBmb3J3YXJkQ2hhbmdlcyA9IGNoYW5nZUhlbHBlci5nZXRSZXZlcnNlQ2hhbmdlcygpO1xuICAgICAgICBpZiAocXVpdEVhcmx5QXJyWzBdKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGUgYSBwYXJ0aWFsIGZyb20gdGhlIHJldmVyc2UgZGlhZ29uYWxzLlxuICAgICAgICAgICAgLy8gICAgICAgRm9yIG5vdywganVzdCBhc3N1bWUgZXZlcnl0aGluZyBhZnRlciB0aGUgbWlkT3JpZ2luYWwvbWlkTW9kaWZpZWQgcG9pbnQgaXMgYSBkaWZmXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdGFydFBvaW50ID0gbWlkT3JpZ2luYWxBcnJbMF0gKyAxO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRQb2ludCA9IG1pZE1vZGlmaWVkQXJyWzBdICsgMTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkQ2hhbmdlcyAhPT0gbnVsbCAmJiBmb3J3YXJkQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEZvcndhcmRDaGFuZ2UgPSBmb3J3YXJkQ2hhbmdlc1tmb3J3YXJkQ2hhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBNYXRoLm1heChvcmlnaW5hbFN0YXJ0UG9pbnQsIGxhc3RGb3J3YXJkQ2hhbmdlLmdldE9yaWdpbmFsRW5kKCkpO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRQb2ludCA9IE1hdGgubWF4KG1vZGlmaWVkU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0TW9kaWZpZWRFbmQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXZlcnNlQ2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0UG9pbnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydFBvaW50ICsgMSwgbW9kaWZpZWRTdGFydFBvaW50LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnRQb2ludCArIDEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm93IHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgcmV2ZXJzZSBkaWFnb25hbHMgaGlzdG9yeVxuICAgICAgICAgICAgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcbiAgICAgICAgICAgIGRpYWdvbmFsTWluID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7XG4gICAgICAgICAgICBkaWFnb25hbE1heCA9IGRpYWdvbmFsUmV2ZXJzZUVuZDtcbiAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IDEwNzM3NDE4MjQgLyogTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcbiAgICAgICAgICAgIGhpc3RvcnlJbmRleCA9IChkZWx0YUlzRXZlbikgPyB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMSA6IHRoaXMubV9yZXZlcnNlSGlzdG9yeS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlhZ29uYWwgaW5kZXggZnJvbSB0aGUgcmVsYXRpdmUgZGlhZ29uYWwgbnVtYmVyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlhZ29uYWwgPSBkaWFnb25hbFJlbGF0aXZlICsgZGlhZ29uYWxSZXZlcnNlQmFzZTtcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxNaW4gfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxNYXggJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhIGRlbGV0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE9yaWdpbmFsRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbFJldmVyc2VCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydGlvbilcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA+IGxhc3RPcmlnaW5hbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCAtIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlUG9pbnRzID0gdGhpcy5tX3JldmVyc2VIaXN0b3J5W2hpc3RvcnlJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSByZXZlcnNlUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxNYXggPSByZXZlcnNlUG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpO1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSByZXZlcnNlIGhpc3Rvcnkgd2lsbCBmaW5kIGRpZmZzIHRoYXRcbiAgICAgICAgICAgIC8vIGFyZSBjb3JyZWN0LCBidXQgbm90IGludHVpdGl2ZSwgc28gd2UgbmVlZCBzaGlmdCB0aGVtLlxuICAgICAgICAgICAgcmV2ZXJzZUNoYW5nZXMgPSBjaGFuZ2VIZWxwZXIuZ2V0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhmb3J3YXJkQ2hhbmdlcywgcmV2ZXJzZUNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UgdG8gY29tcHV0ZSB0aGUgZGlmZiBvbiwgdGhpcyBtZXRob2QgZmluZHMgdGhlIHBvaW50OlxuICAgICAqIChtaWRPcmlnaW5hbCwgbWlkTW9kaWZpZWQpXG4gICAgICogdGhhdCBleGlzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgTENTIG9mIHRoZSB0d28gc2VxdWVuY2VzIGFuZFxuICAgICAqIGlzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgTENTIHByb2JsZW0gbWF5IGJlIGJyb2tlbiBkb3duIHJlY3Vyc2l2ZWx5LlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgdHJ5IHRvIGtlZXAgdGhlIExDUyB0cmFjZSBpbiBtZW1vcnkuIElmIHRoZSBMQ1MgcmVjdXJzaW9uXG4gICAgICogcG9pbnQgaXMgY2FsY3VsYXRlZCBhbmQgdGhlIGZ1bGwgdHJhY2UgaXMgYXZhaWxhYmxlIGluIG1lbW9yeSwgdGhlbiB0aGlzIG1ldGhvZFxuICAgICAqIHdpbGwgcmV0dXJuIHRoZSBjaGFuZ2UgbGlzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxTdGFydCBUaGUgc3RhcnQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG9yaWdpbmFsRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG9yaWdpbmFsIHNlcXVlbmNlIHJhbmdlXG4gICAgICogQHBhcmFtIG1vZGlmaWVkU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtb2RpZmllZEVuZCBUaGUgZW5kIGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtaWRPcmlnaW5hbCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtaWRNb2RpZmllZCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEByZXR1cm5zIFRoZSBkaWZmIGNoYW5nZXMsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIG51bGxcbiAgICAgKi9cbiAgICBDb21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycikge1xuICAgICAgICBsZXQgb3JpZ2luYWxJbmRleCA9IDAsIG1vZGlmaWVkSW5kZXggPSAwO1xuICAgICAgICBsZXQgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSAwLCBkaWFnb25hbEZvcndhcmRFbmQgPSAwO1xuICAgICAgICBsZXQgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSAwLCBkaWFnb25hbFJldmVyc2VFbmQgPSAwO1xuICAgICAgICAvLyBUbyB0cmF2ZXJzZSB0aGUgZWRpdCBncmFwaCBhbmQgcHJvZHVjZSB0aGUgcHJvcGVyIExDUywgb3VyIGFjdHVhbFxuICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBpcyBqdXN0IG91dHNpZGUgdGhlIGdpdmVuIGJvdW5kYXJ5XG4gICAgICAgIG9yaWdpbmFsU3RhcnQtLTtcbiAgICAgICAgbW9kaWZpZWRTdGFydC0tO1xuICAgICAgICAvLyBXZSBzZXQgdGhlc2UgdXAgdG8gbWFrZSB0aGUgY29tcGlsZXIgaGFwcHksIGJ1dCB0aGV5IHdpbGxcbiAgICAgICAgLy8gYmUgcmVwbGFjZWQgYmVmb3JlIHdlIHJldHVybiB3aXRoIHRoZSBhY3R1YWwgcmVjdXJzaW9uIHBvaW50XG4gICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gMDtcbiAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSAwO1xuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGhpc3RvcnlcbiAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xuICAgICAgICAvLyBFYWNoIGNlbGwgaW4gdGhlIHR3byBhcnJheXMgY29ycmVzcG9uZHMgdG8gYSBkaWFnb25hbCBpbiB0aGUgZWRpdCBncmFwaC5cbiAgICAgICAgLy8gVGhlIGludGVnZXIgdmFsdWUgaW4gdGhlIGNlbGwgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWxJbmRleCBvZiB0aGUgZnVydGhlc3RcbiAgICAgICAgLy8gcmVhY2hpbmcgcG9pbnQgZm91bmQgc28gZmFyIHRoYXQgZW5kcyBpbiB0aGF0IGRpYWdvbmFsLlxuICAgICAgICAvLyBUaGUgbW9kaWZpZWRJbmRleCBjYW4gYmUgY29tcHV0ZWQgbWF0aGVtYXRpY2FsbHkgZnJvbSB0aGUgb3JpZ2luYWxJbmRleCBhbmQgdGhlIGRpYWdvbmFsIG51bWJlci5cbiAgICAgICAgY29uc3QgbWF4RGlmZmVyZW5jZXMgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KSArIChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xuICAgICAgICBjb25zdCBudW1EaWFnb25hbHMgPSBtYXhEaWZmZXJlbmNlcyArIDE7XG4gICAgICAgIGNvbnN0IGZvcndhcmRQb2ludHMgPSBuZXcgSW50MzJBcnJheShudW1EaWFnb25hbHMpO1xuICAgICAgICBjb25zdCByZXZlcnNlUG9pbnRzID0gbmV3IEludDMyQXJyYXkobnVtRGlhZ29uYWxzKTtcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkQmFzZTogSW5kZXggaW50byBmb3J3YXJkUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydClcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlQmFzZTogSW5kZXggaW50byByZXZlcnNlUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxuICAgICAgICBjb25zdCBkaWFnb25hbEZvcndhcmRCYXNlID0gKG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCk7XG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSAob3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXG4gICAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxGb3J3YXJkQmFzZSlcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXG4gICAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxSZXZlcnNlQmFzZSlcbiAgICAgICAgY29uc3QgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0ID0gKG9yaWdpbmFsU3RhcnQgLSBtb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgY29uc3QgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0ID0gKG9yaWdpbmFsRW5kIC0gbW9kaWZpZWRFbmQpO1xuICAgICAgICAvLyBkZWx0YTogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZW5kIGRpYWdvbmFsIGFuZCB0aGUgc3RhcnQgZGlhZ29uYWwuIFRoaXMgaXMgdXNlZCB0byByZWxhdGUgZGlhZ29uYWwgbnVtYmVyc1xuICAgICAgICAvLyAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBkaWFnb25hbCB3aXRoIGRpYWdvbmFsIG51bWJlcnMgcmVsYXRpdmUgdG8gdGhlIGVuZCBkaWFnb25hbC5cbiAgICAgICAgLy8gVGhlIEV2ZW4vT2Rkbi1uZXNzIG9mIHRoaXMgZGVsdGEgaXMgaW1wb3J0YW50IGZvciBkZXRlcm1pbmluZyB3aGVuIHdlIHNob3VsZCBjaGVjayBmb3Igb3ZlcmxhcFxuICAgICAgICBjb25zdCBkZWx0YSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbEZvcndhcmRCYXNlO1xuICAgICAgICBjb25zdCBkZWx0YUlzRXZlbiA9IChkZWx0YSAlIDIgPT09IDApO1xuICAgICAgICAvLyBIZXJlIHdlIHNldCB1cCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXMgdGhlIGZ1cnRoZXN0IHBvaW50cyBmb3VuZCBzbyBmYXJcbiAgICAgICAgLy8gaW4gYm90aCB0aGUgZm9yd2FyZCBhbmQgcmV2ZXJzZSBkaXJlY3Rpb25zLCByZXNwZWN0aXZlbHlcbiAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbEZvcndhcmRCYXNlXSA9IG9yaWdpbmFsU3RhcnQ7XG4gICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxSZXZlcnNlQmFzZV0gPSBvcmlnaW5hbEVuZDtcbiAgICAgICAgLy8gUmVtZW1iZXIgaWYgd2UgcXVpdCBlYXJseSwgYW5kIHRodXMgbmVlZCB0byBkbyBhIGJlc3QtZWZmb3J0IHJlc3VsdCBpbnN0ZWFkIG9mIGEgcmVhbCByZXN1bHQuXG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xuICAgICAgICAvLyBBIGNvdXBsZSBvZiBwb2ludHM6XG4gICAgICAgIC8vIC0tV2l0aCB0aGlzIG1ldGhvZCwgd2UgaXRlcmF0ZSBvbiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBzZXF1ZW5jZXMuXG4gICAgICAgIC8vICAgVGhlIG1vcmUgZGlmZmVyZW5jZXMgdGhlcmUgYWN0dWFsbHkgYXJlLCB0aGUgbG9uZ2VyIHRoaXMgd2lsbCB0YWtlLlxuICAgICAgICAvLyAtLUFsc28sIGFzIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXMgaW5jcmVhc2VzLCB3ZSBoYXZlIHRvIHNlYXJjaCBvbiBkaWFnb25hbHMgZnVydGhlclxuICAgICAgICAvLyAgIGF3YXkgZnJvbSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsICh3aGljaCBpcyBkaWFnb25hbEZvcndhcmRCYXNlIGZvciBmb3J3YXJkLCBkaWFnb25hbFJldmVyc2VCYXNlIGZvciByZXZlcnNlKS5cbiAgICAgICAgLy8gLS1XZSBleHRlbmQgb24gZXZlbiBkaWFnb25hbHMgKHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2UgZGlhZ29uYWwpIG9ubHkgd2hlbiBudW1EaWZmZXJlbmNlc1xuICAgICAgICAvLyAgIGlzIGV2ZW4gYW5kIG9kZCBkaWFnb25hbHMgb25seSB3aGVuIG51bURpZmZlcmVuY2VzIGlzIG9kZC5cbiAgICAgICAgZm9yIChsZXQgbnVtRGlmZmVyZW5jZXMgPSAxOyBudW1EaWZmZXJlbmNlcyA8PSAobWF4RGlmZmVyZW5jZXMgLyAyKSArIDE7IG51bURpZmZlcmVuY2VzKyspIHtcbiAgICAgICAgICAgIGxldCBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb25cbiAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbEZvcndhcmRCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEZvcndhcmRCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbEZvcndhcmRTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxGb3J3YXJkRW5kOyBkaWFnb25hbCArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxGb3J3YXJkRW5kICYmIGZvcndhcmRQb2ludHNbZGlhZ29uYWwgLSAxXSA8IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcCBpbiBzdGVwIDNcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAyOiBXZSBjYW4gY29udGludWUgdG8gZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIHNvIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkSW5kZXggPCBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ICsgbW9kaWZpZWRJbmRleCA+IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCArIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSBtb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTVEVQIDM6IElmIGRlbHRhIGlzIG9kZCAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIGZvcndhcmQgd2hlbiBkZWx0YSBpcyBvZGQpXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiByZXZlcnNlIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXMtMVxuICAgICAgICAgICAgICAgIC8vICh0aGUgcHJldmlvdXMgaXRlcmF0aW9uOyB3ZSBoYXZlbid0IGNvbXB1dGVkIHJldmVyc2UgZGlhZ29uYWxzIGZvciBudW1EaWZmZXJlbmNlcyB5ZXQpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICBpZiAoIWRlbHRhSXNFdmVuICYmIE1hdGguYWJzKGRpYWdvbmFsIC0gZGlhZ29uYWxSZXZlcnNlQmFzZSkgPD0gKG51bURpZmZlcmVuY2VzIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPj0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA8PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIGZhbHNlIG92ZXJsYXAsIG9yIHdlIGRpZG4ndCBoYXZlIGVub3VnaCBtZW1vcnkgZm9yIHRoZSBmdWxsIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBiZSBxdWl0dGluZyBlYXJseSwgYmVmb3JlIG1vdmluZyBvbiB0byB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICBjb25zdCBtYXRjaExlbmd0aE9mTG9uZ2VzdCA9ICgoZnVydGhlc3RPcmlnaW5hbEluZGV4IC0gb3JpZ2luYWxTdGFydCkgKyAoZnVydGhlc3RNb2RpZmllZEluZGV4IC0gbW9kaWZpZWRTdGFydCkgLSBudW1EaWZmZXJlbmNlcykgLyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlICE9PSBudWxsICYmICF0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZShmdXJ0aGVzdE9yaWdpbmFsSW5kZXgsIG1hdGNoTGVuZ3RoT2ZMb25nZXN0KSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGZpbmlzaCwgc28gc2tpcCBhaGVhZCB0byBnZW5lcmF0aW5nIGEgcmVzdWx0IGZyb20gd2hhdCB3ZSBoYXZlLlxuICAgICAgICAgICAgICAgIHF1aXRFYXJseUFyclswXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmdXJ0aGVzdCBkaXN0YW5jZSB3ZSBnb3QgaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gZnVydGhlc3RPcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gZnVydGhlc3RNb2RpZmllZEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaExlbmd0aE9mTG9uZ2VzdCA+IDAgJiYgMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVub3VnaCBvZiB0aGUgaGlzdG9yeSBpcyBpbiBtZW1vcnkgdG8gd2FsayBpdCBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgYWN0dWFsbHkgcmVtZW1iZXIgZW5vdWdoIG9mIHRoZSBoaXN0b3J5LlxuICAgICAgICAgICAgICAgICAgICAvL1NpbmNlIHdlIGFyZSBxdWl0dGluZyB0aGUgZGlmZiBlYXJseSwgd2UgbmVlZCB0byBzaGlmdCBiYWNrIHRoZSBvcmlnaW5hbFN0YXJ0IGFuZCBtb2RpZmllZCBzdGFydFxuICAgICAgICAgICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZGlhZ29uYWxSZXZlcnNlRW5kID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlICsgbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbFJldmVyc2VTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxSZXZlcnNlRW5kOyBkaWFnb25hbCArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYnkgbG9va2luZyBhdCB0aGUgZGlhZ29uYWxzIGFib3ZlIGFuZCBiZWxvdyBhbmQgcGlja2luZyB0aGUgb25lIHdob3NlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbEVuZCwgbW9kaWZpZWRFbmQpXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbFJldmVyc2VTdGFydCB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbFJldmVyc2VFbmQgJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgb3JpZ2luYWxJbmRleCBzbyB3ZSBjYW4gdGVzdCBmb3IgZmFsc2Ugb3ZlcmxhcFxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGUgZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbEluZGV4ID4gb3JpZ2luYWxTdGFydCAmJiBtb2RpZmllZEluZGV4ID4gbW9kaWZpZWRTdGFydCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDQ6IElmIGRlbHRhIGlzIGV2ZW4gKG92ZXJsYXAgZmlyc3QgaGFwcGVucyBvbiByZXZlcnNlIHdoZW4gZGVsdGEgaXMgZXZlbilcbiAgICAgICAgICAgICAgICAvLyBhbmQgZGlhZ29uYWwgaXMgaW4gdGhlIHJhbmdlIG9mIGZvcndhcmQgZGlhZ29uYWxzIGNvbXB1dGVkIGZvciBudW1EaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgZm9yIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhSXNFdmVuICYmIE1hdGguYWJzKGRpYWdvbmFsIC0gZGlhZ29uYWxGb3J3YXJkQmFzZSkgPD0gbnVtRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPD0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wT3JpZ2luYWxJbmRleCA+PSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsXSAmJiAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIGZhbHNlIG92ZXJsYXAsIG9yIHdlIGRpZG4ndCBoYXZlIGVub3VnaCBtZW1vcnkgZm9yIHRoZSBmdWxsIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHZlY3RvcnMgdG8gaGlzdG9yeSBiZWZvcmUgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICBpZiAobnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxsb2NhdGluZyBzcGFjZSBmb3Igb25lIGV4dHJhIGludCwgd2hpY2ggd2UgZmlsbCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSBkaWFnb25hbCBiYXNlIGluZGV4XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpO1xuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbEZvcndhcmRCYXNlIC0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgIE15QXJyYXkuQ29weTIoZm9yd2FyZFBvaW50cywgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIHRlbXAsIDEsIGRpYWdvbmFsRm9yd2FyZEVuZCAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5LnB1c2godGVtcCk7XG4gICAgICAgICAgICAgICAgdGVtcCA9IG5ldyBJbnQzMkFycmF5KGRpYWdvbmFsUmV2ZXJzZUVuZCAtIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDE7XG4gICAgICAgICAgICAgICAgTXlBcnJheS5Db3B5MihyZXZlcnNlUG9pbnRzLCBkaWFnb25hbFJldmVyc2VTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIGhpc3RvcnkuIFdlIGp1c3QgaGF2ZSB0byBjb252ZXJ0IGl0IHRvIGEgY2hhbmdlIGxpc3RcbiAgICAgICAgLy8gTk9URTogVGhpcyBwYXJ0IGlzIGEgYml0IG1lc3N5XG4gICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuXG4gICAgICogV2hpbGUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBkaWZmIG1hdGNoZXMgdGhlIGZpcnN0IGVsZW1lbnQgYWZ0ZXIgdGhlIGRpZmYsXG4gICAgICogd2Ugc2hpZnQgdGhlIGRpZmYgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBsaXN0IG9mIGNoYW5nZXMgdG8gc2hpZnRcbiAgICAgKiBAcmV0dXJucyBUaGUgc2hpZnRlZCBjaGFuZ2VzXG4gICAgICovXG4gICAgUHJldHRpZnlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gU2hpZnQgYWxsIHRoZSBjaGFuZ2VzIGRvd24gZmlyc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ub3JpZ2luYWxTdGFydCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ubW9kaWZpZWRTdGFydCA6IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tPcmlnaW5hbCA9IGNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDA7XG4gICAgICAgICAgICBjb25zdCBjaGVja01vZGlmaWVkID0gY2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHdoaWxlIChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IG9yaWdpbmFsU3RvcFxuICAgICAgICAgICAgICAgICYmIGNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoIDwgbW9kaWZpZWRTdG9wXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja09yaWdpbmFsIHx8IHRoaXMuT3JpZ2luYWxFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCkpXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja01vZGlmaWVkIHx8IHRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFN0cmljdEVxdWFsID0gdGhpcy5FbGVtZW50c0FyZVN0cmljdEVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoLCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZFN0cmljdEVxdWFsICYmICFzdGFydFN0cmljdEVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmluZyB0aGUgY2hhbmdlIGRvd24gd291bGQgY3JlYXRlIGFuIGVxdWFsIGNoYW5nZSwgYnV0IHRoZSBlbGVtZW50cyBhcmUgbm90IHN0cmljdCBlcXVhbFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgICAgICBjaGFuZ2UubW9kaWZpZWRTdGFydCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1lcmdlZENoYW5nZUFyciA9IFtudWxsXTtcbiAgICAgICAgICAgIGlmIChpIDwgY2hhbmdlcy5sZW5ndGggLSAxICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpXSwgY2hhbmdlc1tpICsgMV0sIG1lcmdlZENoYW5nZUFycikpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hpZnQgY2hhbmdlcyBiYWNrIHVwIHVudGlsIHdlIGhpdCBlbXB0eSBvciB3aGl0ZXNwYWNlLW9ubHkgbGluZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdG9wID0gMDtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZFN0b3AgPSAwO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IGNoYW5nZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RvcCA9IHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRTdG9wID0gcHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrT3JpZ2luYWwgPSBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XG4gICAgICAgICAgICBsZXQgYmVzdERlbHRhID0gMDtcbiAgICAgICAgICAgIGxldCBiZXN0U2NvcmUgPSB0aGlzLl9ib3VuZGFyeVNjb3JlKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgsIGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVsdGEgPSAxOzsgZGVsdGErKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnQgPSBjaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnQgPSBjaGFuZ2UubW9kaWZpZWRTdGFydCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgb3JpZ2luYWxTdG9wIHx8IG1vZGlmaWVkU3RhcnQgPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja09yaWdpbmFsICYmICF0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZWQgJiYgIXRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID0gKG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsU3RvcCAmJiBtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZFN0b3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gKCh0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID8gNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5fYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQgLT0gYmVzdERlbHRhO1xuICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQgLT0gYmVzdERlbHRhO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2hhbmdlQXJyID0gW251bGxdO1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpIC0gMV0sIGNoYW5nZXNbaV0sIG1lcmdlZENoYW5nZUFycikpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2kgLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgY291bGQgYmUgbXVsdGlwbGUgbG9uZ2VzdCBjb21tb24gc3Vic3RyaW5ncy5cbiAgICAgICAgLy8gR2l2ZSBwcmVmZXJlbmNlIHRvIHRoZSBvbmVzIGNvbnRhaW5pbmcgbG9uZ2VyIGxpbmVzXG4gICAgICAgIGlmICh0aGlzLl9oYXNTdHJpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFDaGFuZ2UgPSBjaGFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiQ2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkTGVuZ3RoID0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBhT3JpZ2luYWxTdGFydCA9IGFDaGFuZ2Uub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBiT3JpZ2luYWxFbmQgPSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBiQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFiT3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBhT3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBhTW9kaWZpZWRTdGFydCA9IGFDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBiTW9kaWZpZWRFbmQgPSBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBiQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFiTW9kaWZpZWRMZW5ndGggPSBiTW9kaWZpZWRFbmQgLSBhTW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB3YXN0aW5nIGEgbG90IG9mIHRpbWUgd2l0aCB0aGVzZSBzZWFyY2hlc1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkTGVuZ3RoIDwgNSAmJiBhYk9yaWdpbmFsTGVuZ3RoIDwgMjAgJiYgYWJNb2RpZmllZExlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9maW5kQmV0dGVyQ29udGlndW91c1NlcXVlbmNlKGFPcmlnaW5hbFN0YXJ0LCBhYk9yaWdpbmFsTGVuZ3RoLCBhTW9kaWZpZWRTdGFydCwgYWJNb2RpZmllZExlbmd0aCwgbWF0Y2hlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb3JpZ2luYWxNYXRjaFN0YXJ0LCBtb2RpZmllZE1hdGNoU3RhcnRdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE1hdGNoU3RhcnQgIT09IGFDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGggfHwgbW9kaWZpZWRNYXRjaFN0YXJ0ICE9PSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBhQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGFub3RoZXIgc2VxdWVuY2UgdGhhdCBoYXMgYSBiZXR0ZXIgc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gb3JpZ2luYWxNYXRjaFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSBtb2RpZmllZE1hdGNoU3RhcnQgLSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxNYXRjaFN0YXJ0ICsgbWF0Y2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgPSBtb2RpZmllZE1hdGNoU3RhcnQgKyBtYXRjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IGJNb2RpZmllZEVuZCAtIGJDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG4gICAgX2ZpbmRCZXR0ZXJDb250aWd1b3VzU2VxdWVuY2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoLCBkZXNpcmVkTGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbExlbmd0aCA8IGRlc2lyZWRMZW5ndGggfHwgbW9kaWZpZWRMZW5ndGggPCBkZXNpcmVkTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbE1heCA9IG9yaWdpbmFsU3RhcnQgKyBvcmlnaW5hbExlbmd0aCAtIGRlc2lyZWRMZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBtb2RpZmllZE1heCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aCAtIGRlc2lyZWRMZW5ndGggKyAxO1xuICAgICAgICBsZXQgYmVzdFNjb3JlID0gMDtcbiAgICAgICAgbGV0IGJlc3RPcmlnaW5hbFN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGJlc3RNb2RpZmllZFN0YXJ0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9yaWdpbmFsU3RhcnQ7IGkgPCBvcmlnaW5hbE1heDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbW9kaWZpZWRTdGFydDsgaiA8IG1vZGlmaWVkTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IHRoaXMuX2NvbnRpZ3VvdXNTZXF1ZW5jZVNjb3JlKGksIGosIGRlc2lyZWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IDAgJiYgc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RPcmlnaW5hbFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vZGlmaWVkU3RhcnQgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdFNjb3JlID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtiZXN0T3JpZ2luYWxTdGFydCwgYmVzdE1vZGlmaWVkU3RhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfY29udGlndW91c1NlcXVlbmNlU2NvcmUob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQgKyBsLCBtb2RpZmllZFN0YXJ0ICsgbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3JlICs9IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxTdGFydCArIGxdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgfVxuICAgIF9PcmlnaW5hbElzQm91bmRhcnkoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDw9IDAgfHwgaW5kZXggPj0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgJiYgL15cXHMqJC8udGVzdCh0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4XSkpO1xuICAgIH1cbiAgICBfT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmQgPSBvcmlnaW5hbFN0YXJ0ICsgb3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kIC0gMSkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX01vZGlmaWVkSXNCb3VuZGFyeShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPD0gMCB8fCBpbmRleCA+PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyAmJiAvXlxccyokLy50ZXN0KHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXhdKSk7XG4gICAgfVxuICAgIF9Nb2RpZmllZFJlZ2lvbklzQm91bmRhcnkobW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0KSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZEVuZCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQgLSAxKSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTY29yZSA9ICh0aGlzLl9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpID8gMSA6IDApO1xuICAgICAgICBjb25zdCBtb2RpZmllZFNjb3JlID0gKHRoaXMuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxTY29yZSArIG1vZGlmaWVkU2NvcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZXMgdGhlIHR3byBpbnB1dCBEaWZmQ2hhbmdlIGxpc3RzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmdcbiAgICAgKiBsaXN0LlxuICAgICAqIEBwYXJhbSBUaGUgbGVmdCBjaGFuZ2VzXG4gICAgICogQHBhcmFtIFRoZSByaWdodCBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBsaXN0XG4gICAgICovXG4gICAgQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGxldCBtZXJnZWRDaGFuZ2VBcnIgPSBbXTtcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoID09PSAwIHx8IHJpZ2h0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChyaWdodC5sZW5ndGggPiAwKSA/IHJpZ2h0IDogbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLkNoYW5nZXNPdmVybGFwKGxlZnRbbGVmdC5sZW5ndGggLSAxXSwgcmlnaHRbMF0sIG1lcmdlZENoYW5nZUFycikpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGJyZWFrIHRoZSBwcm9ibGVtIGRvd24gcmVjdXJzaXZlbHksIGl0IGlzIHBvc3NpYmxlIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIG1pZ2h0IHJlY3Vyc2UgaW4gdGhlIG1pZGRsZSBvZiBhIGNoYW5nZSB0aGVyZWJ5IHNwbGl0dGluZyBpdCBpbnRvXG4gICAgICAgICAgICAvLyB0d28gY2hhbmdlcy4gSGVyZSBpbiB0aGUgY29tYmluaW5nIHN0YWdlLCB3ZSBkZXRlY3QgYW5kIGZ1c2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgYmFjayB0b2dldGhlclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBNeUFycmF5LkNvcHkobGVmdCwgMCwgcmVzdWx0LCAwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmVzdWx0W2xlZnQubGVuZ3RoIC0gMV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XG4gICAgICAgICAgICBNeUFycmF5LkNvcHkocmlnaHQsIDEsIHJlc3VsdCwgbGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICBNeUFycmF5LkNvcHkobGVmdCwgMCwgcmVzdWx0LCAwLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICBNeUFycmF5LkNvcHkocmlnaHQsIDAsIHJlc3VsdCwgbGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGNoYW5nZXMgb3ZlcmxhcCBhbmQgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlXG4gICAgICogY2hhbmdlXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY2hhbmdlXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBjaGFuZ2VcbiAgICAgKiBAcGFyYW0gbWVyZ2VkQ2hhbmdlIFRoZSBtZXJnZWQgY2hhbmdlIGlmIHRoZSB0d28gb3ZlcmxhcCwgbnVsbCBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwXG4gICAgICovXG4gICAgQ2hhbmdlc092ZXJsYXAobGVmdCwgcmlnaHQsIG1lcmdlZENoYW5nZUFycikge1xuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5vcmlnaW5hbFN0YXJ0IDw9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5tb2RpZmllZFN0YXJ0IDw9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xuICAgICAgICBpZiAobGVmdC5vcmlnaW5hbFN0YXJ0ICsgbGVmdC5vcmlnaW5hbExlbmd0aCA+PSByaWdodC5vcmlnaW5hbFN0YXJ0IHx8IGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IGxlZnQub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbExlbmd0aCA9IGxlZnQub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0YXJ0ID0gbGVmdC5tb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkTGVuZ3RoID0gbGVmdC5tb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZWZ0Lm9yaWdpbmFsU3RhcnQgKyBsZWZ0Lm9yaWdpbmFsTGVuZ3RoID49IHJpZ2h0Lm9yaWdpbmFsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExlbmd0aCA9IHJpZ2h0Lm9yaWdpbmFsU3RhcnQgKyByaWdodC5vcmlnaW5hbExlbmd0aCAtIGxlZnQub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0Lm1vZGlmaWVkU3RhcnQgKyBsZWZ0Lm1vZGlmaWVkTGVuZ3RoID49IHJpZ2h0Lm1vZGlmaWVkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZExlbmd0aCA9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQgKyByaWdodC5tb2RpZmllZExlbmd0aCAtIGxlZnQubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZENoYW5nZUFyclswXSA9IG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZENoYW5nZUFyclswXSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB1c2VkIHRvIGNsaXAgYSBkaWFnb25hbCBpbmRleCB0byB0aGUgcmFuZ2Ugb2YgdmFsaWRcbiAgICAgKiBkaWFnb25hbHMuIFRoaXMgYWxzbyBkZWNpZGVzIHdoZXRoZXIgb3Igbm90IHRoZSBkaWFnb25hbCBpbmRleCxcbiAgICAgKiBpZiBpdCBleGNlZWRzIHRoZSBib3VuZGFyeSwgc2hvdWxkIGJlIGNsaXBwZWQgdG8gdGhlIGJvdW5kYXJ5IG9yIGNsaXBwZWRcbiAgICAgKiBvbmUgaW5zaWRlIHRoZSBib3VuZGFyeSBkZXBlbmRpbmcgb24gdGhlIEV2ZW4vT2RkIHN0YXR1cyBvZiB0aGUgYm91bmRhcnlcbiAgICAgKiBhbmQgbnVtRGlmZmVyZW5jZXMuXG4gICAgICogQHBhcmFtIGRpYWdvbmFsIFRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgdG8gY2xpcC5cbiAgICAgKiBAcGFyYW0gbnVtRGlmZmVyZW5jZXMgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJlaW5nIGl0ZXJhdGVkIHVwb24uXG4gICAgICogQHBhcmFtIGRpYWdvbmFsQmFzZUluZGV4IFRoZSBiYXNlIHJlZmVyZW5jZSBkaWFnb25hbC5cbiAgICAgKiBAcGFyYW0gbnVtRGlhZ29uYWxzIFRoZSB0b3RhbCBudW1iZXIgb2YgZGlhZ29uYWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGlwcGVkIGRpYWdvbmFsIGluZGV4LlxuICAgICAqL1xuICAgIENsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxCYXNlSW5kZXgsIG51bURpYWdvbmFscykge1xuICAgICAgICBpZiAoZGlhZ29uYWwgPj0gMCAmJiBkaWFnb25hbCA8IG51bURpYWdvbmFscykge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBjbGlwLCBpdHMgaW4gcmFuZ2VcbiAgICAgICAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaWFnb25hbHNCZWxvdzogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYmVsb3cgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxuICAgICAgICAvLyBkaWFnb25hbHNBYm92ZTogVGhlIG51bWJlciBvZiBkaWFnb25hbHMgYWJvdmUgdGhlIHJlZmVyZW5jZSBkaWFnb25hbFxuICAgICAgICBjb25zdCBkaWFnb25hbHNCZWxvdyA9IGRpYWdvbmFsQmFzZUluZGV4O1xuICAgICAgICBjb25zdCBkaWFnb25hbHNBYm92ZSA9IG51bURpYWdvbmFscyAtIGRpYWdvbmFsQmFzZUluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgZGlmZkV2ZW4gPSAobnVtRGlmZmVyZW5jZXMgJSAyID09PSAwKTtcbiAgICAgICAgaWYgKGRpYWdvbmFsIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZEV2ZW4gPSAoZGlhZ29uYWxzQmVsb3cgJSAyID09PSAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZGlmZkV2ZW4gPT09IGxvd2VyQm91bmRFdmVuKSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZEV2ZW4gPSAoZGlhZ29uYWxzQWJvdmUgJSAyID09PSAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZGlmZkV2ZW4gPT09IHVwcGVyQm91bmRFdmVuKSA/IG51bURpYWdvbmFscyAtIDEgOiBudW1EaWFnb25hbHMgLSAyO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIFJlcHJlc2VudHMgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHNlcXVlbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIERpZmZDaGFuZ2Uge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZSB3aXRoIHRoZSBnaXZlbiBzZXF1ZW5jZSBpbmZvcm1hdGlvblxuICAgICAqIGFuZCBjb250ZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xuICAgICAgICAvL0RlYnVnLkFzc2VydChvcmlnaW5hbExlbmd0aCA+IDAgfHwgbW9kaWZpZWRMZW5ndGggPiAwLCBcIm9yaWdpbmFsTGVuZ3RoIGFuZCBtb2RpZmllZExlbmd0aCBjYW5ub3QgYm90aCBiZSA8PSAwXCIpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnQgPSBvcmlnaW5hbFN0YXJ0O1xuICAgICAgICB0aGlzLm9yaWdpbmFsTGVuZ3RoID0gb3JpZ2luYWxMZW5ndGg7XG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydCA9IG1vZGlmaWVkU3RhcnQ7XG4gICAgICAgIHRoaXMubW9kaWZpZWRMZW5ndGggPSBtb2RpZmllZExlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVuZCBwb2ludCAoZXhjbHVzaXZlKSBvZiB0aGUgY2hhbmdlIGluIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxTdGFydCArIHRoaXMub3JpZ2luYWxMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSkgb2YgdGhlIGNoYW5nZSBpbiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgZ2V0TW9kaWZpZWRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVkU3RhcnQgKyB0aGlzLm1vZGlmaWVkTGVuZ3RoO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gQXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBvbiBFdmVudEVtaXR0ZXIgYnkgaW1wbGVtZW50aW5nIGEgc3Vic2V0IG9mIHRoZSBpbnRlcmZhY2UuXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVtaXQoZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblVuZXhwZWN0ZWRFcnJvcihlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgdGhpcy5lbWl0KGUpO1xuICAgIH1cbiAgICAvLyBGb3IgZXh0ZXJuYWwgZXJyb3JzLCB3ZSBkb24ndCB3YW50IHRoZSBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkXG4gICAgb25VbmV4cGVjdGVkRXh0ZXJuYWxFcnJvcihlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc0NhbmNlbGxhdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFcnJvcihlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc0NhbmNlbGxhdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxldCB7IG5hbWUsIG1lc3NhZ2UgfSA9IGVycm9yO1xuICAgICAgICBjb25zdCBzdGFjayA9IGVycm9yLnN0YWNrdHJhY2UgfHwgZXJyb3Iuc3RhY2s7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGFzIGlzXG4gICAgcmV0dXJuIGVycm9yO1xufVxuY29uc3QgY2FuY2VsZWROYW1lID0gJ0NhbmNlbGVkJztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxsYXRpb25FcnJvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gY2FuY2VsZWROYW1lICYmIGVycm9yLm1lc3NhZ2UgPT09IGNhbmNlbGVkTmFtZTtcbn1cbi8vICEhIUlNUE9SVEFOVCEhIVxuLy8gRG8gTk9UIGNoYW5nZSB0aGlzIGNsYXNzIGJlY2F1c2UgaXQgaXMgYWxzbyB1c2VkIGFzIGFuIEFQSS10eXBlLlxuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihjYW5jZWxlZE5hbWUpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIENhbmNlbGxhdGlvbkVycm9yIGBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKWB9IGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbGVkKCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNhbmNlbGVkTmFtZSk7XG4gICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxBcmd1bWVudChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBhcmd1bWVudDogJHtuYW1lfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBhcmd1bWVudCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbGxlZ2FsU3RhdGUobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElsbGVnYWwgc3RhdGU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgc3RhdGUnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcignTm90U3VwcG9ydGVkJyk7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBjb21iaW5lZERpc3Bvc2FibGUsIERpc3Bvc2FibGUsIERpc3Bvc2FibGVTdG9yZSwgU2FmZURpc3Bvc2FibGUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpbmtlZExpc3QuanMnO1xuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi9zdG9wd2F0Y2guanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGFuIGVtaXR0ZXIgd2l0aCBsaXN0ZW5lcnMgaXMgZGlzcG9zZWQuIFRoYXQgaXMgYSBzaWduIG9mIGNvZGUgc21lbGwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IF9lbmFibGVEaXNwb3NlV2l0aExpc3RlbmVyV2FybmluZyA9IGZhbHNlO1xuLy8gX2VuYWJsZURpc3Bvc2VXaXRoTGlzdGVuZXJXYXJuaW5nID0gQm9vbGVhbihcIlRSVUVcIik7IC8vIGNhdXNlcyBhIGxpbnRlciB3YXJuaW5nIHNvIHRoYXQgaXQgY2Fubm90IGJlIHB1c2hlZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgc25hcHNob3R0ZWQgZXZlbnQgaXMgdXNlZCByZXBlYXRlZGx5IHdpdGhvdXQgY2xlYW51cC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTQyODUxXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IF9lbmFibGVTbmFwc2hvdFBvdGVudGlhbExlYWtXYXJuaW5nID0gZmFsc2U7XG5leHBvcnQgdmFyIEV2ZW50O1xuKGZ1bmN0aW9uIChFdmVudCkge1xuICAgIEV2ZW50Lk5vbmUgPSAoKSA9PiBEaXNwb3NhYmxlLk5vbmU7XG4gICAgZnVuY3Rpb24gX2FkZExlYWthZ2VUcmFjZUxvZ2ljKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKF9lbmFibGVTbmFwc2hvdFBvdGVudGlhbExlYWtXYXJuaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uTGlzdGVuZXJEaWRBZGQ6IG9yaWdMaXN0ZW5lckRpZEFkZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gU3RhY2t0cmFjZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLm9uTGlzdGVuZXJEaWRBZGQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzbmFwc2hvdHRlZCBlbWl0dGVyIExJS0VMWSB1c2VkIHB1YmxpYyBhbmQgU0hPVUxEIEhBVkUgQkVFTiBjcmVhdGVkIHdpdGggRGlzcG9zYWJsZVN0b3JlLiBzbmFwc2hvdHRlZCBoZXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnByaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yaWdMaXN0ZW5lckRpZEFkZCA9PT0gbnVsbCB8fCBvcmlnTGlzdGVuZXJEaWRBZGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdMaXN0ZW5lckRpZEFkZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyBhbm90aGVyIGV2ZW50IHdoaWNoIG9ubHkgZmlyZXMgb25jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcywgaW4gY2FzZSB0aGUgZXZlbnQgZmlyZXMgZHVyaW5nIHRoZSBsaXN0ZW5lciBjYWxsXG4gICAgICAgICAgICBsZXQgZGlkRmlyZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50KGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaWRGaXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaWRGaXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGUpO1xuICAgICAgICAgICAgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICAgICAgaWYgKGRpZEZpcmUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRXZlbnQub25jZSA9IG9uY2U7XG4gICAgLyoqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChldmVudCwgbWFwLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdCgobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IGV2ZW50KGkgPT4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgbWFwKGkpKSwgbnVsbCwgZGlzcG9zYWJsZXMpLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQubWFwID0gbWFwO1xuICAgIC8qKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGV2ZW50LCBlYWNoLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdCgobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IGV2ZW50KGkgPT4geyBlYWNoKGkpOyBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBpKTsgfSwgbnVsbCwgZGlzcG9zYWJsZXMpLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQuZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgZnVuY3Rpb24gZmlsdGVyKGV2ZW50LCBmaWx0ZXIsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoZSA9PiBmaWx0ZXIoZSkgJiYgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSksIG51bGwsIGRpc3Bvc2FibGVzKSwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmZpbHRlciA9IGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyB0aGUgc2FtZSBldmVudCBidXQgdHlwZWQgYXMgYEV2ZW50PHZvaWQ+YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduYWwoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5zaWduYWwgPSBzaWduYWw7XG4gICAgZnVuY3Rpb24gYW55KC4uLmV2ZW50cykge1xuICAgICAgICByZXR1cm4gKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBjb21iaW5lZERpc3Bvc2FibGUoLi4uZXZlbnRzLm1hcChldmVudCA9PiBldmVudChlID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGUpLCBudWxsLCBkaXNwb3NhYmxlcykpKTtcbiAgICB9XG4gICAgRXZlbnQuYW55ID0gYW55O1xuICAgIC8qKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoZXZlbnQsIG1lcmdlLCBpbml0aWFsLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBpbml0aWFsO1xuICAgICAgICByZXR1cm4gbWFwKGV2ZW50LCBlID0+IHtcbiAgICAgICAgICAgIG91dHB1dCA9IG1lcmdlKG91dHB1dCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQucmVkdWNlID0gcmVkdWNlO1xuICAgIGZ1bmN0aW9uIHNuYXBzaG90KGV2ZW50LCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckFkZCgpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGVtaXR0ZXIuZmlyZSwgZW1pdHRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25MYXN0TGlzdGVuZXJSZW1vdmUoKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIob3B0aW9ucyk7XG4gICAgICAgIGlmIChkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmFkZChlbWl0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZXZlbnQsIG1lcmdlLCBkZWxheSA9IDEwMCwgbGVhZGluZyA9IGZhbHNlLCBsZWFrV2FybmluZ1RocmVzaG9sZCwgZGlzcG9zYWJsZSkge1xuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbnVtRGVib3VuY2VkQ2FsbHMgPSAwO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbGVha1dhcm5pbmdUaHJlc2hvbGQsXG4gICAgICAgICAgICBvbkZpcnN0TGlzdGVuZXJBZGQoKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gZXZlbnQoY3VyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbnVtRGVib3VuY2VkQ2FsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBjdXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVhZGluZyAmJiAhaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nIHx8IG51bURlYm91bmNlZENhbGxzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShfb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgX2FkZExlYWthZ2VUcmFjZUxvZ2ljKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcihvcHRpb25zKTtcbiAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuYWRkKGVtaXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIC8qKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXRjaChldmVudCwgZXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IGZpcnN0Q2FsbCA9IHRydWU7XG4gICAgICAgIGxldCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihldmVudCwgdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IGZpcnN0Q2FsbCB8fCAhZXF1YWxzKHZhbHVlLCBjYWNoZSk7XG4gICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhY2hlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkRW1pdDtcbiAgICAgICAgfSwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmxhdGNoID0gbGF0Y2g7XG4gICAgLyoqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KGV2ZW50LCBpc1QsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEV2ZW50LmZpbHRlcihldmVudCwgaXNULCBkaXNwb3NhYmxlKSxcbiAgICAgICAgICAgIEV2ZW50LmZpbHRlcihldmVudCwgZSA9PiAhaXNUKGUpLCBkaXNwb3NhYmxlKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgRXZlbnQuc3BsaXQgPSBzcGxpdDtcbiAgICAvKipcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVmZmVyKGV2ZW50LCBmbHVzaEFmdGVyVGltZW91dCA9IGZhbHNlLCBfYnVmZmVyID0gW10pIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IF9idWZmZXIuc2xpY2UoKTtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZXZlbnQoZSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuZm9yRWFjaChlID0+IGVtaXR0ZXIuZmlyZShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyQWRkKCkge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBldmVudChlID0+IGVtaXR0ZXIuZmlyZShlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckRpZEFkZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbHVzaEFmdGVyVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5idWZmZXIgPSBidWZmZXI7XG4gICAgY2xhc3MgQ2hhaW5hYmxlRXZlbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIG1hcChmbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChtYXAodGhpcy5ldmVudCwgZm4pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGZvckVhY2godGhpcy5ldmVudCwgZm4pKTtcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXIoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5hYmxlRXZlbnQoZmlsdGVyKHRoaXMuZXZlbnQsIGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkdWNlKG1lcmdlLCBpbml0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KHJlZHVjZSh0aGlzLmV2ZW50LCBtZXJnZSwgaW5pdGlhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGxhdGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChsYXRjaCh0aGlzLmV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVib3VuY2UobWVyZ2UsIGRlbGF5ID0gMTAwLCBsZWFkaW5nID0gZmFsc2UsIGxlYWtXYXJuaW5nVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGRlYm91bmNlKHRoaXMuZXZlbnQsIG1lcmdlLCBkZWxheSwgbGVhZGluZywgbGVha1dhcm5pbmdUaHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgICAgICBvbihsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBvbmNlKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBvbmNlKHRoaXMuZXZlbnQpKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERPIE5PVCB1c2UsIHRoaXMgbGVha3MgbWVtb3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChldmVudCk7XG4gICAgfVxuICAgIEV2ZW50LmNoYWluID0gY2hhaW47XG4gICAgZnVuY3Rpb24gZnJvbU5vZGVFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXZlbnROYW1lLCBtYXAgPSBpZCA9PiBpZCkge1xuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xuICAgICAgICBjb25zdCBvbkZpcnN0TGlzdGVuZXJBZGQgPSAoKSA9PiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBmbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKHsgb25GaXJzdExpc3RlbmVyQWRkLCBvbkxhc3RMaXN0ZW5lclJlbW92ZSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcbiAgICB9XG4gICAgRXZlbnQuZnJvbU5vZGVFdmVudEVtaXR0ZXIgPSBmcm9tTm9kZUV2ZW50RW1pdHRlcjtcbiAgICBmdW5jdGlvbiBmcm9tRE9NRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4gcmVzdWx0LmZpcmUobWFwKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3Qgb25GaXJzdExpc3RlbmVyQWRkID0gKCkgPT4gZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVtaXR0ZXIoeyBvbkZpcnN0TGlzdGVuZXJBZGQsIG9uTGFzdExpc3RlbmVyUmVtb3ZlIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5mcm9tRE9NRXZlbnRFbWl0dGVyID0gZnJvbURPTUV2ZW50RW1pdHRlcjtcbiAgICBmdW5jdGlvbiB0b1Byb21pc2UoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gb25jZShldmVudCkocmVzb2x2ZSkpO1xuICAgIH1cbiAgICBFdmVudC50b1Byb21pc2UgPSB0b1Byb21pc2U7XG4gICAgZnVuY3Rpb24gcnVuQW5kU3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50KGUgPT4gaGFuZGxlcihlKSk7XG4gICAgfVxuICAgIEV2ZW50LnJ1bkFuZFN1YnNjcmliZSA9IHJ1bkFuZFN1YnNjcmliZTtcbiAgICBmdW5jdGlvbiBydW5BbmRTdWJzY3JpYmVXaXRoU3RvcmUoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHN0b3JlID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gcnVuKGUpIHtcbiAgICAgICAgICAgIHN0b3JlID09PSBudWxsIHx8IHN0b3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9yZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdG9yZSA9IG5ldyBEaXNwb3NhYmxlU3RvcmUoKTtcbiAgICAgICAgICAgIGhhbmRsZXIoZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bih1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBkaXNwb3NhYmxlID0gZXZlbnQoZSA9PiBydW4oZSkpO1xuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3RvcmUgPT09IG51bGwgfHwgc3RvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3JlLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEV2ZW50LnJ1bkFuZFN1YnNjcmliZVdpdGhTdG9yZSA9IHJ1bkFuZFN1YnNjcmliZVdpdGhTdG9yZTtcbn0pKEV2ZW50IHx8IChFdmVudCA9IHt9KSk7XG5jbGFzcyBFdmVudFByb2ZpbGluZyB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lckNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5faW52b2NhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fZWxhcHNlZE92ZXJhbGwgPSAwO1xuICAgICAgICB0aGlzLl9uYW1lID0gYCR7bmFtZX1fJHtFdmVudFByb2ZpbGluZy5faWRQb29sKyt9YDtcbiAgICB9XG4gICAgc3RhcnQobGlzdGVuZXJDb3VudCkge1xuICAgICAgICB0aGlzLl9zdG9wV2F0Y2ggPSBuZXcgU3RvcFdhdGNoKHRydWUpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BXYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuX3N0b3BXYXRjaC5lbGFwc2VkKCk7XG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkT3ZlcmFsbCArPSBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5faW52b2NhdGlvbkNvdW50ICs9IDE7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oYGRpZCBGSVJFICR7dGhpcy5fbmFtZX06IGVsYXBzZWRfbXM6ICR7ZWxhcHNlZC50b0ZpeGVkKDUpfSwgbGlzdGVuZXI6ICR7dGhpcy5fbGlzdGVuZXJDb3VudH0gKGVsYXBzZWRfb3ZlcmFsbDogJHt0aGlzLl9lbGFwc2VkT3ZlcmFsbC50b0ZpeGVkKDIpfSwgaW52b2NhdGlvbnM6ICR7dGhpcy5faW52b2NhdGlvbkNvdW50fSlgKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkV2ZW50UHJvZmlsaW5nLl9pZFBvb2wgPSAwO1xubGV0IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZCA9IC0xO1xuY2xhc3MgTGVha2FnZU1vbml0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGN1c3RvbVRocmVzaG9sZCwgbmFtZSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTgpLnNsaWNlKDIsIDUpKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tVGhyZXNob2xkID0gY3VzdG9tVGhyZXNob2xkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl93YXJuQ291bnRkb3duID0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrcykge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2tzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2soc3RhY2ssIGxpc3RlbmVyQ291bnQpIHtcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmN1c3RvbVRocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IHRoaXMuY3VzdG9tVGhyZXNob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPD0gMCB8fCBsaXN0ZW5lckNvdW50IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fc3RhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSAodGhpcy5fc3RhY2tzLmdldChzdGFjay52YWx1ZSkgfHwgMCk7XG4gICAgICAgIHRoaXMuX3N0YWNrcy5zZXQoc3RhY2sudmFsdWUsIGNvdW50ICsgMSk7XG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX3dhcm5Db3VudGRvd24gPD0gMCkge1xuICAgICAgICAgICAgLy8gb25seSB3YXJuIG9uIGZpcnN0IGV4Y2VlZCBhbmQgdGhlbiBldmVyeSB0aW1lIHRoZSBsaW1pdFxuICAgICAgICAgICAgLy8gaXMgZXhjZWVkZWQgYnkgNTAlIGFnYWluXG4gICAgICAgICAgICB0aGlzLl93YXJuQ291bnRkb3duID0gdGhyZXNob2xkICogMC41O1xuICAgICAgICAgICAgLy8gZmluZCBtb3N0IGZyZXF1ZW50IGxpc3RlbmVyIGFuZCBwcmludCB3YXJuaW5nXG4gICAgICAgICAgICBsZXQgdG9wU3RhY2s7XG4gICAgICAgICAgICBsZXQgdG9wQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbc3RhY2ssIGNvdW50XSBvZiB0aGlzLl9zdGFja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcFN0YWNrIHx8IHRvcENvdW50IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wU3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdG9wQ291bnQgPSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFske3RoaXMubmFtZX1dIHBvdGVudGlhbCBsaXN0ZW5lciBMRUFLIGRldGVjdGVkLCBoYXZpbmcgJHtsaXN0ZW5lckNvdW50fSBsaXN0ZW5lcnMgYWxyZWFkeS4gTU9TVCBmcmVxdWVudCBsaXN0ZW5lciAoJHt0b3BDb3VudH0pOmApO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRvcFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSAodGhpcy5fc3RhY2tzLmdldChzdGFjay52YWx1ZSkgfHwgMCk7XG4gICAgICAgICAgICB0aGlzLl9zdGFja3Muc2V0KHN0YWNrLnZhbHVlLCBjb3VudCAtIDEpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrdHJhY2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrdHJhY2UoKF9hID0gbmV3IEVycm9yKCkuc3RhY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICB9XG4gICAgcHJpbnQoKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnZhbHVlLnNwbGl0KCdcXG4nKS5zbGljZSgyKS5qb2luKCdcXG4nKSk7XG4gICAgfVxufVxuY2xhc3MgTGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBjYWxsYmFja1RoaXMsIHN0YWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5jYWxsYmFja1RoaXMgPSBjYWxsYmFja1RoaXM7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU2FmZURpc3Bvc2FibGUoKTtcbiAgICB9XG4gICAgaW52b2tlKGUpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuY2FsbGJhY2tUaGlzLCBlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBFbWl0dGVyIGNhbiBiZSB1c2VkIHRvIGV4cG9zZSBhbiBFdmVudCB0byB0aGUgcHVibGljXG4gKiB0byBmaXJlIGl0IGZyb20gdGhlIGluc2lkZXMuXG4gKiBTYW1wbGU6XG4gICAgY2xhc3MgRG9jdW1lbnQge1xuXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX29uRGlkQ2hhbmdlID0gbmV3IEVtaXR0ZXI8KHZhbHVlOnN0cmluZyk9PmFueT4oKTtcblxuICAgICAgICBwdWJsaWMgb25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcblxuICAgICAgICAvLyBnZXR0ZXItc3R5bGVcbiAgICAgICAgLy8gZ2V0IG9uRGlkQ2hhbmdlKCk6IEV2ZW50PCh2YWx1ZTpzdHJpbmcpPT5hbnk+IHtcbiAgICAgICAgLy8gXHRyZXR1cm4gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBwcml2YXRlIF9kb0l0KCkge1xuICAgICAgICAgICAgLy8uLi5cbiAgICAgICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICovXG5leHBvcnQgY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9sZWFrYWdlTW9uID0gX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkID4gMCA/IG5ldyBMZWFrYWdlTW9uaXRvcih0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMubGVha1dhcm5pbmdUaHJlc2hvbGQpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wZXJmTW9uID0gKChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJvZk5hbWUpID8gbmV3IEV2ZW50UHJvZmlsaW5nKHRoaXMuX29wdGlvbnMuX3Byb2ZOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBJdCBpcyBiYWQgdG8gaGF2ZSBsaXN0ZW5lcnMgYXQgdGhlIHRpbWUgb2YgZGlzcG9zaW5nIGFuIGVtaXR0ZXIsIGl0IGlzIHdvcnN0IHRvIGhhdmUgbGlzdGVuZXJzIGtlZXAgdGhlIGVtaXR0ZXJcbiAgICAgICAgICAgIC8vIGFsaXZlIHZpYSB0aGUgcmVmZXJlbmNlIHRoYXQncyBlbWJlZGRlZCBpbiB0aGVpciBkaXNwb3NhYmxlcy4gVGhlcmVmb3JlIHdlIGxvb3Agb3ZlciBhbGwgcmVtYWluaW5nIGxpc3RlbmVycyBhbmRcbiAgICAgICAgICAgIC8vIHVuc2V0IHRoZWlyIHN1YnNjcmlwdGlvbnMvZGlzcG9zYWJsZXMuIExvb3BpbmcgYW5kIGJsYW1pbmcgcmVtYWluaW5nIGxpc3RlbmVycyBpcyBkb25lIG9uIG5leHQgdGljayBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9ncmFtbWluZyBwYXR0ZXJuIGlzIHZlcnkgcG9wdWxhcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb25zdCBzb21lTW9kZWwgPSB0aGlzLl9kaXNwb3NhYmxlcy5hZGQobmV3IE1vZGVsT2JqZWN0KCkpOyAvLyAoMSkgY3JlYXRlIGFuZCByZWdpc3RlciBtb2RlbFxuICAgICAgICAgICAgLy8gdGhpcy5fZGlzcG9zYWJsZXMuYWRkKHNvbWVNb2RlbC5vbkRpZENoYW5nZSgoKSA9PiB7IC4uLiB9KTsgLy8gKDIpIHN1YnNjcmliZSBhbmQgcmVnaXN0ZXIgbW9kZWwtZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIC8vIC4uLmxhdGVyLi4uXG4gICAgICAgICAgICAvLyB0aGlzLl9kaXNwb3NhYmxlcy5kaXNwb3NlKCk7IGRpc3Bvc2VzICgxKSB0aGVuICgyKTogZG9uJ3Qgd2FybiBhZnRlciAoMSkgYnV0IGFmdGVyIHRoZSBcIm92ZXJhbGwgZGlzcG9zZVwiIGlzIGRvbmVcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2VuYWJsZURpc3Bvc2VXaXRoTGlzdGVuZXJXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20odGhpcy5fbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIuc3Vic2NyaXB0aW9uLmlzc2V0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuc3Vic2NyaXB0aW9uLnVuc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuX2RlbGl2ZXJ5UXVldWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICAgICAgKF9jID0gKF9iID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uTGFzdExpc3RlbmVyUmVtb3ZlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYik7XG4gICAgICAgICAgICAoX2QgPSB0aGlzLl9sZWFrYWdlTW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxuICAgICAqL1xuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAoY2FsbGJhY2ssIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMuaXNFbXB0eSgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdExpc3RlbmVyICYmICgoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25GaXJzdExpc3RlbmVyQWRkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlbW92ZU1vbml0b3I7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZWFrYWdlTW9uICYmIHRoaXMuX2xpc3RlbmVycy5zaXplID49IDMwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFuZCByZWNvcmQgdGhpcyBlbWl0dGVyIGZvciBwb3RlbnRpYWwgbGVha2FnZVxuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IFN0YWNrdHJhY2UuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3IgPSB0aGlzLl9sZWFrYWdlTW9uLmNoZWNrKHN0YWNrLCB0aGlzLl9saXN0ZW5lcnMuc2l6ZSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2VuYWJsZURpc3Bvc2VXaXRoTGlzdGVuZXJXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2sgIT09IG51bGwgJiYgc3RhY2sgIT09IHZvaWQgMCA/IHN0YWNrIDogU3RhY2t0cmFjZS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgTGlzdGVuZXIoY2FsbGJhY2ssIHRoaXNBcmdzLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TGlzdGVuZXIgJiYgKChfYiA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkZpcnN0TGlzdGVuZXJEaWRBZGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyRGlkQWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF9jID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm9uTGlzdGVuZXJEaWRBZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxpc3RlbmVyRGlkQWRkKHRoaXMsIGNhbGxiYWNrLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGxpc3RlbmVyLnN1YnNjcmlwdGlvbi5zZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlTW9uaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTW9uaXRvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTGlzdGVuZXJzID0gKHRoaXMuX2xpc3RlbmVycyAmJiAhdGhpcy5fbGlzdGVuZXJzLmlzRW1wdHkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zYWJsZXMgaW5zdGFuY2VvZiBEaXNwb3NhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGlzcG9zYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBwdXQgYWxsIFtsaXN0ZW5lcixldmVudF0tcGFpcnMgaW50byBkZWxpdmVyeSBxdWV1ZVxuICAgICAgICAgICAgLy8gdGhlbiBlbWl0IGFsbCBldmVudC4gYW4gaW5uZXIvbmVzdGVkIGV2ZW50IG1pZ2h0IGJlXG4gICAgICAgICAgICAvLyB0aGUgZHJpdmVyIG9mIHRoaXNcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVsaXZlcnlRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5wdXNoKFtsaXN0ZW5lciwgZXZlbnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0YXJ0L3N0b3AgcGVyZm9ybWFuY2UgaW5zaWdodCBjb2xsZWN0aW9uXG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQodGhpcy5fZGVsaXZlcnlRdWV1ZS5zaXplKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9kZWxpdmVyeVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xpc3RlbmVyLCBldmVudF0gPSB0aGlzLl9kZWxpdmVyeVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuaW52b2tlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy5fcGVyZk1vbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYXVzZWFibGVFbWl0dGVyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSAwO1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy5fbWVyZ2VGbiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXJnZTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkKys7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkICE9PSAwICYmIC0tdGhpcy5faXNQYXVzZWQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXJnZUZuKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBtZXJnZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBzaW5nbGUgY29tcG9zaXRlXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQuIG1ha2UgYSBjb3B5IGluIGNhc2UgZmlyaW5nIHBhdXNlcyB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBBcnJheS5mcm9tKHRoaXMuX2V2ZW50UXVldWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX21lcmdlRm4oZXZlbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBtZXJnaW5nLCBmaXJlIGVhY2ggZXZlbnQgaW5kaXZpZHVhbGx5IGFuZCB0ZXN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGVtaXR0ZXIgaXNuJ3QgcGF1c2VkIGhhbGZ3YXkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHdoaWxlICghdGhpcy5faXNQYXVzZWQgJiYgdGhpcy5fZXZlbnRRdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmZpcmUodGhpcy5fZXZlbnRRdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuZmlyZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVib3VuY2VFbWl0dGVyIGV4dGVuZHMgUGF1c2VhYmxlRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kZWxheSA9IChfYSA9IG9wdGlvbnMuZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMDtcbiAgICB9XG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB9LCB0aGlzLl9kZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZmlyZShldmVudCk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgRXZlbnRCdWZmZXJlciBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyBpbiB3aGljaCB5b3Ugd2FudFxuICogdG8gZGVsYXkgZmlyaW5nIHlvdXIgZXZlbnRzIGR1cmluZyBzb21lIGNvZGUuXG4gKiBZb3UgY2FuIHdyYXAgdGhhdCBjb2RlIGFuZCBiZSBzdXJlIHRoYXQgdGhlIGV2ZW50IHdpbGwgbm90XG4gKiBiZSBmaXJlZCBkdXJpbmcgdGhhdCB3cmFwLlxuICpcbiAqIGBgYFxuICogY29uc3QgZW1pdHRlcjogRW1pdHRlcjtcbiAqIGNvbnN0IGRlbGF5ZXIgPSBuZXcgRXZlbnREZWxheWVyKCk7XG4gKiBjb25zdCBkZWxheWVkRXZlbnQgPSBkZWxheWVyLndyYXBFdmVudChlbWl0dGVyLmV2ZW50KTtcbiAqXG4gKiBkZWxheWVkRXZlbnQoY29uc29sZS5sb2cpO1xuICpcbiAqIGRlbGF5ZXIuYnVmZmVyRXZlbnRzKCgpID0+IHtcbiAqICAgZW1pdHRlci5maXJlKCk7IC8vIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIHlldFxuICogfSk7XG4gKlxuICogLy8gZXZlbnQgd2lsbCBvbmx5IGJlIGZpcmVkIGF0IHRoaXMgcG9pbnRcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRCdWZmZXJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIH1cbiAgICB3cmFwRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQoaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW3RoaXMuYnVmZmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKCgpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBidWZmZXJFdmVudHMoZm4pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHIgPSBmbigpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucG9wKCk7XG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKGZsdXNoID0+IGZsdXNoKCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG59XG4vKipcbiAqIEEgUmVsYXkgaXMgYW4gZXZlbnQgZm9yd2FyZGVyIHdoaWNoIGZ1bmN0aW9ucyBhcyBhIHJlcGx1Z2FiYmxlIGV2ZW50IHBpcGUuXG4gKiBPbmNlIGNyZWF0ZWQsIHlvdSBjYW4gY29ubmVjdCBhbiBpbnB1dCBldmVudCB0byBpdCBhbmQgaXQgd2lsbCBzaW1wbHkgZm9yd2FyZFxuICogZXZlbnRzIGZyb20gdGhhdCBpbnB1dCBldmVudCB0aHJvdWdoIGl0cyBvd24gYGV2ZW50YCBwcm9wZXJ0eS4gVGhlIGBpbnB1dGBcbiAqIGNhbiBiZSBjaGFuZ2VkIGF0IGFueSBwb2ludCBpbiB0aW1lLlxuICovXG5leHBvcnQgY2xhc3MgUmVsYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlucHV0RXZlbnQgPSBFdmVudC5Ob25lO1xuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IERpc3Bvc2FibGUuTm9uZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyRGlkQWRkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gdGhpcy5pbnB1dEV2ZW50KHRoaXMuZW1pdHRlci5maXJlLCB0aGlzLmVtaXR0ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50ID0gdGhpcy5lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBzZXQgaW5wdXQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSBldmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBsZXQgZGlkQ2FsbCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRpZENhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi9zdHJpbmdzLmpzJztcbi8qKlxuICogUmV0dXJuIGEgaGFzaCB2YWx1ZSBmb3IgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChvYmopIHtcbiAgICByZXR1cm4gZG9IYXNoKG9iaiwgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG9IYXNoKG9iaiwgaGFzaFZhbCkge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDM0OSwgaGFzaFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlIYXNoKG9iaiwgaGFzaFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0SGFzaChvYmosIGhhc2hWYWwpO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0hhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbkhhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKG9iaiwgaGFzaFZhbCk7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg5MzcsIGhhc2hWYWwpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2goNjE3LCBoYXNoVmFsKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVySGFzaCh2YWwsIGluaXRpYWxIYXNoVmFsKSB7XG4gICAgcmV0dXJuICgoKGluaXRpYWxIYXNoVmFsIDw8IDUpIC0gaW5pdGlhbEhhc2hWYWwpICsgdmFsKSB8IDA7IC8vIGhhc2hWYWwgKiAzMSArIGNoLCBrZWVwIGFzIGludDMyXG59XG5mdW5jdGlvbiBib29sZWFuSGFzaChiLCBpbml0aWFsSGFzaFZhbCkge1xuICAgIHJldHVybiBudW1iZXJIYXNoKGIgPyA0MzMgOiA4NjMsIGluaXRpYWxIYXNoVmFsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdIYXNoKHMsIGhhc2hWYWwpIHtcbiAgICBoYXNoVmFsID0gbnVtYmVySGFzaCgxNDk0MTcsIGhhc2hWYWwpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKHMuY2hhckNvZGVBdChpKSwgaGFzaFZhbCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoVmFsO1xufVxuZnVuY3Rpb24gYXJyYXlIYXNoKGFyciwgaW5pdGlhbEhhc2hWYWwpIHtcbiAgICBpbml0aWFsSGFzaFZhbCA9IG51bWJlckhhc2goMTA0NTc5LCBpbml0aWFsSGFzaFZhbCk7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGhhc2hWYWwsIGl0ZW0pID0+IGRvSGFzaChpdGVtLCBoYXNoVmFsKSwgaW5pdGlhbEhhc2hWYWwpO1xufVxuZnVuY3Rpb24gb2JqZWN0SGFzaChvYmosIGluaXRpYWxIYXNoVmFsKSB7XG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDE4MTM4NywgaW5pdGlhbEhhc2hWYWwpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5yZWR1Y2UoKGhhc2hWYWwsIGtleSkgPT4ge1xuICAgICAgICBoYXNoVmFsID0gc3RyaW5nSGFzaChrZXksIGhhc2hWYWwpO1xuICAgICAgICByZXR1cm4gZG9IYXNoKG9ialtrZXldLCBoYXNoVmFsKTtcbiAgICB9LCBpbml0aWFsSGFzaFZhbCk7XG59XG5mdW5jdGlvbiBsZWZ0Um90YXRlKHZhbHVlLCBiaXRzLCB0b3RhbEJpdHMgPSAzMikge1xuICAgIC8vIGRlbHRhICsgYml0cyA9IHRvdGFsQml0c1xuICAgIGNvbnN0IGRlbHRhID0gdG90YWxCaXRzIC0gYml0cztcbiAgICAvLyBBbGwgb25lcywgZXhwZWN0IGBkZWx0YWAgemVyb3MgYWxpZ25lZCB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBtYXNrID0gfigoMSA8PCBkZWx0YSkgLSAxKTtcbiAgICAvLyBKb2luICh2YWx1ZSBsZWZ0LXNoaWZ0ZWQgYGJpdHNgIGJpdHMpIHdpdGggKG1hc2tlZCB2YWx1ZSByaWdodC1zaGlmdGVkIGBkZWx0YWAgYml0cylcbiAgICByZXR1cm4gKCh2YWx1ZSA8PCBiaXRzKSB8ICgobWFzayAmIHZhbHVlKSA+Pj4gZGVsdGEpKSA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGZpbGwoZGVzdCwgaW5kZXggPSAwLCBjb3VudCA9IGRlc3QuYnl0ZUxlbmd0aCwgdmFsdWUgPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGRlc3RbaW5kZXggKyBpXSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxlZnRQYWQodmFsdWUsIGxlbmd0aCwgY2hhciA9ICcwJykge1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBjaGFyICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0hleFN0cmluZyhidWZmZXJPclZhbHVlLCBiaXRzaXplID0gMzIpIHtcbiAgICBpZiAoYnVmZmVyT3JWYWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlck9yVmFsdWUpKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRQYWQoKGJ1ZmZlck9yVmFsdWUgPj4+IDApLnRvU3RyaW5nKDE2KSwgYml0c2l6ZSAvIDQpO1xufVxuLyoqXG4gKiBBIFNIQTEgaW1wbGVtZW50YXRpb24gdGhhdCB3b3JrcyB3aXRoIHN0cmluZ3MgYW5kIGRvZXMgbm90IGFsbG9jYXRlLlxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nU0hBMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2gwID0gMHg2NzQ1MjMwMTtcbiAgICAgICAgdGhpcy5faDEgPSAweEVGQ0RBQjg5O1xuICAgICAgICB0aGlzLl9oMiA9IDB4OThCQURDRkU7XG4gICAgICAgIHRoaXMuX2gzID0gMHgxMDMyNTQ3NjtcbiAgICAgICAgdGhpcy5faDQgPSAweEMzRDJFMUYwO1xuICAgICAgICB0aGlzLl9idWZmID0gbmV3IFVpbnQ4QXJyYXkoNjQgLyogQkxPQ0tfU0laRSAqLyArIDMgLyogdG8gZml0IGFueSB1dGYtOCAqLyk7XG4gICAgICAgIHRoaXMuX2J1ZmZEViA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2J1ZmZMZW4gPSAwO1xuICAgICAgICB0aGlzLl90b3RhbExlbiA9IDA7XG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0ckxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLl9idWZmO1xuICAgICAgICBsZXQgYnVmZkxlbiA9IHRoaXMuX2J1ZmZMZW47XG4gICAgICAgIGxldCBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XG4gICAgICAgIGxldCBjaGFyQ29kZTtcbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgaWYgKGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGNvZGVQb2ludCA9IGNoYXJDb2RlO1xuICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyAxIDwgc3RyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShuZXh0Q2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHN0cmluZ3MuY29tcHV0ZUNvZGVQb2ludChjaGFyQ29kZSwgbmV4dENoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWwgPT4gdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgY2hhcmFjdGVyIGlzIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gY2hhckNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ3MuaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWxsZWdhbCA9PiB1bmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmTGVuID0gdGhpcy5fcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3RyTGVuKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZkxlbiA9IGJ1ZmZMZW47XG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGxlZnRvdmVySGlnaFN1cnJvZ2F0ZTtcbiAgICB9XG4gICAgX3B1c2goYnVmZiwgYnVmZkxlbiwgY29kZVBvaW50KSB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDAwODApIHtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IGNvZGVQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDA4MDApIHtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTEwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTEwMDAwMDApID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEpID4+PiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjExMTAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAxMTExMDAwMDAwMDAwMDAwKSA+Pj4gMTIpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMCkgPj4+IDYpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMTExMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDExMTAwMDAwMDAwMDAwMDAwMDAwMCkgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExMDAwMDAwKSA+Pj4gNik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExKSA+Pj4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZMZW4gPj0gNjQgLyogQkxPQ0tfU0laRSAqLykge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgICAgICAgICAgYnVmZkxlbiAtPSA2NCAvKiBCTE9DS19TSVpFICovO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW4gKz0gNjQgLyogQkxPQ0tfU0laRSAqLztcbiAgICAgICAgICAgIC8vIHRha2UgbGFzdCAzIGluIGNhc2Ugb2YgVVRGOCBvdmVyZmxvd1xuICAgICAgICAgICAgYnVmZlswXSA9IGJ1ZmZbNjQgLyogQkxPQ0tfU0laRSAqLyArIDBdO1xuICAgICAgICAgICAgYnVmZlsxXSA9IGJ1ZmZbNjQgLyogQkxPQ0tfU0laRSAqLyArIDFdO1xuICAgICAgICAgICAgYnVmZlsyXSA9IGJ1ZmZbNjQgLyogQkxPQ0tfU0laRSAqLyArIDJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmTGVuO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmTGVuID0gdGhpcy5fcHVzaCh0aGlzLl9idWZmLCB0aGlzLl9idWZmTGVuLCA2NTUzMyAvKiBVTklDT0RFX1JFUExBQ0VNRU5UICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IHRoaXMuX2J1ZmZMZW47XG4gICAgICAgICAgICB0aGlzLl93cmFwVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9IZXhTdHJpbmcodGhpcy5faDApICsgdG9IZXhTdHJpbmcodGhpcy5faDEpICsgdG9IZXhTdHJpbmcodGhpcy5faDIpICsgdG9IZXhTdHJpbmcodGhpcy5faDMpICsgdG9IZXhTdHJpbmcodGhpcy5faDQpO1xuICAgIH1cbiAgICBfd3JhcFVwKCkge1xuICAgICAgICB0aGlzLl9idWZmW3RoaXMuX2J1ZmZMZW4rK10gPSAweDgwO1xuICAgICAgICBmaWxsKHRoaXMuX2J1ZmYsIHRoaXMuX2J1ZmZMZW4pO1xuICAgICAgICBpZiAodGhpcy5fYnVmZkxlbiA+IDU2KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XG4gICAgICAgICAgICBmaWxsKHRoaXMuX2J1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgd2lsbCBmaXQgYmVjYXVzZSB0aGUgbWFudGlzc2EgY2FuIGNvdmVyIHVwIHRvIDUyIGJpdHNcbiAgICAgICAgY29uc3QgbWwgPSA4ICogdGhpcy5fdG90YWxMZW47XG4gICAgICAgIHRoaXMuX2J1ZmZEVi5zZXRVaW50MzIoNTYsIE1hdGguZmxvb3IobWwgLyA0Mjk0OTY3Mjk2KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDYwLCBtbCAlIDQyOTQ5NjcyOTYsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgIH1cbiAgICBfc3RlcCgpIHtcbiAgICAgICAgY29uc3QgYmlnQmxvY2szMiA9IFN0cmluZ1NIQTEuX2JpZ0Jsb2NrMzI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9idWZmRFY7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQgLyogMTYqNCAqLzsgaiArPSA0KSB7XG4gICAgICAgICAgICBiaWdCbG9jazMyLnNldFVpbnQzMihqLCBkYXRhLmdldFVpbnQzMihqLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gNjQ7IGogPCAzMjAgLyogODAqNCAqLzsgaiArPSA0KSB7XG4gICAgICAgICAgICBiaWdCbG9jazMyLnNldFVpbnQzMihqLCBsZWZ0Um90YXRlKChiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gMTIsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSAzMiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDU2LCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gNjQsIGZhbHNlKSksIDEpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGEgPSB0aGlzLl9oMDtcbiAgICAgICAgbGV0IGIgPSB0aGlzLl9oMTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLl9oMjtcbiAgICAgICAgbGV0IGQgPSB0aGlzLl9oMztcbiAgICAgICAgbGV0IGUgPSB0aGlzLl9oNDtcbiAgICAgICAgbGV0IGYsIGs7XG4gICAgICAgIGxldCB0ZW1wO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMjApIHtcbiAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gICAgICAgICAgICAgICAgayA9IDB4NUE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNDApIHtcbiAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgICAgICAgIGsgPSAweDZFRDlFQkExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaiA8IDYwKSB7XG4gICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgICAgICAgICAgICAgICBrID0gMHg4RjFCQkNEQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgayA9IDB4Q0E2MkMxRDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wID0gKGxlZnRSb3RhdGUoYSwgNSkgKyBmICsgZSArIGsgKyBiaWdCbG9jazMyLmdldFVpbnQzMihqICogNCwgZmFsc2UpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IGxlZnRSb3RhdGUoYiwgMzApO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oMCA9ICh0aGlzLl9oMCArIGEpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5faDEgPSAodGhpcy5faDEgKyBiKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2gyID0gKHRoaXMuX2gyICsgYykgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9oMyA9ICh0aGlzLl9oMyArIGQpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5faDQgPSAodGhpcy5faDQgKyBlKSAmIDB4ZmZmZmZmZmY7XG4gICAgfVxufVxuU3RyaW5nU0hBMS5fYmlnQmxvY2szMiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMzIwKSk7IC8vIDgwICogNCA9IDMyMFxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgdmFyIEl0ZXJhYmxlO1xuKGZ1bmN0aW9uIChJdGVyYWJsZSkge1xuICAgIGZ1bmN0aW9uIGlzKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBJdGVyYWJsZS5pcyA9IGlzO1xuICAgIGNvbnN0IF9lbXB0eSA9IE9iamVjdC5mcmVlemUoW10pO1xuICAgIGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gX2VtcHR5O1xuICAgIH1cbiAgICBJdGVyYWJsZS5lbXB0eSA9IGVtcHR5O1xuICAgIGZ1bmN0aW9uKiBzaW5nbGUoZWxlbWVudCkge1xuICAgICAgICB5aWVsZCBlbGVtZW50O1xuICAgIH1cbiAgICBJdGVyYWJsZS5zaW5nbGUgPSBzaW5nbGU7XG4gICAgZnVuY3Rpb24gZnJvbShpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGUgfHwgX2VtcHR5O1xuICAgIH1cbiAgICBJdGVyYWJsZS5mcm9tID0gZnJvbTtcbiAgICBmdW5jdGlvbiBpc0VtcHR5KGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiAhaXRlcmFibGUgfHwgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lID09PSB0cnVlO1xuICAgIH1cbiAgICBJdGVyYWJsZS5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBmdW5jdGlvbiBmaXJzdChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS52YWx1ZTtcbiAgICB9XG4gICAgSXRlcmFibGUuZmlyc3QgPSBmaXJzdDtcbiAgICBmdW5jdGlvbiBzb21lKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBJdGVyYWJsZS5zb21lID0gc29tZTtcbiAgICBmdW5jdGlvbiBmaW5kKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgSXRlcmFibGUuZmluZCA9IGZpbmQ7XG4gICAgZnVuY3Rpb24qIGZpbHRlcihpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuZmlsdGVyID0gZmlsdGVyO1xuICAgIGZ1bmN0aW9uKiBtYXAoaXRlcmFibGUsIGZuKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgeWllbGQgZm4oZWxlbWVudCwgaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUubWFwID0gbWFwO1xuICAgIGZ1bmN0aW9uKiBjb25jYXQoLi4uaXRlcmFibGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEl0ZXJhYmxlLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBmdW5jdGlvbiogY29uY2F0TmVzdGVkKGl0ZXJhYmxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZXJhYmxlIG9mIGl0ZXJhYmxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS5jb25jYXROZXN0ZWQgPSBjb25jYXROZXN0ZWQ7XG4gICAgZnVuY3Rpb24gcmVkdWNlKGl0ZXJhYmxlLCByZWR1Y2VyLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVkdWNlcih2YWx1ZSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBJdGVyYWJsZS5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBzbGljZSBvZiB0aGUgYXJyYXksIHdpdGggdGhlIHNhbWUgc2VtYW50aWNzIGFzIGBhcnJheS5zbGljZSgpYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogc2xpY2UoYXJyLCBmcm9tLCB0byA9IGFyci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICBmcm9tICs9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgICAgdG8gKz0gYXJyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvID0gYXJyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgZnJvbSA8IHRvOyBmcm9tKyspIHtcbiAgICAgICAgICAgIHlpZWxkIGFycltmcm9tXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS5zbGljZSA9IHNsaWNlO1xuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGBhdE1vc3RgIGVsZW1lbnRzIGZyb20gaXRlcmFibGUgYW5kIHJldHVybnMgdGhlIGNvbnN1bWVkIGVsZW1lbnRzLFxuICAgICAqIGFuZCBhbiBpdGVyYWJsZSBmb3IgdGhlIHJlc3Qgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN1bWUoaXRlcmFibGUsIGF0TW9zdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICBjb25zdCBjb25zdW1lZCA9IFtdO1xuICAgICAgICBpZiAoYXRNb3N0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCBpdGVyYWJsZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXRNb3N0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb25zdW1lZCwgSXRlcmFibGUuZW1wdHkoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lZC5wdXNoKG5leHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY29uc3VtZWQsIHsgW1N5bWJvbC5pdGVyYXRvcl0oKSB7IHJldHVybiBpdGVyYXRvcjsgfSB9XTtcbiAgICB9XG4gICAgSXRlcmFibGUuY29uc3VtZSA9IGNvbnN1bWU7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVyYWJsZXMgYXJlIHRoZSBzYW1lIGxlbmd0aCBhbmQgYWxsIGl0ZW1zIGFyZVxuICAgICAqIGVxdWFsIHVzaW5nIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBjb21wYXJhdG9yID0gKGF0LCBidCkgPT4gYXQgPT09IGJ0KSB7XG4gICAgICAgIGNvbnN0IGFpID0gYVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGNvbnN0IGJpID0gYltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBhbiA9IGFpLm5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGJuID0gYmkubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGFuLmRvbmUgIT09IGJuLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbi5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29tcGFyYXRvcihhbi52YWx1ZSwgYm4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEl0ZXJhYmxlLmVxdWFscyA9IGVxdWFscztcbn0pKEl0ZXJhYmxlIHx8IChJdGVyYWJsZSA9IHt9KSk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIEtleUNvZGVTdHJNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9rZXlDb2RlVG9TdHIgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RyVG9LZXlDb2RlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgZGVmaW5lKGtleUNvZGUsIHN0cikge1xuICAgICAgICB0aGlzLl9rZXlDb2RlVG9TdHJba2V5Q29kZV0gPSBzdHI7XG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZVtzdHIudG9Mb3dlckNhc2UoKV0gPSBrZXlDb2RlO1xuICAgIH1cbiAgICBrZXlDb2RlVG9TdHIoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdO1xuICAgIH1cbiAgICBzdHJUb0tleUNvZGUoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldIHx8IDAgLyogVW5rbm93biAqLztcbiAgICB9XG59XG5jb25zdCB1aU1hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XG5jb25zdCB1c2VyU2V0dGluZ3NVU01hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XG5jb25zdCB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbmV4cG9ydCBjb25zdCBFVkVOVF9LRVlfQ09ERV9NQVAgPSBuZXcgQXJyYXkoMjMwKTtcbmV4cG9ydCBjb25zdCBOQVRJVkVfV0lORE9XU19LRVlfQ09ERV9UT19LRVlfQ09ERSA9IHt9O1xuY29uc3Qgc2NhbkNvZGVJbnRUb1N0ciA9IFtdO1xuY29uc3Qgc2NhbkNvZGVTdHJUb0ludCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBzY2FuQ29kZUxvd2VyQ2FzZVN0clRvSW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuICogLTEgaWYgYSBTY2FuQ29kZSA9PiBLZXlDb2RlIG1hcHBpbmcgZGVwZW5kcyBvbiBrYiBsYXlvdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERSA9IFtdO1xuLyoqXG4gKiAtMSBpZiBhIEtleUNvZGUgPT4gU2NhbkNvZGUgbWFwcGluZyBkZXBlbmRzIG9uIGtiIGxheW91dC5cbiAqL1xuZXhwb3J0IGNvbnN0IElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8PSAxOTMgLyogTUFYX1ZBTFVFICovOyBpKyspIHtcbiAgICBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERVtpXSA9IC0xIC8qIERlcGVuZHNPbktiTGF5b3V0ICovO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPD0gMTI3IC8qIE1BWF9WQUxVRSAqLzsgaSsrKSB7XG4gICAgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREVbaV0gPSAtMSAvKiBEZXBlbmRzT25LYkxheW91dCAqLztcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkMzc1NzMxKHY9dnMuODUpLmFzcHhcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9ub2RlLW5hdGl2ZS1rZXltYXAvYmxvYi9tYXN0ZXIvZGVwcy9jaHJvbWl1bS9rZXlib2FyZF9jb2Rlc193aW4uaFxuICAgIGNvbnN0IGVtcHR5ID0gJyc7XG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXG4gICAgICAgIC8vIGtleUNvZGVPcmQsIGltbXV0YWJsZSwgc2NhbkNvZGUsIHNjYW5Db2RlU3RyLCBrZXlDb2RlLCBrZXlDb2RlU3RyLCBldmVudEtleUNvZGUsIHZrZXksIHVzVXNlclNldHRpbmdzTGFiZWwsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCAnTm9uZScsIDAgLyogVW5rbm93biAqLywgJ3Vua25vd24nLCAwLCAnVktfVU5LTk9XTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxIC8qIEh5cGVyICovLCAnSHlwZXInLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDIgLyogU3VwZXIgKi8sICdTdXBlcicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMyAvKiBGbiAqLywgJ0ZuJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCA0IC8qIEZuTG9jayAqLywgJ0ZuTG9jaycsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgNSAvKiBTdXNwZW5kICovLCAnU3VzcGVuZCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgNiAvKiBSZXN1bWUgKi8sICdSZXN1bWUnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDcgLyogVHVyYm8gKi8sICdUdXJibycsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgOCAvKiBTbGVlcCAqLywgJ1NsZWVwJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NMRUVQJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDkgLyogV2FrZVVwICovLCAnV2FrZVVwJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszMSwgMCwgMTAgLyogS2V5QSAqLywgJ0tleUEnLCAzMSAvKiBLZXlBICovLCAnQScsIDY1LCAnVktfQScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszMiwgMCwgMTEgLyogS2V5QiAqLywgJ0tleUInLCAzMiAvKiBLZXlCICovLCAnQicsIDY2LCAnVktfQicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszMywgMCwgMTIgLyogS2V5QyAqLywgJ0tleUMnLCAzMyAvKiBLZXlDICovLCAnQycsIDY3LCAnVktfQycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszNCwgMCwgMTMgLyogS2V5RCAqLywgJ0tleUQnLCAzNCAvKiBLZXlEICovLCAnRCcsIDY4LCAnVktfRCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszNSwgMCwgMTQgLyogS2V5RSAqLywgJ0tleUUnLCAzNSAvKiBLZXlFICovLCAnRScsIDY5LCAnVktfRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszNiwgMCwgMTUgLyogS2V5RiAqLywgJ0tleUYnLCAzNiAvKiBLZXlGICovLCAnRicsIDcwLCAnVktfRicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszNywgMCwgMTYgLyogS2V5RyAqLywgJ0tleUcnLCAzNyAvKiBLZXlHICovLCAnRycsIDcxLCAnVktfRycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszOCwgMCwgMTcgLyogS2V5SCAqLywgJ0tleUgnLCAzOCAvKiBLZXlIICovLCAnSCcsIDcyLCAnVktfSCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszOSwgMCwgMTggLyogS2V5SSAqLywgJ0tleUknLCAzOSAvKiBLZXlJICovLCAnSScsIDczLCAnVktfSScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0MCwgMCwgMTkgLyogS2V5SiAqLywgJ0tleUonLCA0MCAvKiBLZXlKICovLCAnSicsIDc0LCAnVktfSicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0MSwgMCwgMjAgLyogS2V5SyAqLywgJ0tleUsnLCA0MSAvKiBLZXlLICovLCAnSycsIDc1LCAnVktfSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0MiwgMCwgMjEgLyogS2V5TCAqLywgJ0tleUwnLCA0MiAvKiBLZXlMICovLCAnTCcsIDc2LCAnVktfTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0MywgMCwgMjIgLyogS2V5TSAqLywgJ0tleU0nLCA0MyAvKiBLZXlNICovLCAnTScsIDc3LCAnVktfTScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0NCwgMCwgMjMgLyogS2V5TiAqLywgJ0tleU4nLCA0NCAvKiBLZXlOICovLCAnTicsIDc4LCAnVktfTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0NSwgMCwgMjQgLyogS2V5TyAqLywgJ0tleU8nLCA0NSAvKiBLZXlPICovLCAnTycsIDc5LCAnVktfTycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0NiwgMCwgMjUgLyogS2V5UCAqLywgJ0tleVAnLCA0NiAvKiBLZXlQICovLCAnUCcsIDgwLCAnVktfUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0NywgMCwgMjYgLyogS2V5USAqLywgJ0tleVEnLCA0NyAvKiBLZXlRICovLCAnUScsIDgxLCAnVktfUScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0OCwgMCwgMjcgLyogS2V5UiAqLywgJ0tleVInLCA0OCAvKiBLZXlSICovLCAnUicsIDgyLCAnVktfUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0OSwgMCwgMjggLyogS2V5UyAqLywgJ0tleVMnLCA0OSAvKiBLZXlTICovLCAnUycsIDgzLCAnVktfUycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1MCwgMCwgMjkgLyogS2V5VCAqLywgJ0tleVQnLCA1MCAvKiBLZXlUICovLCAnVCcsIDg0LCAnVktfVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1MSwgMCwgMzAgLyogS2V5VSAqLywgJ0tleVUnLCA1MSAvKiBLZXlVICovLCAnVScsIDg1LCAnVktfVScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1MiwgMCwgMzEgLyogS2V5ViAqLywgJ0tleVYnLCA1MiAvKiBLZXlWICovLCAnVicsIDg2LCAnVktfVicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1MywgMCwgMzIgLyogS2V5VyAqLywgJ0tleVcnLCA1MyAvKiBLZXlXICovLCAnVycsIDg3LCAnVktfVycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1NCwgMCwgMzMgLyogS2V5WCAqLywgJ0tleVgnLCA1NCAvKiBLZXlYICovLCAnWCcsIDg4LCAnVktfWCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1NSwgMCwgMzQgLyogS2V5WSAqLywgJ0tleVknLCA1NSAvKiBLZXlZICovLCAnWScsIDg5LCAnVktfWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1NiwgMCwgMzUgLyogS2V5WiAqLywgJ0tleVonLCA1NiAvKiBLZXlaICovLCAnWicsIDkwLCAnVktfWicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyMiwgMCwgMzYgLyogRGlnaXQxICovLCAnRGlnaXQxJywgMjIgLyogRGlnaXQxICovLCAnMScsIDQ5LCAnVktfMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyMywgMCwgMzcgLyogRGlnaXQyICovLCAnRGlnaXQyJywgMjMgLyogRGlnaXQyICovLCAnMicsIDUwLCAnVktfMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyNCwgMCwgMzggLyogRGlnaXQzICovLCAnRGlnaXQzJywgMjQgLyogRGlnaXQzICovLCAnMycsIDUxLCAnVktfMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyNSwgMCwgMzkgLyogRGlnaXQ0ICovLCAnRGlnaXQ0JywgMjUgLyogRGlnaXQ0ICovLCAnNCcsIDUyLCAnVktfNCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyNiwgMCwgNDAgLyogRGlnaXQ1ICovLCAnRGlnaXQ1JywgMjYgLyogRGlnaXQ1ICovLCAnNScsIDUzLCAnVktfNScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyNywgMCwgNDEgLyogRGlnaXQ2ICovLCAnRGlnaXQ2JywgMjcgLyogRGlnaXQ2ICovLCAnNicsIDU0LCAnVktfNicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyOCwgMCwgNDIgLyogRGlnaXQ3ICovLCAnRGlnaXQ3JywgMjggLyogRGlnaXQ3ICovLCAnNycsIDU1LCAnVktfNycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyOSwgMCwgNDMgLyogRGlnaXQ4ICovLCAnRGlnaXQ4JywgMjkgLyogRGlnaXQ4ICovLCAnOCcsIDU2LCAnVktfOCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszMCwgMCwgNDQgLyogRGlnaXQ5ICovLCAnRGlnaXQ5JywgMzAgLyogRGlnaXQ5ICovLCAnOScsIDU3LCAnVktfOScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsyMSwgMCwgNDUgLyogRGlnaXQwICovLCAnRGlnaXQwJywgMjEgLyogRGlnaXQwICovLCAnMCcsIDQ4LCAnVktfMCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszLCAxLCA0NiAvKiBFbnRlciAqLywgJ0VudGVyJywgMyAvKiBFbnRlciAqLywgJ0VudGVyJywgMTMsICdWS19SRVRVUk4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOSwgMSwgNDcgLyogRXNjYXBlICovLCAnRXNjYXBlJywgOSAvKiBFc2NhcGUgKi8sICdFc2NhcGUnLCAyNywgJ1ZLX0VTQ0FQRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxLCA0OCAvKiBCYWNrc3BhY2UgKi8sICdCYWNrc3BhY2UnLCAxIC8qIEJhY2tzcGFjZSAqLywgJ0JhY2tzcGFjZScsIDgsICdWS19CQUNLJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzIsIDEsIDQ5IC8qIFRhYiAqLywgJ1RhYicsIDIgLyogVGFiICovLCAnVGFiJywgOSwgJ1ZLX1RBQicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMCwgMSwgNTAgLyogU3BhY2UgKi8sICdTcGFjZScsIDEwIC8qIFNwYWNlICovLCAnU3BhY2UnLCAzMiwgJ1ZLX1NQQUNFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzgzLCAwLCA1MSAvKiBNaW51cyAqLywgJ01pbnVzJywgODMgLyogTWludXMgKi8sICctJywgMTg5LCAnVktfT0VNX01JTlVTJywgJy0nLCAnT0VNX01JTlVTJ10sXG4gICAgICAgIFs4MSwgMCwgNTIgLyogRXF1YWwgKi8sICdFcXVhbCcsIDgxIC8qIEVxdWFsICovLCAnPScsIDE4NywgJ1ZLX09FTV9QTFVTJywgJz0nLCAnT0VNX1BMVVMnXSxcbiAgICAgICAgWzg3LCAwLCA1MyAvKiBCcmFja2V0TGVmdCAqLywgJ0JyYWNrZXRMZWZ0JywgODcgLyogQnJhY2tldExlZnQgKi8sICdbJywgMjE5LCAnVktfT0VNXzQnLCAnWycsICdPRU1fNCddLFxuICAgICAgICBbODksIDAsIDU0IC8qIEJyYWNrZXRSaWdodCAqLywgJ0JyYWNrZXRSaWdodCcsIDg5IC8qIEJyYWNrZXRSaWdodCAqLywgJ10nLCAyMjEsICdWS19PRU1fNicsICddJywgJ09FTV82J10sXG4gICAgICAgIFs4OCwgMCwgNTUgLyogQmFja3NsYXNoICovLCAnQmFja3NsYXNoJywgODggLyogQmFja3NsYXNoICovLCAnXFxcXCcsIDIyMCwgJ1ZLX09FTV81JywgJ1xcXFwnLCAnT0VNXzUnXSxcbiAgICAgICAgWzAsIDAsIDU2IC8qIEludGxIYXNoICovLCAnSW50bEhhc2gnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzgwLCAwLCA1NyAvKiBTZW1pY29sb24gKi8sICdTZW1pY29sb24nLCA4MCAvKiBTZW1pY29sb24gKi8sICc7JywgMTg2LCAnVktfT0VNXzEnLCAnOycsICdPRU1fMSddLFxuICAgICAgICBbOTAsIDAsIDU4IC8qIFF1b3RlICovLCAnUXVvdGUnLCA5MCAvKiBRdW90ZSAqLywgJ1xcJycsIDIyMiwgJ1ZLX09FTV83JywgJ1xcJycsICdPRU1fNyddLFxuICAgICAgICBbODYsIDAsIDU5IC8qIEJhY2txdW90ZSAqLywgJ0JhY2txdW90ZScsIDg2IC8qIEJhY2txdW90ZSAqLywgJ2AnLCAxOTIsICdWS19PRU1fMycsICdgJywgJ09FTV8zJ10sXG4gICAgICAgIFs4MiwgMCwgNjAgLyogQ29tbWEgKi8sICdDb21tYScsIDgyIC8qIENvbW1hICovLCAnLCcsIDE4OCwgJ1ZLX09FTV9DT01NQScsICcsJywgJ09FTV9DT01NQSddLFxuICAgICAgICBbODQsIDAsIDYxIC8qIFBlcmlvZCAqLywgJ1BlcmlvZCcsIDg0IC8qIFBlcmlvZCAqLywgJy4nLCAxOTAsICdWS19PRU1fUEVSSU9EJywgJy4nLCAnT0VNX1BFUklPRCddLFxuICAgICAgICBbODUsIDAsIDYyIC8qIFNsYXNoICovLCAnU2xhc2gnLCA4NSAvKiBTbGFzaCAqLywgJy8nLCAxOTEsICdWS19PRU1fMicsICcvJywgJ09FTV8yJ10sXG4gICAgICAgIFs4LCAxLCA2MyAvKiBDYXBzTG9jayAqLywgJ0NhcHNMb2NrJywgOCAvKiBDYXBzTG9jayAqLywgJ0NhcHNMb2NrJywgMjAsICdWS19DQVBJVEFMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzU5LCAxLCA2NCAvKiBGMSAqLywgJ0YxJywgNTkgLyogRjEgKi8sICdGMScsIDExMiwgJ1ZLX0YxJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzYwLCAxLCA2NSAvKiBGMiAqLywgJ0YyJywgNjAgLyogRjIgKi8sICdGMicsIDExMywgJ1ZLX0YyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzYxLCAxLCA2NiAvKiBGMyAqLywgJ0YzJywgNjEgLyogRjMgKi8sICdGMycsIDExNCwgJ1ZLX0YzJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzYyLCAxLCA2NyAvKiBGNCAqLywgJ0Y0JywgNjIgLyogRjQgKi8sICdGNCcsIDExNSwgJ1ZLX0Y0JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzYzLCAxLCA2OCAvKiBGNSAqLywgJ0Y1JywgNjMgLyogRjUgKi8sICdGNScsIDExNiwgJ1ZLX0Y1JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzY0LCAxLCA2OSAvKiBGNiAqLywgJ0Y2JywgNjQgLyogRjYgKi8sICdGNicsIDExNywgJ1ZLX0Y2JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzY1LCAxLCA3MCAvKiBGNyAqLywgJ0Y3JywgNjUgLyogRjcgKi8sICdGNycsIDExOCwgJ1ZLX0Y3JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzY2LCAxLCA3MSAvKiBGOCAqLywgJ0Y4JywgNjYgLyogRjggKi8sICdGOCcsIDExOSwgJ1ZLX0Y4JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzY3LCAxLCA3MiAvKiBGOSAqLywgJ0Y5JywgNjcgLyogRjkgKi8sICdGOScsIDEyMCwgJ1ZLX0Y5JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzY4LCAxLCA3MyAvKiBGMTAgKi8sICdGMTAnLCA2OCAvKiBGMTAgKi8sICdGMTAnLCAxMjEsICdWS19GMTAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNjksIDEsIDc0IC8qIEYxMSAqLywgJ0YxMScsIDY5IC8qIEYxMSAqLywgJ0YxMScsIDEyMiwgJ1ZLX0YxMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs3MCwgMSwgNzUgLyogRjEyICovLCAnRjEyJywgNzAgLyogRjEyICovLCAnRjEyJywgMTIzLCAnVktfRjEyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDc2IC8qIFByaW50U2NyZWVuICovLCAnUHJpbnRTY3JlZW4nLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzc5LCAxLCA3NyAvKiBTY3JvbGxMb2NrICovLCAnU2Nyb2xsTG9jaycsIDc5IC8qIFNjcm9sbExvY2sgKi8sICdTY3JvbGxMb2NrJywgMTQ1LCAnVktfU0NST0xMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzcsIDEsIDc4IC8qIFBhdXNlICovLCAnUGF1c2UnLCA3IC8qIFBhdXNlQnJlYWsgKi8sICdQYXVzZUJyZWFrJywgMTksICdWS19QQVVTRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxOSwgMSwgNzkgLyogSW5zZXJ0ICovLCAnSW5zZXJ0JywgMTkgLyogSW5zZXJ0ICovLCAnSW5zZXJ0JywgNDUsICdWS19JTlNFUlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTQsIDEsIDgwIC8qIEhvbWUgKi8sICdIb21lJywgMTQgLyogSG9tZSAqLywgJ0hvbWUnLCAzNiwgJ1ZLX0hPTUUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTEsIDEsIDgxIC8qIFBhZ2VVcCAqLywgJ1BhZ2VVcCcsIDExIC8qIFBhZ2VVcCAqLywgJ1BhZ2VVcCcsIDMzLCAnVktfUFJJT1InLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMjAsIDEsIDgyIC8qIERlbGV0ZSAqLywgJ0RlbGV0ZScsIDIwIC8qIERlbGV0ZSAqLywgJ0RlbGV0ZScsIDQ2LCAnVktfREVMRVRFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEzLCAxLCA4MyAvKiBFbmQgKi8sICdFbmQnLCAxMyAvKiBFbmQgKi8sICdFbmQnLCAzNSwgJ1ZLX0VORCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMiwgMSwgODQgLyogUGFnZURvd24gKi8sICdQYWdlRG93bicsIDEyIC8qIFBhZ2VEb3duICovLCAnUGFnZURvd24nLCAzNCwgJ1ZLX05FWFQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTcsIDEsIDg1IC8qIEFycm93UmlnaHQgKi8sICdBcnJvd1JpZ2h0JywgMTcgLyogUmlnaHRBcnJvdyAqLywgJ1JpZ2h0QXJyb3cnLCAzOSwgJ1ZLX1JJR0hUJywgJ1JpZ2h0JywgZW1wdHldLFxuICAgICAgICBbMTUsIDEsIDg2IC8qIEFycm93TGVmdCAqLywgJ0Fycm93TGVmdCcsIDE1IC8qIExlZnRBcnJvdyAqLywgJ0xlZnRBcnJvdycsIDM3LCAnVktfTEVGVCcsICdMZWZ0JywgZW1wdHldLFxuICAgICAgICBbMTgsIDEsIDg3IC8qIEFycm93RG93biAqLywgJ0Fycm93RG93bicsIDE4IC8qIERvd25BcnJvdyAqLywgJ0Rvd25BcnJvdycsIDQwLCAnVktfRE9XTicsICdEb3duJywgZW1wdHldLFxuICAgICAgICBbMTYsIDEsIDg4IC8qIEFycm93VXAgKi8sICdBcnJvd1VwJywgMTYgLyogVXBBcnJvdyAqLywgJ1VwQXJyb3cnLCAzOCwgJ1ZLX1VQJywgJ1VwJywgZW1wdHldLFxuICAgICAgICBbNzgsIDEsIDg5IC8qIE51bUxvY2sgKi8sICdOdW1Mb2NrJywgNzggLyogTnVtTG9jayAqLywgJ051bUxvY2snLCAxNDQsICdWS19OVU1MT0NLJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEwOCwgMSwgOTAgLyogTnVtcGFkRGl2aWRlICovLCAnTnVtcGFkRGl2aWRlJywgMTA4IC8qIE51bXBhZERpdmlkZSAqLywgJ051bVBhZF9EaXZpZGUnLCAxMTEsICdWS19ESVZJREUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTAzLCAxLCA5MSAvKiBOdW1wYWRNdWx0aXBseSAqLywgJ051bXBhZE11bHRpcGx5JywgMTAzIC8qIE51bXBhZE11bHRpcGx5ICovLCAnTnVtUGFkX011bHRpcGx5JywgMTA2LCAnVktfTVVMVElQTFknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTA2LCAxLCA5MiAvKiBOdW1wYWRTdWJ0cmFjdCAqLywgJ051bXBhZFN1YnRyYWN0JywgMTA2IC8qIE51bXBhZFN1YnRyYWN0ICovLCAnTnVtUGFkX1N1YnRyYWN0JywgMTA5LCAnVktfU1VCVFJBQ1QnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTA0LCAxLCA5MyAvKiBOdW1wYWRBZGQgKi8sICdOdW1wYWRBZGQnLCAxMDQgLyogTnVtcGFkQWRkICovLCAnTnVtUGFkX0FkZCcsIDEwNywgJ1ZLX0FERCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFszLCAxLCA5NCAvKiBOdW1wYWRFbnRlciAqLywgJ051bXBhZEVudGVyJywgMyAvKiBFbnRlciAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOTQsIDEsIDk1IC8qIE51bXBhZDEgKi8sICdOdW1wYWQxJywgOTQgLyogTnVtcGFkMSAqLywgJ051bVBhZDEnLCA5NywgJ1ZLX05VTVBBRDEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOTUsIDEsIDk2IC8qIE51bXBhZDIgKi8sICdOdW1wYWQyJywgOTUgLyogTnVtcGFkMiAqLywgJ051bVBhZDInLCA5OCwgJ1ZLX05VTVBBRDInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOTYsIDEsIDk3IC8qIE51bXBhZDMgKi8sICdOdW1wYWQzJywgOTYgLyogTnVtcGFkMyAqLywgJ051bVBhZDMnLCA5OSwgJ1ZLX05VTVBBRDMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOTcsIDEsIDk4IC8qIE51bXBhZDQgKi8sICdOdW1wYWQ0JywgOTcgLyogTnVtcGFkNCAqLywgJ051bVBhZDQnLCAxMDAsICdWS19OVU1QQUQ0JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzk4LCAxLCA5OSAvKiBOdW1wYWQ1ICovLCAnTnVtcGFkNScsIDk4IC8qIE51bXBhZDUgKi8sICdOdW1QYWQ1JywgMTAxLCAnVktfTlVNUEFENScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs5OSwgMSwgMTAwIC8qIE51bXBhZDYgKi8sICdOdW1wYWQ2JywgOTkgLyogTnVtcGFkNiAqLywgJ051bVBhZDYnLCAxMDIsICdWS19OVU1QQUQ2JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEwMCwgMSwgMTAxIC8qIE51bXBhZDcgKi8sICdOdW1wYWQ3JywgMTAwIC8qIE51bXBhZDcgKi8sICdOdW1QYWQ3JywgMTAzLCAnVktfTlVNUEFENycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMDEsIDEsIDEwMiAvKiBOdW1wYWQ4ICovLCAnTnVtcGFkOCcsIDEwMSAvKiBOdW1wYWQ4ICovLCAnTnVtUGFkOCcsIDEwNCwgJ1ZLX05VTVBBRDgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTAyLCAxLCAxMDMgLyogTnVtcGFkOSAqLywgJ051bXBhZDknLCAxMDIgLyogTnVtcGFkOSAqLywgJ051bVBhZDknLCAxMDUsICdWS19OVU1QQUQ5JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzkzLCAxLCAxMDQgLyogTnVtcGFkMCAqLywgJ051bXBhZDAnLCA5MyAvKiBOdW1wYWQwICovLCAnTnVtUGFkMCcsIDk2LCAnVktfTlVNUEFEMCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMDcsIDEsIDEwNSAvKiBOdW1wYWREZWNpbWFsICovLCAnTnVtcGFkRGVjaW1hbCcsIDEwNyAvKiBOdW1wYWREZWNpbWFsICovLCAnTnVtUGFkX0RlY2ltYWwnLCAxMTAsICdWS19ERUNJTUFMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzkyLCAwLCAxMDYgLyogSW50bEJhY2tzbGFzaCAqLywgJ0ludGxCYWNrc2xhc2gnLCA5MiAvKiBJbnRsQmFja3NsYXNoICovLCAnT0VNXzEwMicsIDIyNiwgJ1ZLX09FTV8xMDInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNTgsIDEsIDEwNyAvKiBDb250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51JywgNTggLyogQ29udGV4dE1lbnUgKi8sICdDb250ZXh0TWVudScsIDkzLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEwOCAvKiBQb3dlciAqLywgJ1Bvd2VyJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxMDkgLyogTnVtcGFkRXF1YWwgKi8sICdOdW1wYWRFcXVhbCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzEsIDEsIDExMCAvKiBGMTMgKi8sICdGMTMnLCA3MSAvKiBGMTMgKi8sICdGMTMnLCAxMjQsICdWS19GMTMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzIsIDEsIDExMSAvKiBGMTQgKi8sICdGMTQnLCA3MiAvKiBGMTQgKi8sICdGMTQnLCAxMjUsICdWS19GMTQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzMsIDEsIDExMiAvKiBGMTUgKi8sICdGMTUnLCA3MyAvKiBGMTUgKi8sICdGMTUnLCAxMjYsICdWS19GMTUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzQsIDEsIDExMyAvKiBGMTYgKi8sICdGMTYnLCA3NCAvKiBGMTYgKi8sICdGMTYnLCAxMjcsICdWS19GMTYnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzUsIDEsIDExNCAvKiBGMTcgKi8sICdGMTcnLCA3NSAvKiBGMTcgKi8sICdGMTcnLCAxMjgsICdWS19GMTcnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzYsIDEsIDExNSAvKiBGMTggKi8sICdGMTgnLCA3NiAvKiBGMTggKi8sICdGMTgnLCAxMjksICdWS19GMTgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNzcsIDEsIDExNiAvKiBGMTkgKi8sICdGMTknLCA3NyAvKiBGMTkgKi8sICdGMTknLCAxMzAsICdWS19GMTknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTE3IC8qIEYyMCAqLywgJ0YyMCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19GMjAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTE4IC8qIEYyMSAqLywgJ0YyMScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19GMjEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTE5IC8qIEYyMiAqLywgJ0YyMicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19GMjInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTIwIC8qIEYyMyAqLywgJ0YyMycsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19GMjMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTIxIC8qIEYyNCAqLywgJ0YyNCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19GMjQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTIyIC8qIE9wZW4gKi8sICdPcGVuJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxMjMgLyogSGVscCAqLywgJ0hlbHAnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEyNCAvKiBTZWxlY3QgKi8sICdTZWxlY3QnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEyNSAvKiBBZ2FpbiAqLywgJ0FnYWluJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxMjYgLyogVW5kbyAqLywgJ1VuZG8nLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEyNyAvKiBDdXQgKi8sICdDdXQnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEyOCAvKiBDb3B5ICovLCAnQ29weScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTI5IC8qIFBhc3RlICovLCAnUGFzdGUnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDEzMCAvKiBGaW5kICovLCAnRmluZCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTMxIC8qIEF1ZGlvVm9sdW1lTXV0ZSAqLywgJ0F1ZGlvVm9sdW1lTXV0ZScsIDExMiAvKiBBdWRpb1ZvbHVtZU11dGUgKi8sICdBdWRpb1ZvbHVtZU11dGUnLCAxNzMsICdWS19WT0xVTUVfTVVURScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxMzIgLyogQXVkaW9Wb2x1bWVVcCAqLywgJ0F1ZGlvVm9sdW1lVXAnLCAxMTMgLyogQXVkaW9Wb2x1bWVVcCAqLywgJ0F1ZGlvVm9sdW1lVXAnLCAxNzUsICdWS19WT0xVTUVfVVAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTMzIC8qIEF1ZGlvVm9sdW1lRG93biAqLywgJ0F1ZGlvVm9sdW1lRG93bicsIDExNCAvKiBBdWRpb1ZvbHVtZURvd24gKi8sICdBdWRpb1ZvbHVtZURvd24nLCAxNzQsICdWS19WT0xVTUVfRE9XTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMDUsIDEsIDEzNCAvKiBOdW1wYWRDb21tYSAqLywgJ051bXBhZENvbW1hJywgMTA1IC8qIE5VTVBBRF9TRVBBUkFUT1IgKi8sICdOdW1QYWRfU2VwYXJhdG9yJywgMTA4LCAnVktfU0VQQVJBVE9SJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzExMCwgMCwgMTM1IC8qIEludGxSbyAqLywgJ0ludGxSbycsIDExMCAvKiBBQk5UX0MxICovLCAnQUJOVF9DMScsIDE5MywgJ1ZLX0FCTlRfQzEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTM2IC8qIEthbmFNb2RlICovLCAnS2FuYU1vZGUnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDAsIDEzNyAvKiBJbnRsWWVuICovLCAnSW50bFllbicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTM4IC8qIENvbnZlcnQgKi8sICdDb252ZXJ0JywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxMzkgLyogTm9uQ29udmVydCAqLywgJ05vbkNvbnZlcnQnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE0MCAvKiBMYW5nMSAqLywgJ0xhbmcxJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNDEgLyogTGFuZzIgKi8sICdMYW5nMicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTQyIC8qIExhbmczICovLCAnTGFuZzMnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE0MyAvKiBMYW5nNCAqLywgJ0xhbmc0JywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNDQgLyogTGFuZzUgKi8sICdMYW5nNScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTQ1IC8qIEFib3J0ICovLCAnQWJvcnQnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE0NiAvKiBQcm9wcyAqLywgJ1Byb3BzJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNDcgLyogTnVtcGFkUGFyZW5MZWZ0ICovLCAnTnVtcGFkUGFyZW5MZWZ0JywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNDggLyogTnVtcGFkUGFyZW5SaWdodCAqLywgJ051bXBhZFBhcmVuUmlnaHQnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE0OSAvKiBOdW1wYWRCYWNrc3BhY2UgKi8sICdOdW1wYWRCYWNrc3BhY2UnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE1MCAvKiBOdW1wYWRNZW1vcnlTdG9yZSAqLywgJ051bXBhZE1lbW9yeVN0b3JlJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNTEgLyogTnVtcGFkTWVtb3J5UmVjYWxsICovLCAnTnVtcGFkTWVtb3J5UmVjYWxsJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNTIgLyogTnVtcGFkTWVtb3J5Q2xlYXIgKi8sICdOdW1wYWRNZW1vcnlDbGVhcicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTUzIC8qIE51bXBhZE1lbW9yeUFkZCAqLywgJ051bXBhZE1lbW9yeUFkZCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTU0IC8qIE51bXBhZE1lbW9yeVN1YnRyYWN0ICovLCAnTnVtcGFkTWVtb3J5U3VidHJhY3QnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE1NSAvKiBOdW1wYWRDbGVhciAqLywgJ051bXBhZENsZWFyJywgMTI2IC8qIENsZWFyICovLCAnQ2xlYXInLCAxMiwgJ1ZLX0NMRUFSJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE1NiAvKiBOdW1wYWRDbGVhckVudHJ5ICovLCAnTnVtcGFkQ2xlYXJFbnRyeScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNSwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgNSAvKiBDdHJsICovLCAnQ3RybCcsIDE3LCAnVktfQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0LCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCA0IC8qIFNoaWZ0ICovLCAnU2hpZnQnLCAxNiwgJ1ZLX1NISUZUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzYsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDYgLyogQWx0ICovLCAnQWx0JywgMTgsICdWS19NRU5VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzU3LCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCA1NyAvKiBNZXRhICovLCAnTWV0YScsIDAsICdWS19DT01NQU5EJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzUsIDEsIDE1NyAvKiBDb250cm9sTGVmdCAqLywgJ0NvbnRyb2xMZWZ0JywgNSAvKiBDdHJsICovLCBlbXB0eSwgMCwgJ1ZLX0xDT05UUk9MJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzQsIDEsIDE1OCAvKiBTaGlmdExlZnQgKi8sICdTaGlmdExlZnQnLCA0IC8qIFNoaWZ0ICovLCBlbXB0eSwgMCwgJ1ZLX0xTSElGVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs2LCAxLCAxNTkgLyogQWx0TGVmdCAqLywgJ0FsdExlZnQnLCA2IC8qIEFsdCAqLywgZW1wdHksIDAsICdWS19MTUVOVScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs1NywgMSwgMTYwIC8qIE1ldGFMZWZ0ICovLCAnTWV0YUxlZnQnLCA1NyAvKiBNZXRhICovLCBlbXB0eSwgMCwgJ1ZLX0xXSU4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbNSwgMSwgMTYxIC8qIENvbnRyb2xSaWdodCAqLywgJ0NvbnRyb2xSaWdodCcsIDUgLyogQ3RybCAqLywgZW1wdHksIDAsICdWS19SQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs0LCAxLCAxNjIgLyogU2hpZnRSaWdodCAqLywgJ1NoaWZ0UmlnaHQnLCA0IC8qIFNoaWZ0ICovLCBlbXB0eSwgMCwgJ1ZLX1JTSElGVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFs2LCAxLCAxNjMgLyogQWx0UmlnaHQgKi8sICdBbHRSaWdodCcsIDYgLyogQWx0ICovLCBlbXB0eSwgMCwgJ1ZLX1JNRU5VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzU3LCAxLCAxNjQgLyogTWV0YVJpZ2h0ICovLCAnTWV0YVJpZ2h0JywgNTcgLyogTWV0YSAqLywgZW1wdHksIDAsICdWS19SV0lOJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE2NSAvKiBCcmlnaHRuZXNzVXAgKi8sICdCcmlnaHRuZXNzVXAnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE2NiAvKiBCcmlnaHRuZXNzRG93biAqLywgJ0JyaWdodG5lc3NEb3duJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNjcgLyogTWVkaWFQbGF5ICovLCAnTWVkaWFQbGF5JywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNjggLyogTWVkaWFSZWNvcmQgKi8sICdNZWRpYVJlY29yZCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTY5IC8qIE1lZGlhRmFzdEZvcndhcmQgKi8sICdNZWRpYUZhc3RGb3J3YXJkJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzAgLyogTWVkaWFSZXdpbmQgKi8sICdNZWRpYVJld2luZCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTE0LCAxLCAxNzEgLyogTWVkaWFUcmFja05leHQgKi8sICdNZWRpYVRyYWNrTmV4dCcsIDExOSAvKiBNZWRpYVRyYWNrTmV4dCAqLywgJ01lZGlhVHJhY2tOZXh0JywgMTc2LCAnVktfTUVESUFfTkVYVF9UUkFDSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMTUsIDEsIDE3MiAvKiBNZWRpYVRyYWNrUHJldmlvdXMgKi8sICdNZWRpYVRyYWNrUHJldmlvdXMnLCAxMjAgLyogTWVkaWFUcmFja1ByZXZpb3VzICovLCAnTWVkaWFUcmFja1ByZXZpb3VzJywgMTc3LCAnVktfTUVESUFfUFJFVl9UUkFDSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMTYsIDEsIDE3MyAvKiBNZWRpYVN0b3AgKi8sICdNZWRpYVN0b3AnLCAxMjEgLyogTWVkaWFTdG9wICovLCAnTWVkaWFTdG9wJywgMTc4LCAnVktfTUVESUFfU1RPUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzQgLyogRWplY3QgKi8sICdFamVjdCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTE3LCAxLCAxNzUgLyogTWVkaWFQbGF5UGF1c2UgKi8sICdNZWRpYVBsYXlQYXVzZScsIDEyMiAvKiBNZWRpYVBsYXlQYXVzZSAqLywgJ01lZGlhUGxheVBhdXNlJywgMTc5LCAnVktfTUVESUFfUExBWV9QQVVTRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzYgLyogTWVkaWFTZWxlY3QgKi8sICdNZWRpYVNlbGVjdCcsIDEyMyAvKiBMYXVuY2hNZWRpYVBsYXllciAqLywgJ0xhdW5jaE1lZGlhUGxheWVyJywgMTgxLCAnVktfTUVESUFfTEFVTkNIX01FRElBX1NFTEVDVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzcgLyogTGF1bmNoTWFpbCAqLywgJ0xhdW5jaE1haWwnLCAxMjQgLyogTGF1bmNoTWFpbCAqLywgJ0xhdW5jaE1haWwnLCAxODAsICdWS19NRURJQV9MQVVOQ0hfTUFJTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzggLyogTGF1bmNoQXBwMiAqLywgJ0xhdW5jaEFwcDInLCAxMjUgLyogTGF1bmNoQXBwMiAqLywgJ0xhdW5jaEFwcDInLCAxODMsICdWS19NRURJQV9MQVVOQ0hfQVBQMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxNzkgLyogTGF1bmNoQXBwMSAqLywgJ0xhdW5jaEFwcDEnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTUVESUFfTEFVTkNIX0FQUDEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTgwIC8qIFNlbGVjdFRhc2sgKi8sICdTZWxlY3RUYXNrJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxODEgLyogTGF1bmNoU2NyZWVuU2F2ZXIgKi8sICdMYXVuY2hTY3JlZW5TYXZlcicsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTgyIC8qIEJyb3dzZXJTZWFyY2ggKi8sICdCcm93c2VyU2VhcmNoJywgMTE1IC8qIEJyb3dzZXJTZWFyY2ggKi8sICdCcm93c2VyU2VhcmNoJywgMTcwLCAnVktfQlJPV1NFUl9TRUFSQ0gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTgzIC8qIEJyb3dzZXJIb21lICovLCAnQnJvd3NlckhvbWUnLCAxMTYgLyogQnJvd3NlckhvbWUgKi8sICdCcm93c2VySG9tZScsIDE3MiwgJ1ZLX0JST1dTRVJfSE9NRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMTIsIDEsIDE4NCAvKiBCcm93c2VyQmFjayAqLywgJ0Jyb3dzZXJCYWNrJywgMTE3IC8qIEJyb3dzZXJCYWNrICovLCAnQnJvd3NlckJhY2snLCAxNjYsICdWS19CUk9XU0VSX0JBQ0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMTEzLCAxLCAxODUgLyogQnJvd3NlckZvcndhcmQgKi8sICdCcm93c2VyRm9yd2FyZCcsIDExOCAvKiBCcm93c2VyRm9yd2FyZCAqLywgJ0Jyb3dzZXJGb3J3YXJkJywgMTY3LCAnVktfQlJPV1NFUl9GT1JXQVJEJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE4NiAvKiBCcm93c2VyU3RvcCAqLywgJ0Jyb3dzZXJTdG9wJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfU1RPUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAxODcgLyogQnJvd3NlclJlZnJlc2ggKi8sICdCcm93c2VyUmVmcmVzaCcsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19CUk9XU0VSX1JFRlJFU0gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTg4IC8qIEJyb3dzZXJGYXZvcml0ZXMgKi8sICdCcm93c2VyRmF2b3JpdGVzJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0JST1dTRVJfRkFWT1JJVEVTJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE4OSAvKiBab29tVG9nZ2xlICovLCAnWm9vbVRvZ2dsZScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTkwIC8qIE1haWxSZXBseSAqLywgJ01haWxSZXBseScsIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMTkxIC8qIE1haWxGb3J3YXJkICovLCAnTWFpbEZvcndhcmQnLCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDE5MiAvKiBNYWlsU2VuZCAqLywgJ01haWxTZW5kJywgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIC8vIFNlZSBodHRwczovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDEwSnVsU2VwL2F0dC0wMTgyL2tleUNvZGUtc3BlYy5odG1sXG4gICAgICAgIC8vIElmIGFuIElucHV0IE1ldGhvZCBFZGl0b3IgaXMgcHJvY2Vzc2luZyBrZXkgaW5wdXQgYW5kIHRoZSBldmVudCBpcyBrZXlkb3duLCByZXR1cm4gMjI5LlxuICAgICAgICBbMTA5LCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAxMDkgLyogS0VZX0lOX0NPTVBPU0lUSU9OICovLCAnS2V5SW5Db21wb3NpdGlvbicsIDIyOSwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxMTEsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDExMSAvKiBBQk5UX0MyICovLCAnQUJOVF9DMicsIDE5NCwgJ1ZLX0FCTlRfQzInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbOTEsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDkxIC8qIE9FTV84ICovLCAnT0VNXzgnLCAyMjMsICdWS19PRU1fOCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfS0FOQScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEFOR1VMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19KVU5KQScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRklOQUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0hBTkpBJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19LQU5KSScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQ09OVkVSVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTk9OQ09OVkVSVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQUNDRVBUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19NT0RFQ0hBTkdFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19TRUxFQ1QnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1BSSU5UJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19FWEVDVVRFJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19TTkFQU0hPVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEVMUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQVBQUycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUFJPQ0VTU0tFWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUEFDS0VUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19EQkVfU0JDU0NIQVInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0RCRV9EQkNTQ0hBUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQVRUTicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQ1JTRUwnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0VYU0VMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19FUkVPRicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUExBWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfWk9PTScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxLCAwIC8qIE5vbmUgKi8sIGVtcHR5LCAwIC8qIFVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTk9OQU1FJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEsIDAgLyogTm9uZSAqLywgZW1wdHksIDAgLyogVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QQTEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMSwgMCAvKiBOb25lICovLCBlbXB0eSwgMCAvKiBVbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX09FTV9DTEVBUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgXTtcbiAgICBsZXQgc2VlbktleUNvZGUgPSBbXTtcbiAgICBsZXQgc2VlblNjYW5Db2RlID0gW107XG4gICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIG1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IFtfa2V5Q29kZU9yZCwgaW1tdXRhYmxlLCBzY2FuQ29kZSwgc2NhbkNvZGVTdHIsIGtleUNvZGUsIGtleUNvZGVTdHIsIGV2ZW50S2V5Q29kZSwgdmtleSwgdXNVc2VyU2V0dGluZ3NMYWJlbCwgZ2VuZXJhbFVzZXJTZXR0aW5nc0xhYmVsXSA9IG1hcHBpbmc7XG4gICAgICAgIGlmICghc2VlblNjYW5Db2RlW3NjYW5Db2RlXSkge1xuICAgICAgICAgICAgc2VlblNjYW5Db2RlW3NjYW5Db2RlXSA9IHRydWU7XG4gICAgICAgICAgICBzY2FuQ29kZUludFRvU3RyW3NjYW5Db2RlXSA9IHNjYW5Db2RlU3RyO1xuICAgICAgICAgICAgc2NhbkNvZGVTdHJUb0ludFtzY2FuQ29kZVN0cl0gPSBzY2FuQ29kZTtcbiAgICAgICAgICAgIHNjYW5Db2RlTG93ZXJDYXNlU3RyVG9JbnRbc2NhbkNvZGVTdHIudG9Mb3dlckNhc2UoKV0gPSBzY2FuQ29kZTtcbiAgICAgICAgICAgIGlmIChpbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERVtzY2FuQ29kZV0gPSBrZXlDb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoa2V5Q29kZSAhPT0gMCAvKiBVbmtub3duICovKVxuICAgICAgICAgICAgICAgICAgICAmJiAoa2V5Q29kZSAhPT0gMyAvKiBFbnRlciAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDUgLyogQ3RybCAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDQgLyogU2hpZnQgKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSA2IC8qIEFsdCAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDU3IC8qIE1ldGEgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFW2tleUNvZGVdID0gc2NhbkNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VlbktleUNvZGVba2V5Q29kZV0pIHtcbiAgICAgICAgICAgIHNlZW5LZXlDb2RlW2tleUNvZGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgha2V5Q29kZVN0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG1pc3NpbmcgZm9yIGtleSBjb2RlICR7a2V5Q29kZX0gYXJvdW5kIHNjYW4gY29kZSAke3NjYW5Db2RlU3RyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdWlNYXAuZGVmaW5lKGtleUNvZGUsIGtleUNvZGVTdHIpO1xuICAgICAgICAgICAgdXNlclNldHRpbmdzVVNNYXAuZGVmaW5lKGtleUNvZGUsIHVzVXNlclNldHRpbmdzTGFiZWwgfHwga2V5Q29kZVN0cik7XG4gICAgICAgICAgICB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmRlZmluZShrZXlDb2RlLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwgfHwgdXNVc2VyU2V0dGluZ3NMYWJlbCB8fCBrZXlDb2RlU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRLZXlDb2RlKSB7XG4gICAgICAgICAgICBFVkVOVF9LRVlfQ09ERV9NQVBbZXZlbnRLZXlDb2RlXSA9IGtleUNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZrZXkpIHtcbiAgICAgICAgICAgIE5BVElWRV9XSU5ET1dTX0tFWV9DT0RFX1RPX0tFWV9DT0RFW3ZrZXldID0ga2V5Q29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYW51YWxseSBhZGRlZCBkdWUgdG8gdGhlIGV4Y2x1c2lvbiBhYm92ZSAoZHVlIHRvIGR1cGxpY2F0aW9uIHdpdGggTnVtcGFkRW50ZXIpXG4gICAgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREVbMyAvKiBFbnRlciAqL10gPSA0NiAvKiBFbnRlciAqLztcbn0pKCk7XG5leHBvcnQgdmFyIEtleUNvZGVVdGlscztcbihmdW5jdGlvbiAoS2V5Q29kZVV0aWxzKSB7XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdWlNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKGtleSkge1xuICAgICAgICByZXR1cm4gdWlNYXAuc3RyVG9LZXlDb2RlKGtleSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1VzZXJTZXR0aW5nc1VTKGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc1VTTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzVVMgPSB0b1VzZXJTZXR0aW5nc1VTO1xuICAgIGZ1bmN0aW9uIHRvVXNlclNldHRpbmdzR2VuZXJhbChrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLnRvVXNlclNldHRpbmdzR2VuZXJhbCA9IHRvVXNlclNldHRpbmdzR2VuZXJhbDtcbiAgICBmdW5jdGlvbiBmcm9tVXNlclNldHRpbmdzKGtleSkge1xuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzVVNNYXAuc3RyVG9LZXlDb2RlKGtleSkgfHwgdXNlclNldHRpbmdzR2VuZXJhbE1hcC5zdHJUb0tleUNvZGUoa2V5KTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLmZyb21Vc2VyU2V0dGluZ3MgPSBmcm9tVXNlclNldHRpbmdzO1xuICAgIGZ1bmN0aW9uIHRvRWxlY3Ryb25BY2NlbGVyYXRvcihrZXlDb2RlKSB7XG4gICAgICAgIGlmIChrZXlDb2RlID49IDkzIC8qIE51bXBhZDAgKi8gJiYga2V5Q29kZSA8PSAxMDggLyogTnVtcGFkRGl2aWRlICovKSB7XG4gICAgICAgICAgICAvLyBbRWxlY3Ryb24gQWNjZWxlcmF0b3JzXSBFbGVjdHJvbiBpcyBhYmxlIHRvIHBhcnNlIG51bXBhZCBrZXlzLCBidXQgdW5mb3J0dW5hdGVseSBpdFxuICAgICAgICAgICAgLy8gcmVuZGVycyB0aGVtIGp1c3QgYXMgcmVndWxhciBrZXlzIGluIG1lbnVzLiBGb3IgZXhhbXBsZSwgbnVtMCBpcyByZW5kZXJlZCBhcyBcIjBcIixcbiAgICAgICAgICAgIC8vIG51bWRpdiBpcyByZW5kZXJlZCBhcyBcIi9cIiwgbnVtc3ViIGlzIHJlbmRlcmVkIGFzIFwiLVwiLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gaW5jcmVkaWJsZSBjb25mdXNpb24sIGFzIGl0IG1ha2VzIG51bXBhZCBiYXNlZCBrZXliaW5kaW5ncyBpbmRpc3Rpbmd1aXNoYWJsZVxuICAgICAgICAgICAgLy8gZnJvbSBrZXliaW5kaW5ncyBiYXNlZCBvbiByZWd1bGFyIGtleXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgdGhlcmVmb3JlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGN1c3RvbSByZW5kZXJpbmcgZm9yIG51bXBhZCBrZXlzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDE2IC8qIFVwQXJyb3cgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVcCc7XG4gICAgICAgICAgICBjYXNlIDE4IC8qIERvd25BcnJvdyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Rvd24nO1xuICAgICAgICAgICAgY2FzZSAxNSAvKiBMZWZ0QXJyb3cgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdMZWZ0JztcbiAgICAgICAgICAgIGNhc2UgMTcgLyogUmlnaHRBcnJvdyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWlNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMudG9FbGVjdHJvbkFjY2VsZXJhdG9yID0gdG9FbGVjdHJvbkFjY2VsZXJhdG9yO1xufSkoS2V5Q29kZVV0aWxzIHx8IChLZXlDb2RlVXRpbHMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCkge1xuICAgIGNvbnN0IGNob3JkUGFydCA9ICgoc2Vjb25kUGFydCAmIDB4MDAwMEZGRkYpIDw8IDE2KSA+Pj4gMDtcbiAgICByZXR1cm4gKGZpcnN0UGFydCB8IGNob3JkUGFydCkgPj4+IDA7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjbGFzcyBMYXp5IHtcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgICAgICB0aGlzLmV4ZWN1dG9yID0gZXhlY3V0b3I7XG4gICAgICAgIHRoaXMuX2RpZFJ1biA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgZm9yY2UgZXZhbHVhdGlvbiBvZiB0aGUgbGF6eSB2YWx1ZSBpZiBpdCBoYXMgbm90IGJlZW4gcmVzb2x2ZWQgeWV0LiBMYXp5IHZhbHVlcyBhcmUgb25seVxuICAgICAqIHJlc29sdmVkIG9uY2UuIGBnZXRWYWx1ZWAgd2lsbCByZS10aHJvdyBleGNlcHRpb25zIHRoYXQgYXJlIGhpdCB3aGlsZSByZXNvbHZpbmcgdGhlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGlkUnVuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5leGVjdXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3cmFwcGVkIHZhbHVlIHdpdGhvdXQgZm9yY2luZyBldmFsdWF0aW9uLlxuICAgICAqL1xuICAgIGdldCByYXdWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IG9uY2UgfSBmcm9tICcuL2Z1bmN0aW9uYWwuanMnO1xuaW1wb3J0IHsgSXRlcmFibGUgfSBmcm9tICcuL2l0ZXJhdG9yLmpzJztcbi8qKlxuICogRW5hYmxlcyBsb2dnaW5nIG9mIHBvdGVudGlhbGx5IGxlYWtlZCBkaXNwb3NhYmxlcy5cbiAqXG4gKiBBIGRpc3Bvc2FibGUgaXMgY29uc2lkZXJlZCBsZWFrZWQgaWYgaXQgaXMgbm90IGRpc3Bvc2VkIG9yIG5vdCByZWdpc3RlcmVkIGFzIHRoZSBjaGlsZCBvZlxuICogYW5vdGhlciBkaXNwb3NhYmxlLiBUaGlzIHRyYWNraW5nIGlzIHZlcnkgc2ltcGxlIGFuIG9ubHkgd29ya3MgZm9yIGNsYXNzZXMgdGhhdCBlaXRoZXJcbiAqIGV4dGVuZCBEaXNwb3NhYmxlIG9yIHVzZSBhIERpc3Bvc2FibGVTdG9yZS4gVGhpcyBtZWFucyB0aGVyZSBhcmUgYSBsb3Qgb2YgZmFsc2UgcG9zaXRpdmVzLlxuICovXG5jb25zdCBUUkFDS19ESVNQT1NBQkxFUyA9IGZhbHNlO1xubGV0IGRpc3Bvc2FibGVUcmFja2VyID0gbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBzZXREaXNwb3NhYmxlVHJhY2tlcih0cmFja2VyKSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPSB0cmFja2VyO1xufVxuaWYgKFRSQUNLX0RJU1BPU0FCTEVTKSB7XG4gICAgY29uc3QgX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfXyA9ICdfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fJztcbiAgICBzZXREaXNwb3NhYmxlVHJhY2tlcihuZXcgY2xhc3Mge1xuICAgICAgICB0cmFja0Rpc3Bvc2FibGUoeCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoJ1BvdGVudGlhbGx5IGxlYWtlZCBkaXNwb3NhYmxlJykuc3RhY2s7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXhbX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfX10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICAgIHNldFBhcmVudChjaGlsZCwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IERpc3Bvc2FibGUuTm9uZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya0FzRGlzcG9zZWQoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGUgJiYgZGlzcG9zYWJsZSAhPT0gRGlzcG9zYWJsZS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZVtfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcmtBc1NpbmdsZXRvbihkaXNwb3NhYmxlKSB7IH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRyYWNrRGlzcG9zYWJsZSh4KSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLnRyYWNrRGlzcG9zYWJsZSh4KTtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIG1hcmtBc0Rpc3Bvc2VkKGRpc3Bvc2FibGUpIHtcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlVHJhY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZVRyYWNrZXIubWFya0FzRGlzcG9zZWQoZGlzcG9zYWJsZSk7XG59XG5mdW5jdGlvbiBzZXRQYXJlbnRPZkRpc3Bvc2FibGUoY2hpbGQsIHBhcmVudCkge1xuICAgIGRpc3Bvc2FibGVUcmFja2VyID09PSBudWxsIHx8IGRpc3Bvc2FibGVUcmFja2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwb3NhYmxlVHJhY2tlci5zZXRQYXJlbnQoY2hpbGQsIHBhcmVudCk7XG59XG5mdW5jdGlvbiBzZXRQYXJlbnRPZkRpc3Bvc2FibGVzKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgICBpZiAoIWRpc3Bvc2FibGVUcmFja2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBkaXNwb3NhYmxlVHJhY2tlci5zZXRQYXJlbnQoY2hpbGQsIHBhcmVudCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgc2luZ2xldG9uIHdoaWNoIGRvZXMgbm90IG5lZWQgdG8gYmUgZGlzcG9zZWQuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc1NpbmdsZXRvbihzaW5nbGV0b24pIHtcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlVHJhY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZVRyYWNrZXIubWFya0FzU2luZ2xldG9uKHNpbmdsZXRvbik7XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbn1cbmV4cG9ydCBjbGFzcyBNdWx0aURpc3Bvc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoYEVuY291bnRlcmVkIGVycm9ycyB3aGlsZSBkaXNwb3Npbmcgb2Ygc3RvcmUuIEVycm9yczogWyR7ZXJyb3JzLmpvaW4oJywgJyl9XWApO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEaXNwb3NhYmxlKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZy5kaXNwb3NlID09PSAnZnVuY3Rpb24nICYmIHRoaW5nLmRpc3Bvc2UubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2UoYXJnKSB7XG4gICAgaWYgKEl0ZXJhYmxlLmlzKGFyZykpIHtcbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJnKSB7XG4gICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE11bHRpRGlzcG9zZUVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IFtdIDogYXJnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmcpIHtcbiAgICAgICAgYXJnLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWREaXNwb3NhYmxlKC4uLmRpc3Bvc2FibGVzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdG9EaXNwb3NhYmxlKCgpID0+IGRpc3Bvc2UoZGlzcG9zYWJsZXMpKTtcbiAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGVzKGRpc3Bvc2FibGVzLCBwYXJlbnQpO1xuICAgIHJldHVybiBwYXJlbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9EaXNwb3NhYmxlKGZuKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRyYWNrRGlzcG9zYWJsZSh7XG4gICAgICAgIGRpc3Bvc2U6IG9uY2UoKCkgPT4ge1xuICAgICAgICAgICAgbWFya0FzRGlzcG9zZWQoc2VsZik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xufVxuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3RvRGlzcG9zZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHJlZ2lzdGVyZWQgZGlzcG9zYWJsZXMgYW5kIG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBBbnkgZnV0dXJlIGRpc3Bvc2FibGVzIGFkZGVkIHRvIHRoaXMgb2JqZWN0IHdpbGwgYmUgZGlzcG9zZWQgb2Ygb24gYGFkZGAuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBvYmplY3QgaGFzIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHJlZ2lzdGVyZWQgZGlzcG9zYWJsZXMgYnV0IGRvIG5vdCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcG9zZSh0aGlzLl90b0Rpc3Bvc2UudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fdG9EaXNwb3NlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKG8pIHtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgICBpZiAobyA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYSBkaXNwb3NhYmxlIG9uIGl0c2VsZiEnKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUobywgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBpZiAoIURpc3Bvc2FibGVTdG9yZS5ESVNBQkxFX0RJU1BPU0VEX1dBUk5JTkcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCdUcnlpbmcgdG8gYWRkIGEgZGlzcG9zYWJsZSB0byBhIERpc3Bvc2FibGVTdG9yZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgb2YuIFRoZSBhZGRlZCBvYmplY3Qgd2lsbCBiZSBsZWFrZWQhJykuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9EaXNwb3NlLmFkZChvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG5EaXNwb3NhYmxlU3RvcmUuRElTQUJMRV9ESVNQT1NFRF9XQVJOSU5HID0gZmFsc2U7XG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZSgpO1xuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XG4gICAgICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZSh0aGlzLl9zdG9yZSwgdGhpcyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdG9yZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIF9yZWdpc3RlcihvKSB7XG4gICAgICAgIGlmIChvID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5hZGQobyk7XG4gICAgfVxufVxuRGlzcG9zYWJsZS5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7IGRpc3Bvc2UoKSB7IH0gfSk7XG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpZmVjeWNsZSBvZiBhIGRpc3Bvc2FibGUgdmFsdWUgdGhhdCBtYXkgYmUgY2hhbmdlZC5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIHRoZSBkaXNwb3NhYmxlIHZhbHVlIGlzIGNoYW5nZWQsIHRoZSBwcmV2aW91c2x5IGhlbGQgZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBvZi4gWW91IGNhblxuICogYWxzbyByZWdpc3RlciBhIGBNdXRhYmxlRGlzcG9zYWJsZWAgb24gYSBgRGlzcG9zYWJsZWAgdG8gZW5zdXJlIGl0IGlzIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cC5cbiAqL1xuZXhwb3J0IGNsYXNzIE11dGFibGVEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQgPyB1bmRlZmluZWQgOiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQgfHwgdmFsdWUgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fdmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB2YWx1ZSwgYnV0IGRvZXMgbm90IGRpc3Bvc2UgaXQuXG4gICAgICogVGhlIG9sZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGNsZWFyQW5kTGVhaygpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKG9sZFZhbHVlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNhZmUgZGlzcG9zYWJsZSBjYW4gYmUgYHVuc2V0YCBzbyB0aGF0IGEgbGVha2VkIHJlZmVyZW5jZSAobGlzdGVuZXIpXG4gKiBjYW4gYmUgY3V0LW9mZi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhZmVEaXNwb3NhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnVuc2V0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmlzc2V0ID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcbiAgICB9XG4gICAgc2V0KGZuKSB7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGZuO1xuICAgICAgICB0aGlzLnVuc2V0ID0gKCkgPT4gY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNzZXQgPSAoKSA9PiBjYWxsYmFjayAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW1tb3J0YWxSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdCkge1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHsgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZXYgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICB9XG59XG5Ob2RlLlVuZGVmaW5lZCA9IG5ldyBOb2RlKHVuZGVmaW5lZCk7XG5leHBvcnQgY2xhc3MgTGlua2VkTGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZS5uZXh0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJzdCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICB1bnNoaWZ0KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChlbGVtZW50LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICBfaW5zZXJ0KGVsZW1lbnQsIGF0VGhlRW5kKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXRUaGVFbmQpIHtcbiAgICAgICAgICAgIC8vIHB1c2hcbiAgICAgICAgICAgIGNvbnN0IG9sZExhc3QgPSB0aGlzLl9sYXN0O1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLnByZXYgPSBvbGRMYXN0O1xuICAgICAgICAgICAgb2xkTGFzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVuc2hpZnRcbiAgICAgICAgICAgIGNvbnN0IG9sZEZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSBvbGRGaXJzdDtcbiAgICAgICAgICAgIG9sZEZpcnN0LnByZXYgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgKz0gMTtcbiAgICAgICAgbGV0IGRpZFJlbW92ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkaWRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBkaWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9maXJzdC5lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuX2ZpcnN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9sYXN0LmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5fbGFzdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1vdmUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5wcmV2ICE9PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgIT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBtaWRkbGVcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIGFuY2hvci5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBhbmNob3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wcmV2ID09PSBOb2RlLlVuZGVmaW5lZCAmJiBub2RlLm5leHQgPT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG5vZGVcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbGFzdFxuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2xhc3QucHJldjtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucHJldiA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2ZpcnN0Lm5leHQ7XG4gICAgICAgICAgICB0aGlzLl9maXJzdC5wcmV2ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZVxuICAgICAgICB0aGlzLl9zaXplIC09IDE7XG4gICAgfVxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB5aWVsZCBub2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBpc0FycmF5LCBpc09iamVjdCwgaXNVbmRlZmluZWRPck51bGwgfSBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMDk5MFxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChvYmpba2V5XSAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBDbG9uZShvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRnJlZXplKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW29ial07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jb25zdCBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlcikge1xuICAgIHJldHVybiBfY2xvbmVBbmRDaGFuZ2Uob2JqLCBjaGFuZ2VyLCBuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gX2Nsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlciwgc2Vlbikge1xuICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbChvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSBjaGFuZ2VyKG9iaik7XG4gICAgaWYgKHR5cGVvZiBjaGFuZ2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCByMSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqKSB7XG4gICAgICAgICAgICByMS5wdXNoKF9jbG9uZUFuZENoYW5nZShlLCBjaGFuZ2VyLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAoc2Vlbi5oYXMob2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2xvbmUgcmVjdXJzaXZlIGRhdGEtc3RydWN0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQob2JqKTtcbiAgICAgICAgY29uc3QgcjIgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaTIgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgICAgICByMltpMl0gPSBfY2xvbmVBbmRDaGFuZ2Uob2JqW2kyXSwgY2hhbmdlciwgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5kZWxldGUob2JqKTtcbiAgICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gZGVzdGluYXRpb24uIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgXCJvdmVyd3JpdGVcIiBhbGxvd3MgdG8gY29udHJvbFxuICogaWYgZXhpc3RpbmcgcHJvcGVydGllcyBvbiB0aGUgZGVzdGluYXRpb24gc2hvdWxkIGJlIG92ZXJ3cml0dGVuIG9yIG5vdC4gRGVmYXVsdHMgdG8gdHJ1ZSAob3ZlcndyaXRlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluKGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJ3cml0ZSA9IHRydWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGRlc3RpbmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkZXN0aW5hdGlvbltrZXldKSAmJiBpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluKGRlc3RpbmF0aW9uW2tleV0sIHNvdXJjZVtrZXldLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyKSB7XG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKEFycmF5LmlzQXJyYXkob25lKSkgIT09IChBcnJheS5pc0FycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBsZXQga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9uZSkpIHtcbiAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvbmVLZXlzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIG9uZSkge1xuICAgICAgICAgICAgb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yRGVmYXVsdChvYmosIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBmbihvYmopO1xuICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gTk9URTogVlNDb2RlJ3MgY29weSBvZiBub2RlanMgcGF0aCBsaWJyYXJ5IHRvIGJlIHVzYWJsZSBpbiBjb21tb24gKG5vbi1ub2RlKSBuYW1lc3BhY2Vcbi8vIENvcGllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTQuMTYuMC9saWIvcGF0aC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4gKiBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbiAqIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4gKiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuICogT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuICogVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuaW1wb3J0ICogYXMgcHJvY2VzcyBmcm9tICcuL3Byb2Nlc3MuanMnO1xuY29uc3QgQ0hBUl9VUFBFUkNBU0VfQSA9IDY1OyAvKiBBICovXG5jb25zdCBDSEFSX0xPV0VSQ0FTRV9BID0gOTc7IC8qIGEgKi9cbmNvbnN0IENIQVJfVVBQRVJDQVNFX1ogPSA5MDsgLyogWiAqL1xuY29uc3QgQ0hBUl9MT1dFUkNBU0VfWiA9IDEyMjsgLyogeiAqL1xuY29uc3QgQ0hBUl9ET1QgPSA0NjsgLyogLiAqL1xuY29uc3QgQ0hBUl9GT1JXQVJEX1NMQVNIID0gNDc7IC8qIC8gKi9cbmNvbnN0IENIQVJfQkFDS1dBUkRfU0xBU0ggPSA5MjsgLyogXFwgKi9cbmNvbnN0IENIQVJfQ09MT04gPSA1ODsgLyogOiAqL1xuY29uc3QgQ0hBUl9RVUVTVElPTl9NQVJLID0gNjM7IC8qID8gKi9cbmNsYXNzIEVycm9ySW52YWxpZEFyZ1R5cGUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAgICAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICAgICAgICBsZXQgZGV0ZXJtaW5lcjtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgZXhwZWN0ZWQuaW5kZXhPZignbm90ICcpID09PSAwKSB7XG4gICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICAgICAgbGV0IG1zZyA9IGBUaGUgXCIke25hbWV9XCIgJHt0eXBlfSAke2RldGVybWluZXJ9IG9mIHR5cGUgJHtleHBlY3RlZH1gO1xuICAgICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YDtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9JTlZBTElEX0FSR19UWVBFJztcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvckludmFsaWRBcmdUeXBlKG5hbWUsICdzdHJpbmcnLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXRoU2VwYXJhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7XG59XG5mdW5jdGlvbiBpc1Bvc2l4UGF0aFNlcGFyYXRvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbn1cbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZVJvb3QoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSBDSEFSX1VQUEVSQ0FTRV9BICYmIGNvZGUgPD0gQ0hBUl9VUFBFUkNBU0VfWikgfHxcbiAgICAgICAgKGNvZGUgPj0gQ0hBUl9MT1dFUkNBU0VfQSAmJiBjb2RlIDw9IENIQVJfTE9XRVJDQVNFX1opO1xufVxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmcocGF0aCwgYWxsb3dBYm92ZVJvb3QsIHNlcGFyYXRvciwgaXNQYXRoU2VwYXJhdG9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGxldCBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgbGV0IGxhc3RTbGFzaCA9IC0xO1xuICAgIGxldCBkb3RzID0gMDtcbiAgICBsZXQgY29kZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBOT09QXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb3RzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gQ0hBUl9ET1QgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gcmVzLmxlbmd0aCA+IDAgPyBgJHtzZXBhcmF0b3J9Li5gIDogJy4uJztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7cGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlID09PSBDSEFSX0RPVCAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgICAgICAgKytkb3RzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG90cyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZSgncGF0aE9iamVjdCcsICdPYmplY3QnLCBwYXRoT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICAgIGNvbnN0IGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHxcbiAgICAgICAgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7cGF0aE9iamVjdC5leHQgfHwgJyd9YDtcbiAgICBpZiAoIWRpcikge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRpciA9PT0gcGF0aE9iamVjdC5yb290ID8gYCR7ZGlyfSR7YmFzZX1gIDogYCR7ZGlyfSR7c2VwfSR7YmFzZX1gO1xufVxuZXhwb3J0IGNvbnN0IHdpbjMyID0ge1xuICAgIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgICByZXNvbHZlKC4uLnBhdGhTZWdtZW50cykge1xuICAgICAgICBsZXQgcmVzb2x2ZWREZXZpY2UgPSAnJztcbiAgICAgICAgbGV0IHJlc29sdmVkVGFpbCA9ICcnO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhdGg7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhTZWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgaGFzIHRoZSBjb25jZXB0IG9mIGRyaXZlLXNwZWNpZmljIGN1cnJlbnQgd29ya2luZ1xuICAgICAgICAgICAgICAgIC8vIGRpcmVjdG9yaWVzLiBJZiB3ZSd2ZSByZXNvbHZlZCBhIGRyaXZlIGxldHRlciBidXQgbm90IHlldCBhblxuICAgICAgICAgICAgICAgIC8vIGFic29sdXRlIHBhdGgsIGdldCBjd2QgZm9yIHRoYXQgZHJpdmUsIG9yIHRoZSBwcm9jZXNzIGN3ZCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoZSBkcml2ZSBjd2QgaXMgbm90IGF2YWlsYWJsZS4gV2UncmUgc3VyZSB0aGUgZGV2aWNlIGlzIG5vdFxuICAgICAgICAgICAgICAgIC8vIGEgVU5DIHBhdGggYXQgdGhpcyBwb2ludHMsIGJlY2F1c2UgVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGUuXG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuZW52W2A9JHtyZXNvbHZlZERldmljZX1gXSB8fCBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGEgY3dkIHdhcyBmb3VuZCBhbmQgdGhhdCBpdCBhY3R1YWxseSBwb2ludHNcbiAgICAgICAgICAgICAgICAvLyB0byBvdXIgZHJpdmUuIElmIG5vdCwgZGVmYXVsdCB0byB0aGUgZHJpdmUncyByb290LlxuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhdGguc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gYCR7cmVzb2x2ZWREZXZpY2V9XFxcXGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XG4gICAgICAgICAgICBsZXQgZGV2aWNlID0gJyc7XG4gICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW5cbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoIG9mIHNvbWUga2luZCAoVU5DIG9yIG90aGVyd2lzZSlcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCBqID0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4gfHwgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0LCBqKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiZcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxuICAgICAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2aWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcGF0aCBwb2ludHMgdG8gYW5vdGhlciBkZXZpY2Ugc28gaXQgaXMgbm90IGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZERldmljZSA9IGRldmljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVGFpbCA9IGAke3BhdGguc2xpY2Uocm9vdEVuZCl9XFxcXCR7cmVzb2x2ZWRUYWlsfWA7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUgJiYgcmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsXG4gICAgICAgIC8vIGJ1dCBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKVxuICAgICAgICAvLyBmYWlscylcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSB0YWlsIHBhdGhcbiAgICAgICAgcmVzb2x2ZWRUYWlsID0gbm9ybWFsaXplU3RyaW5nKHJlc29sdmVkVGFpbCwgIXJlc29sdmVkQWJzb2x1dGUsICdcXFxcJywgaXNQYXRoU2VwYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQWJzb2x1dGUgP1xuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9XFxcXCR7cmVzb2x2ZWRUYWlsfWAgOlxuICAgICAgICAgICAgYCR7cmVzb2x2ZWREZXZpY2V9JHtyZXNvbHZlZFRhaWx9YCB8fCAnLic7XG4gICAgfSxcbiAgICBub3JtYWxpemUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XG4gICAgICAgIGxldCBkZXZpY2U7XG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBzaW5nbGUgY2hhciwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgcmV0dXJuIGlzUG9zaXhQYXRoU2VwYXJhdG9yKGNvZGUpID8gJ1xcXFwnIDogcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxuICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgc2VwYXJhdG9yLCB3ZSBrbm93IHdlIGF0IGxlYXN0IGhhdmUgYW4gYWJzb2x1dGVcbiAgICAgICAgICAgIC8vIHBhdGggb2Ygc29tZSBraW5kIChVTkMgb3Igb3RoZXJ3aXNlKVxuICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXRoLnNsaWNlKGxhc3QsIGopO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgVU5DIHJvb3Qgc2luY2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3RoaW5nIGxlZnQgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QpfVxcXFxgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBgXFxcXFxcXFwke2ZpcnN0UGFydH1cXFxcJHtwYXRoLnNsaWNlKGxhc3QsIGopfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290RW5kID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIGRldmljZSA9IHBhdGguc2xpY2UoMCwgMik7XG4gICAgICAgICAgICByb290RW5kID0gMjtcbiAgICAgICAgICAgIGlmIChsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgc2VwYXJhdG9yIGZvbGxvd2luZyBkcml2ZSBuYW1lIGFzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290RW5kID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFpbCA9IHJvb3RFbmQgPCBsZW4gP1xuICAgICAgICAgICAgbm9ybWFsaXplU3RyaW5nKHBhdGguc2xpY2Uocm9vdEVuZCksICFpc0Fic29sdXRlLCAnXFxcXCcsIGlzUGF0aFNlcGFyYXRvcikgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIGlmICh0YWlsLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGFpbCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQobGVuIC0gMSkpKSB7XG4gICAgICAgICAgICB0YWlsICs9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV2aWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYFxcXFwke3RhaWx9YCA6IHRhaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGUgPyBgJHtkZXZpY2V9XFxcXCR7dGFpbH1gIDogYCR7ZGV2aWNlfSR7dGFpbH1gO1xuICAgIH0sXG4gICAgaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGlzUGF0aFNlcGFyYXRvcihjb2RlKSB8fFxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIChsZW4gPiAyICYmXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJlxuICAgICAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTiAmJlxuICAgICAgICAgICAgICAgIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKTtcbiAgICB9LFxuICAgIGpvaW4oLi4ucGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgam9pbmVkO1xuICAgICAgICBsZXQgZmlyc3RQYXJ0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBmaXJzdFBhcnQgPSBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYFxcXFwke2FyZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGpvaW5lZCBwYXRoIGRvZXNuJ3Qgc3RhcnQgd2l0aCB0d28gc2xhc2hlcywgYmVjYXVzZVxuICAgICAgICAvLyBub3JtYWxpemUoKSB3aWxsIG1pc3Rha2UgaXQgZm9yIGEgVU5DIHBhdGggdGhlbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBzdGVwIGlzIHNraXBwZWQgd2hlbiBpdCBpcyB2ZXJ5IGNsZWFyIHRoYXQgdGhlIHVzZXIgYWN0dWFsbHlcbiAgICAgICAgLy8gaW50ZW5kZWQgdG8gcG9pbnQgYXQgYSBVTkMgcGF0aC4gVGhpcyBpcyBhc3N1bWVkIHdoZW4gdGhlIGZpcnN0XG4gICAgICAgIC8vIG5vbi1lbXB0eSBzdHJpbmcgYXJndW1lbnRzIHN0YXJ0cyB3aXRoIGV4YWN0bHkgdHdvIHNsYXNoZXMgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gYXQgbGVhc3Qgb25lIG1vcmUgbm9uLXNsYXNoIGNoYXJhY3Rlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IGZvciBub3JtYWxpemUoKSB0byB0cmVhdCBhIHBhdGggYXMgYSBVTkMgcGF0aCBpdCBuZWVkcyB0b1xuICAgICAgICAvLyBoYXZlIGF0IGxlYXN0IDIgY29tcG9uZW50cywgc28gd2UgZG9uJ3QgZmlsdGVyIGZvciB0aGF0IGhlcmUuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdXNlciBjYW4gdXNlIGpvaW4gdG8gY29uc3RydWN0IFVOQyBwYXRocyBmcm9tXG4gICAgICAgIC8vIGEgc2VydmVyIG5hbWUgYW5kIGEgc2hhcmUgbmFtZTsgZm9yIGV4YW1wbGU6XG4gICAgICAgIC8vICAgcGF0aC5qb2luKCcvL3NlcnZlcicsICdzaGFyZScpIC0+ICdcXFxcXFxcXHNlcnZlclxcXFxzaGFyZVxcXFwnKVxuICAgICAgICBsZXQgbmVlZHNSZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNsYXNoQ291bnQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0UGFydCA9PT0gJ3N0cmluZycgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgKytzbGFzaENvdW50O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RMZW4gPSBmaXJzdFBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZpcnN0TGVuID4gMSAmJiBpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgKytzbGFzaENvdW50O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdExlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2xhc2hDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcGF0aCBpbiB0aGUgZmlyc3QgcGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNSZXBsYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzUmVwbGFjZSkge1xuICAgICAgICAgICAgLy8gRmluZCBhbnkgbW9yZSBjb25zZWN1dGl2ZSBzbGFzaGVzIHdlIG5lZWQgdG8gcmVwbGFjZVxuICAgICAgICAgICAgd2hpbGUgKHNsYXNoQ291bnQgPCBqb2luZWQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgaXNQYXRoU2VwYXJhdG9yKGpvaW5lZC5jaGFyQ29kZUF0KHNsYXNoQ291bnQpKSkge1xuICAgICAgICAgICAgICAgIHNsYXNoQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHNsYXNoZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoc2xhc2hDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkID0gYFxcXFwke2pvaW5lZC5zbGljZShzbGFzaENvdW50KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aW4zMi5ub3JtYWxpemUoam9pbmVkKTtcbiAgICB9LFxuICAgIC8vIEl0IHdpbGwgc29sdmUgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSBgZnJvbWAgdG8gYHRvYCwgZm9yIGluc3RhbmNlOlxuICAgIC8vICBmcm9tID0gJ0M6XFxcXG9yYW5kZWFcXFxcdGVzdFxcXFxhYWEnXG4gICAgLy8gIHRvID0gJ0M6XFxcXG9yYW5kZWFcXFxcaW1wbFxcXFxiYmInXG4gICAgLy8gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlOiAnLi5cXFxcLi5cXFxcaW1wbFxcXFxiYmInXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tT3JpZyA9IHdpbjMyLnJlc29sdmUoZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvT3JpZyA9IHdpbjMyLnJlc29sdmUodG8pO1xuICAgICAgICBpZiAoZnJvbU9yaWcgPT09IHRvT3JpZykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGZyb20gPSBmcm9tT3JpZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0byA9IHRvT3JpZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgICAgIGxldCBmcm9tU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAoZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGggJiZcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxuICAgICAgICBsZXQgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoZnJvbUVuZCAtIDEgPiBmcm9tU3RhcnQgJiZcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgIGZyb21FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcbiAgICAgICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgICAgICBsZXQgdG9TdGFydCA9IDA7XG4gICAgICAgIHdoaWxlICh0b1N0YXJ0IDwgdG8ubGVuZ3RoICYmXG4gICAgICAgICAgICB0by5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICB0b1N0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyBiYWNrc2xhc2hlcyAoYXBwbGljYWJsZSB0byBVTkMgcGF0aHMgb25seSlcbiAgICAgICAgbGV0IHRvRW5kID0gdG8ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAodG9FbmQgLSAxID4gdG9TdGFydCAmJlxuICAgICAgICAgICAgdG8uY2hhckNvZGVBdCh0b0VuZCAtIDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICB0b0VuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuICAgICAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICAgICAgbGV0IGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZm91bmQgYSBtaXNtYXRjaCBiZWZvcmUgdGhlIGZpcnN0IGNvbW1vbiBwYXRoIHNlcGFyYXRvciB3YXMgc2Vlbiwgc29cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBgdG9gLlxuICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9PcmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb29cXFxcYmFyXFxcXGJheidcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGRldmljZSByb290LlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcJzsgdG89J0M6XFxcXGZvbydcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFxmb28nXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGRldmljZSByb290LlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nQzpcXFxcZm9vXFxcXGJhcic7IHRvPSdDOlxcXFwnXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Q29tbW9uU2VwID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2AgYW5kXG4gICAgICAgIC8vIGBmcm9tYFxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIG91dCArPSBvdXQubGVuZ3RoID09PSAwID8gJy4uJyA6ICdcXFxcLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzXG4gICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke291dH0ke3RvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9PcmlnLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICsrdG9TdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9PcmlnLnNsaWNlKHRvU3RhcnQsIHRvRW5kKTtcbiAgICB9LFxuICAgIHRvTmFtZXNwYWNlZFBhdGgocGF0aCkge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgKnByb2JhYmx5KiB0aHJvdyBzb21ld2hlcmUuXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHdpbjMyLnJlc29sdmUocGF0aCk7XG4gICAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ0hBUl9RVUVTVElPTl9NQVJLICYmIGNvZGUgIT09IENIQVJfRE9UKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgbm9uLWxvbmcgVU5DIHJvb3QsIGNvbnZlcnQgdGhlIHBhdGggdG8gYSBsb25nIFVOQyBwYXRoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXFVOQ1xcXFwke3Jlc29sdmVkUGF0aC5zbGljZSgyKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApKSAmJlxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAvLyBNYXRjaGVkIGRldmljZSByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcJHtyZXNvbHZlZFBhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuICAgIGRpcm5hbWUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdEVuZCA9IC0xO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvciwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yayBvciBhIGRvdC5cbiAgICAgICAgICAgIHJldHVybiBpc1BhdGhTZXBhcmF0b3IoY29kZSkgPyBwYXRoIDogJy4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcbiAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCBieSAxIHRvIGluY2x1ZGUgdGhlIHNlcGFyYXRvciBhZnRlciB0aGUgVU5DIHJvb3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIFwibm9ybWFsIHJvb3RcIiBvbiB0b3Agb2YgYSAoVU5DKSByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgcm9vdEVuZCA9IGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkgPyAzIDogMjtcbiAgICAgICAgICAgIG9mZnNldCA9IHJvb3RFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gb2Zmc2V0OyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChyb290RW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSByb290RW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gICAgfSxcbiAgICBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhleHQsICdleHQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgZHJpdmUgbGV0dGVyIHByZWZpeCBzbyBhcyBub3QgdG8gbWlzdGFrZSB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KHBhdGguY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZXh0ID09PSBwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9LFxuICAgIGV4dG5hbWUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgZHJpdmUgbGV0dGVyIHByZWZpeCBzbyBhcyBub3QgdG8gbWlzdGFrZSB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcbiAgICAgICAgICAgIGlzV2luZG93c0RldmljZVJvb3QocGF0aC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydFBhcnQgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgZW5kID09PSAtMSB8fFxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH0sXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJ1xcXFwnKSxcbiAgICBwYXJzZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGxldCByb290RW5kID0gMDtcbiAgICAgICAgbGV0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yLCBleGl0IGVhcmx5IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICByb290RW5kID0gMTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgIGxldCBqID0gMjtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgIGlmIChsZW4gPD0gMikge1xuICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgZHJpdmUgcm9vdCwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290RW5kID0gMjtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkge1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3RFbmQgPiAwKSB7XG4gICAgICAgICAgICByZXQucm9vdCA9IHBhdGguc2xpY2UoMCwgcm9vdEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgICAgIGxldCBzdGFydFBhcnQgPSByb290RW5kO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgICAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgICAgIGZvciAoOyBpID49IHJvb3RFbmQ7IC0taSkge1xuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZGlyZWN0b3J5IGlzIHRoZSByb290LCB1c2UgdGhlIGVudGlyZSByb290IGFzIHRoZSBgZGlyYCBpbmNsdWRpbmdcbiAgICAgICAgLy8gdGhlIHRyYWlsaW5nIHNsYXNoIGlmIGFueSAoYEM6XFxhYmNgIC0+IGBDOlxcYCkuIE90aGVyd2lzZSwgc3RyaXAgb3V0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBzbGFzaCAoYEM6XFxhYmNcXGRlZmAgLT4gYEM6XFxhYmNgKS5cbiAgICAgICAgaWYgKHN0YXJ0UGFydCA+IDAgJiYgc3RhcnRQYXJ0ICE9PSByb290RW5kKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldC5kaXIgPSByZXQucm9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgc2VwOiAnXFxcXCcsXG4gICAgZGVsaW1pdGVyOiAnOycsXG4gICAgd2luMzI6IG51bGwsXG4gICAgcG9zaXg6IG51bGxcbn07XG5leHBvcnQgY29uc3QgcG9zaXggPSB7XG4gICAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICAgIHJlc29sdmUoLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgICAgIGxldCByZXNvbHZlZFBhdGggPSAnJztcbiAgICAgICAgbGV0IHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhTZWdtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBpID49IDAgPyBwYXRoU2VnbWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZFBhdGggPSBgJHtwYXRofS8ke3Jlc29sdmVkUGF0aH1gO1xuICAgICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAgICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgICAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmcocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSwgJy8nLCBpc1Bvc2l4UGF0aFNlcGFyYXRvcik7XG4gICAgICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYC8ke3Jlc29sdmVkUGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFBhdGgubGVuZ3RoID4gMCA/IHJlc29sdmVkUGF0aCA6ICcuJztcbiAgICB9LFxuICAgIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHBhdGggPSBub3JtYWxpemVTdHJpbmcocGF0aCwgIWlzQWJzb2x1dGUsICcvJywgaXNQb3NpeFBhdGhTZXBhcmF0b3IpO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFpbGluZ1NlcGFyYXRvciA/ICcuLycgOiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWlsaW5nU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGAvJHtwYXRofWAgOiBwYXRoO1xuICAgIH0sXG4gICAgaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgfSxcbiAgICBqb2luKC4uLnBhdGhzKSB7XG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGpvaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gcGF0aHNbaV07XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhhcmcsICdwYXRoJyk7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkICs9IGAvJHthcmd9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgICB9LFxuICAgIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKGZyb20sICdmcm9tJyk7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHRvLCAndG8nKTtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSBsZWFkaW5nIGZvcndhcmQgc2xhc2hlcy5cbiAgICAgICAgZnJvbSA9IHBvc2l4LnJlc29sdmUoZnJvbSk7XG4gICAgICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb21TdGFydCA9IDE7XG4gICAgICAgIGNvbnN0IGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG4gICAgICAgIGNvbnN0IHRvU3RhcnQgPSAxO1xuICAgICAgICBjb25zdCB0b0xlbiA9IHRvLmxlbmd0aCAtIHRvU3RhcnQ7XG4gICAgICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbik7XG4gICAgICAgIGxldCBsYXN0Q29tbW9uU2VwID0gLTE7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nLydcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2BcbiAgICAgICAgLy8gYW5kIGBmcm9tYC5cbiAgICAgICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIG91dCArPSBvdXQubGVuZ3RoID09PSAwID8gJy4uJyA6ICcvLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXG4gICAgICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0cy5cbiAgICAgICAgcmV0dXJuIGAke291dH0ke3RvLnNsaWNlKHRvU3RhcnQgKyBsYXN0Q29tbW9uU2VwKX1gO1xuICAgIH0sXG4gICAgdG9OYW1lc3BhY2VkUGF0aChwYXRoKSB7XG4gICAgICAgIC8vIE5vbi1vcCBvbiBwb3NpeCBzeXN0ZW1zXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG4gICAgZGlybmFtZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNSb290ID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnLy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gICAgfSxcbiAgICBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhleHQsICdleHQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChleHQgPT09IHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9LFxuICAgIGV4dG5hbWUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcbiAgICAgICAgICAgIGVuZCA9PT0gLTEgfHxcbiAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXG4gICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IGVuZCAtIDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9LFxuICAgIGZvcm1hdDogX2Zvcm1hdC5iaW5kKG51bGwsICcvJyksXG4gICAgcGFyc2UocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICAgICAgICBzdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICBsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgICAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlID8gMSA6IHN0YXJ0UGFydDtcbiAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydCwgc3RhcnREb3QpO1xuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRQYXJ0ID4gMCkge1xuICAgICAgICAgICAgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgcmV0LmRpciA9ICcvJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgc2VwOiAnLycsXG4gICAgZGVsaW1pdGVyOiAnOicsXG4gICAgd2luMzI6IG51bGwsXG4gICAgcG9zaXg6IG51bGxcbn07XG5wb3NpeC53aW4zMiA9IHdpbjMyLndpbjMyID0gd2luMzI7XG5wb3NpeC5wb3NpeCA9IHdpbjMyLnBvc2l4ID0gcG9zaXg7XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5ub3JtYWxpemUgOiBwb3NpeC5ub3JtYWxpemUpO1xuZXhwb3J0IGNvbnN0IHJlc29sdmUgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLnJlc29sdmUgOiBwb3NpeC5yZXNvbHZlKTtcbmV4cG9ydCBjb25zdCByZWxhdGl2ZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIucmVsYXRpdmUgOiBwb3NpeC5yZWxhdGl2ZSk7XG5leHBvcnQgY29uc3QgZGlybmFtZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIuZGlybmFtZSA6IHBvc2l4LmRpcm5hbWUpO1xuZXhwb3J0IGNvbnN0IGJhc2VuYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5iYXNlbmFtZSA6IHBvc2l4LmJhc2VuYW1lKTtcbmV4cG9ydCBjb25zdCBleHRuYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5leHRuYW1lIDogcG9zaXguZXh0bmFtZSk7XG5leHBvcnQgY29uc3Qgc2VwID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5zZXAgOiBwb3NpeC5zZXApO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX2E7XG5jb25zdCBMQU5HVUFHRV9ERUZBVUxUID0gJ2VuJztcbmxldCBfaXNXaW5kb3dzID0gZmFsc2U7XG5sZXQgX2lzTWFjaW50b3NoID0gZmFsc2U7XG5sZXQgX2lzTGludXggPSBmYWxzZTtcbmxldCBfaXNMaW51eFNuYXAgPSBmYWxzZTtcbmxldCBfaXNOYXRpdmUgPSBmYWxzZTtcbmxldCBfaXNXZWIgPSBmYWxzZTtcbmxldCBfaXNFbGVjdHJvbiA9IGZhbHNlO1xubGV0IF9pc0lPUyA9IGZhbHNlO1xubGV0IF9pc0NJID0gZmFsc2U7XG5sZXQgX2xvY2FsZSA9IHVuZGVmaW5lZDtcbmxldCBfbGFuZ3VhZ2UgPSBMQU5HVUFHRV9ERUZBVUxUO1xubGV0IF90cmFuc2xhdGlvbnNDb25maWdGaWxlID0gdW5kZWZpbmVkO1xubGV0IF91c2VyQWdlbnQgPSB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgPyBnbG9iYWwgOiB7fSk7XG5sZXQgbm9kZVByb2Nlc3MgPSB1bmRlZmluZWQ7XG5pZiAodHlwZW9mIGdsb2JhbHMudnNjb2RlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFscy52c2NvZGUucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOYXRpdmUgZW52aXJvbm1lbnQgKHNhbmRib3hlZClcbiAgICBub2RlUHJvY2VzcyA9IGdsb2JhbHMudnNjb2RlLnByb2Nlc3M7XG59XG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOYXRpdmUgZW52aXJvbm1lbnQgKG5vbi1zYW5kYm94ZWQpXG4gICAgbm9kZVByb2Nlc3MgPSBwcm9jZXNzO1xufVxuY29uc3QgaXNFbGVjdHJvblByb2Nlc3MgPSB0eXBlb2YgKChfYSA9IG5vZGVQcm9jZXNzID09PSBudWxsIHx8IG5vZGVQcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZWN0cm9uKSA9PT0gJ3N0cmluZyc7XG5jb25zdCBpc0VsZWN0cm9uUmVuZGVyZXIgPSBpc0VsZWN0cm9uUHJvY2VzcyAmJiAobm9kZVByb2Nlc3MgPT09IG51bGwgfHwgbm9kZVByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVQcm9jZXNzLnR5cGUpID09PSAncmVuZGVyZXInO1xuLy8gV2ViIGVudmlyb25tZW50XG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgIWlzRWxlY3Ryb25SZW5kZXJlcikge1xuICAgIF91c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIF9pc1dpbmRvd3MgPSBfdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MnKSA+PSAwO1xuICAgIF9pc01hY2ludG9zaCA9IF91c2VyQWdlbnQuaW5kZXhPZignTWFjaW50b3NoJykgPj0gMDtcbiAgICBfaXNJT1MgPSAoX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwIHx8IF91c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpID49IDAgfHwgX3VzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKSA+PSAwKSAmJiAhIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIF9pc0xpbnV4ID0gX3VzZXJBZ2VudC5pbmRleE9mKCdMaW51eCcpID49IDA7XG4gICAgX2lzV2ViID0gdHJ1ZTtcbiAgICBfbG9jYWxlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICAgIF9sYW5ndWFnZSA9IF9sb2NhbGU7XG59XG4vLyBOYXRpdmUgZW52aXJvbm1lbnRcbmVsc2UgaWYgKHR5cGVvZiBub2RlUHJvY2VzcyA9PT0gJ29iamVjdCcpIHtcbiAgICBfaXNXaW5kb3dzID0gKG5vZGVQcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKTtcbiAgICBfaXNNYWNpbnRvc2ggPSAobm9kZVByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbiAgICBfaXNMaW51eCA9IChub2RlUHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jyk7XG4gICAgX2lzTGludXhTbmFwID0gX2lzTGludXggJiYgISFub2RlUHJvY2Vzcy5lbnZbJ1NOQVAnXSAmJiAhIW5vZGVQcm9jZXNzLmVudlsnU05BUF9SRVZJU0lPTiddO1xuICAgIF9pc0VsZWN0cm9uID0gaXNFbGVjdHJvblByb2Nlc3M7XG4gICAgX2lzQ0kgPSAhIW5vZGVQcm9jZXNzLmVudlsnQ0knXSB8fCAhIW5vZGVQcm9jZXNzLmVudlsnQlVJTERfQVJUSUZBQ1RTVEFHSU5HRElSRUNUT1JZJ107XG4gICAgX2xvY2FsZSA9IExBTkdVQUdFX0RFRkFVTFQ7XG4gICAgX2xhbmd1YWdlID0gTEFOR1VBR0VfREVGQVVMVDtcbiAgICBjb25zdCByYXdObHNDb25maWcgPSBub2RlUHJvY2Vzcy5lbnZbJ1ZTQ09ERV9OTFNfQ09ORklHJ107XG4gICAgaWYgKHJhd05sc0NvbmZpZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmxzQ29uZmlnID0gSlNPTi5wYXJzZShyYXdObHNDb25maWcpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBubHNDb25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzWycqJ107XG4gICAgICAgICAgICBfbG9jYWxlID0gbmxzQ29uZmlnLmxvY2FsZTtcbiAgICAgICAgICAgIC8vIFZTQ29kZSdzIGRlZmF1bHQgbGFuZ3VhZ2UgaXMgJ2VuJ1xuICAgICAgICAgICAgX2xhbmd1YWdlID0gcmVzb2x2ZWQgPyByZXNvbHZlZCA6IExBTkdVQUdFX0RFRkFVTFQ7XG4gICAgICAgICAgICBfdHJhbnNsYXRpb25zQ29uZmlnRmlsZSA9IG5sc0NvbmZpZy5fdHJhbnNsYXRpb25zQ29uZmlnRmlsZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc05hdGl2ZSA9IHRydWU7XG59XG4vLyBVbmtub3duIGVudmlyb25tZW50XG5lbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBwbGF0Zm9ybS4nKTtcbn1cbmxldCBfcGxhdGZvcm0gPSAwIC8qIFdlYiAqLztcbmlmIChfaXNNYWNpbnRvc2gpIHtcbiAgICBfcGxhdGZvcm0gPSAxIC8qIE1hYyAqLztcbn1cbmVsc2UgaWYgKF9pc1dpbmRvd3MpIHtcbiAgICBfcGxhdGZvcm0gPSAzIC8qIFdpbmRvd3MgKi87XG59XG5lbHNlIGlmIChfaXNMaW51eCkge1xuICAgIF9wbGF0Zm9ybSA9IDIgLyogTGludXggKi87XG59XG5leHBvcnQgY29uc3QgaXNXaW5kb3dzID0gX2lzV2luZG93cztcbmV4cG9ydCBjb25zdCBpc01hY2ludG9zaCA9IF9pc01hY2ludG9zaDtcbmV4cG9ydCBjb25zdCBpc0xpbnV4ID0gX2lzTGludXg7XG5leHBvcnQgY29uc3QgaXNOYXRpdmUgPSBfaXNOYXRpdmU7XG5leHBvcnQgY29uc3QgaXNXZWIgPSBfaXNXZWI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoX2lzV2ViICYmIHR5cGVvZiBnbG9iYWxzLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbicpO1xuZXhwb3J0IGNvbnN0IGlzSU9TID0gX2lzSU9TO1xuZXhwb3J0IGNvbnN0IHVzZXJBZ2VudCA9IF91c2VyQWdlbnQ7XG4vKipcbiAqIFRoZSBsYW5ndWFnZSB1c2VkIGZvciB0aGUgdXNlciBpbnRlcmZhY2UuIFRoZSBmb3JtYXQgb2ZcbiAqIHRoZSBzdHJpbmcgaXMgYWxsIGxvd2VyIGNhc2UgKGUuZy4gemgtdHcgZm9yIFRyYWRpdGlvbmFsXG4gKiBDaGluZXNlKVxuICovXG5leHBvcnQgY29uc3QgbGFuZ3VhZ2UgPSBfbGFuZ3VhZ2U7XG4vKipcbiAqIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sIzp+OnRleHQ9dGhhbiUyMDQlMkMlMjB0aGVuLSxzZXQlMjB0aW1lb3V0JTIwdG8lMjA0LC0uXG4gKlxuICogV29ya3Mgc2ltaWxhcmx5IHRvIGBzZXRUaW1lb3V0KDApYCBidXQgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGUgNG1zIGFydGlmaWNpYWwgZGVsYXlcbiAqIHRoYXQgYnJvd3NlcnMgc2V0IHdoZW4gdGhlIG5lc3RpbmcgbGV2ZWwgaXMgPiA1LlxuICovXG5leHBvcnQgY29uc3Qgc2V0VGltZW91dDAgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFscy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFscy5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgIGxldCBwZW5kaW5nID0gW107XG4gICAgICAgIGdsb2JhbHMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwZW5kaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuaWQgPT09IGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUuY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0SWQgPSAwO1xuICAgICAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBteUlkID0gKytsYXN0SWQ7XG4gICAgICAgICAgICBwZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBteUlkLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnbG9iYWxzLnBvc3RNZXNzYWdlKHsgdnNjb2RlU2NoZWR1bGVBc3luY1dvcms6IG15SWQgfSwgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4gc2V0VGltZW91dChjYWxsYmFjayk7XG59KSgpO1xuZXhwb3J0IGNvbnN0IE9TID0gKF9pc01hY2ludG9zaCB8fCBfaXNJT1MgPyAyIC8qIE1hY2ludG9zaCAqLyA6IChfaXNXaW5kb3dzID8gMSAvKiBXaW5kb3dzICovIDogMyAvKiBMaW51eCAqLykpO1xubGV0IF9pc0xpdHRsZUVuZGlhbiA9IHRydWU7XG5sZXQgX2lzTGl0dGxlRW5kaWFuQ29tcHV0ZWQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICBpZiAoIV9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkKSB7XG4gICAgICAgIF9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGVzdCA9IG5ldyBVaW50OEFycmF5KDIpO1xuICAgICAgICB0ZXN0WzBdID0gMTtcbiAgICAgICAgdGVzdFsxXSA9IDI7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDE2QXJyYXkodGVzdC5idWZmZXIpO1xuICAgICAgICBfaXNMaXR0bGVFbmRpYW4gPSAodmlld1swXSA9PT0gKDIgPDwgOCkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc0xpdHRsZUVuZGlhbjtcbn1cbmV4cG9ydCBjb25zdCBpc0Nocm9tZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPj0gMCk7XG5leHBvcnQgY29uc3QgaXNGaXJlZm94ID0gISEodXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPj0gMCk7XG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAhISghaXNDaHJvbWUgJiYgKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgPj0gMCkpO1xuZXhwb3J0IGNvbnN0IGlzRWRnZSA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRWRnLycpID49IDApO1xuZXhwb3J0IGNvbnN0IGlzQW5kcm9pZCA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpID49IDApO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBnbG9iYWxzLCBpc01hY2ludG9zaCwgaXNXaW5kb3dzIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5sZXQgc2FmZVByb2Nlc3M7XG4vLyBOYXRpdmUgc2FuZGJveCBlbnZpcm9ubWVudFxuaWYgKHR5cGVvZiBnbG9iYWxzLnZzY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbHMudnNjb2RlLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgc2FuZGJveFByb2Nlc3MgPSBnbG9iYWxzLnZzY29kZS5wcm9jZXNzO1xuICAgIHNhZmVQcm9jZXNzID0ge1xuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiBzYW5kYm94UHJvY2Vzcy5wbGF0Zm9ybTsgfSxcbiAgICAgICAgZ2V0IGFyY2goKSB7IHJldHVybiBzYW5kYm94UHJvY2Vzcy5hcmNoOyB9LFxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuZW52OyB9LFxuICAgICAgICBjd2QoKSB7IHJldHVybiBzYW5kYm94UHJvY2Vzcy5jd2QoKTsgfVxuICAgIH07XG59XG4vLyBOYXRpdmUgbm9kZS5qcyBlbnZpcm9ubWVudFxuZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2FmZVByb2Nlc3MgPSB7XG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm07IH0sXG4gICAgICAgIGdldCBhcmNoKCkgeyByZXR1cm4gcHJvY2Vzcy5hcmNoOyB9LFxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gcHJvY2Vzcy5lbnY7IH0sXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuIHByb2Nlc3MuZW52WydWU0NPREVfQ1dEJ10gfHwgcHJvY2Vzcy5jd2QoKTsgfVxuICAgIH07XG59XG4vLyBXZWIgZW52aXJvbm1lbnRcbmVsc2Uge1xuICAgIHNhZmVQcm9jZXNzID0ge1xuICAgICAgICAvLyBTdXBwb3J0ZWRcbiAgICAgICAgZ2V0IHBsYXRmb3JtKCkgeyByZXR1cm4gaXNXaW5kb3dzID8gJ3dpbjMyJyA6IGlzTWFjaW50b3NoID8gJ2RhcndpbicgOiAnbGludXgnOyB9LFxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgLyogYXJjaCBpcyB1bmRlZmluZWQgaW4gd2ViICovIH0sXG4gICAgICAgIC8vIFVuc3VwcG9ydGVkXG4gICAgICAgIGdldCBlbnYoKSB7IHJldHVybiB7fTsgfSxcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gJy8nOyB9XG4gICAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGBjd2RgIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqXG4gKiBOb3RlOiBpbiB3ZWIsIHRoaXMgcHJvcGVydHkgaXMgaGFyZGNvZGVkIHRvIGJlIGAvYC5cbiAqL1xuZXhwb3J0IGNvbnN0IGN3ZCA9IHNhZmVQcm9jZXNzLmN3ZDtcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGBlbnZgIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqXG4gKiBOb3RlOiBpbiB3ZWIsIHRoaXMgcHJvcGVydHkgaXMgaGFyZGNvZGVkIHRvIGJlIGB7fWAuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBzYWZlUHJvY2Vzcy5lbnY7XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgcGxhdGZvcm1gIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtID0gc2FmZVByb2Nlc3MucGxhdGZvcm07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmNvbnN0IGhhc1BlcmZvcm1hbmNlTm93ID0gKGdsb2JhbHMucGVyZm9ybWFuY2UgJiYgdHlwZW9mIGdsb2JhbHMucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKTtcbmV4cG9ydCBjbGFzcyBTdG9wV2F0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGhpZ2hSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMuX2hpZ2hSZXNvbHV0aW9uID0gaGFzUGVyZm9ybWFuY2VOb3cgJiYgaGlnaFJlc29sdXRpb247XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX25vdygpO1xuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGhpZ2hSZXNvbHV0aW9uID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3BXYXRjaChoaWdoUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1lID0gdGhpcy5fbm93KCk7XG4gICAgfVxuICAgIGVsYXBzZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxuICAgIF9ub3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdoUmVzb2x1dGlvbiA/IGdsb2JhbHMucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuaW1wb3J0IHsgTFJVQ2FjaGVkQ29tcHV0ZWQgfSBmcm9tICcuL2NhY2hlLmpzJztcbmltcG9ydCB7IExhenkgfSBmcm9tICcuL2xhenkuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdHIudHJpbSgpLmxlbmd0aCA9PT0gMDtcbn1cbmNvbnN0IF9mb3JtYXRSZWdleHAgPSAveyhcXGQrKX0vZztcbi8qKlxuICogSGVscGVyIHRvIHByb2R1Y2UgYSBzdHJpbmcgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMuIEluc2VydCB2YXJpYWJsZSBzZWdtZW50c1xuICogaW50byB0aGUgc3RyaW5nIHVzaW5nIHRoZSB7bn0gbm90YXRpb24gd2hlcmUgTiBpcyB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IGZvbGxvd2luZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHZhbHVlIHN0cmluZyB0byB3aGljaCBmb3JtYXR0aW5nIGlzIGFwcGxpZWRcbiAqIEBwYXJhbSBhcmdzIHJlcGxhY2VtZW50cyBmb3Ige259LWVudHJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKF9mb3JtYXRSZWdleHAsIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGlkeCkgfHwgaWR4IDwgMCB8fCBpZHggPj0gYXJncy5sZW5ndGggP1xuICAgICAgICAgICAgbWF0Y2ggOlxuICAgICAgICAgICAgYXJnc1tpZHhdO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBIVE1MIGNoYXJhY3RlcnMgaW5zaWRlIHRoZSBzdHJpbmcgdG8gdXNlIGVudGl0aWVzIGluc3RlYWQuIE1ha2VzIHRoZSBzdHJpbmcgc2FmZSBmcm9tXG4gKiBiZWluZyB1c2VkIGUuZy4gaW4gSFRNTEVsZW1lbnQuaW5uZXJIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC9bPD4mXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSAnPCc6IHJldHVybiAnJmx0Oyc7XG4gICAgICAgICAgICBjYXNlICc+JzogcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzIGluIGEgZ2l2ZW4gc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFxbXFxdXFwoXFwpXS9nLCAnXFxcXCQmJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBoYXlzdGFjay5cbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbSAoZGVmYXVsdCBpcyBhIGJsYW5rKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbShoYXlzdGFjaywgbmVlZGxlID0gJyAnKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGx0cmltKGhheXN0YWNrLCBuZWVkbGUpO1xuICAgIHJldHVybiBydHJpbSh0cmltbWVkLCBuZWVkbGUpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsdHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aDtcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgb2Zmc2V0KSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIG5lZWRsZUxlbjtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgZW5kIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aCwgaGF5c3RhY2tMZW4gPSBoYXlzdGFjay5sZW5ndGg7XG4gICAgaWYgKG5lZWRsZUxlbiA9PT0gMCB8fCBoYXlzdGFja0xlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSBoYXlzdGFja0xlbiwgaWR4ID0gLTE7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWR4ID0gaGF5c3RhY2subGFzdEluZGV4T2YobmVlZGxlLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEgfHwgaWR4ICsgbmVlZGxlTGVuICE9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBpZHg7XG4gICAgfVxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0U2ltcGxlMlJlZ0V4cFBhdHRlcm4ocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCAnXFxcXCQmJykucmVwbGFjZSgvW1xcKl0vZywgJy4qJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBXaWxkY2FyZHMocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1xcKi9nLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVnRXhwKHNlYXJjaFN0cmluZywgaXNSZWdleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHJlZ2V4IGZyb20gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghaXNSZWdleCkge1xuICAgICAgICBzZWFyY2hTdHJpbmcgPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHNlYXJjaFN0cmluZyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndob2xlV29yZCkge1xuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZyA9ICdcXFxcYicgKyBzZWFyY2hTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXFxCLy50ZXN0KHNlYXJjaFN0cmluZy5jaGFyQXQoc2VhcmNoU3RyaW5nLmxlbmd0aCAtIDEpKSkge1xuICAgICAgICAgICAgc2VhcmNoU3RyaW5nID0gc2VhcmNoU3RyaW5nICsgJ1xcXFxiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbW9kaWZpZXJzID0gJyc7XG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgICAgIG1vZGlmaWVycyArPSAnZyc7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5tYXRjaENhc2UpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdpJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubXVsdGlsaW5lKSB7XG4gICAgICAgIG1vZGlmaWVycyArPSAnbSc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuaWNvZGUpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICd1JztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ0V4cExlYWRzVG9FbmRsZXNzTG9vcChyZWdleHApIHtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXG4gICAgLy8gYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmdcbiAgICBpZiAocmVnZXhwLnNvdXJjZSA9PT0gJ14nIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeJCcgfHwgcmVnZXhwLnNvdXJjZSA9PT0gJyQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeXFxcXHMqJCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBjaGVjayBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IGFkdmFuY2VcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXG4gICAgY29uc3QgbWF0Y2ggPSByZWdleHAuZXhlYygnJyk7XG4gICAgcmV0dXJuICEhKG1hdGNoICYmIHJlZ2V4cC5sYXN0SW5kZXggPT09IDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ0V4cEZsYWdzKHJlZ2V4cCkge1xuICAgIHJldHVybiAocmVnZXhwLmdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICAgICArIChyZWdleHAuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKVxuICAgICAgICArIChyZWdleHAubXVsdGlsaW5lID8gJ20nIDogJycpXG4gICAgICAgICsgKHJlZ2V4cCAvKiBzdGFuZGFsb25lIGVkaXRvciBjb21waWxhdGlvbiAqLy51bmljb2RlID8gJ3UnIDogJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0TGluZXMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbn1cbi8qKlxuICogUmV0dXJucyBmaXJzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIFRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIHN0cmluZy5cbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyBlbnRpcmUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFkaW5nV2hpdGVzcGFjZShzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBTcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogVGFiICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG59XG4vKipcbiAqIFJldHVybnMgbGFzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFzdE5vbldoaXRlc3BhY2VJbmRleChzdHIsIHN0YXJ0SW5kZXggPSBzdHIubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIFRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKDsgYVN0YXJ0IDwgYUVuZCAmJiBiU3RhcnQgPCBiRW5kOyBhU3RhcnQrKywgYlN0YXJ0KyspIHtcbiAgICAgICAgbGV0IGNvZGVBID0gYS5jaGFyQ29kZUF0KGFTdGFydCk7XG4gICAgICAgIGxldCBjb2RlQiA9IGIuY2hhckNvZGVBdChiU3RhcnQpO1xuICAgICAgICBpZiAoY29kZUEgPCBjb2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVBID4gY29kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFMZW4gPSBhRW5kIC0gYVN0YXJ0O1xuICAgIGNvbnN0IGJMZW4gPSBiRW5kIC0gYlN0YXJ0O1xuICAgIGlmIChhTGVuIDwgYkxlbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFMZW4gPiBiTGVuKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlSWdub3JlQ2FzZShhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIsIDAsIGEubGVuZ3RoLCAwLCBiLmxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2UoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKDsgYVN0YXJ0IDwgYUVuZCAmJiBiU3RhcnQgPCBiRW5kOyBhU3RhcnQrKywgYlN0YXJ0KyspIHtcbiAgICAgICAgbGV0IGNvZGVBID0gYS5jaGFyQ29kZUF0KGFTdGFydCk7XG4gICAgICAgIGxldCBjb2RlQiA9IGIuY2hhckNvZGVBdChiU3RhcnQpO1xuICAgICAgICBpZiAoY29kZUEgPT09IGNvZGVCKSB7XG4gICAgICAgICAgICAvLyBlcXVhbFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVBID49IDEyOCB8fCBjb2RlQiA+PSAxMjgpIHtcbiAgICAgICAgICAgIC8vIG5vdCBBU0NJSSBsZXR0ZXJzIC0+IGZhbGxiYWNrIHRvIGxvd2VyLWNhc2luZyBzdHJpbmdzXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZyhhLnRvTG93ZXJDYXNlKCksIGIudG9Mb3dlckNhc2UoKSwgYVN0YXJ0LCBhRW5kLCBiU3RhcnQsIGJFbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcHBlciBsb3dlci1jYXNlIGFzY2lpIGxldHRlciBvbnRvIHVwcGVyLWNhc2UgdmFyaW5hdHNcbiAgICAgICAgLy8gWzk3LTEyMl0gKGxvd2VyIGFzY2lpKSAtLT4gWzY1LTkwXSAodXBwZXIgYXNjaWkpXG4gICAgICAgIGlmIChpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZUEpKSB7XG4gICAgICAgICAgICBjb2RlQSAtPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb3dlckFzY2lpTGV0dGVyKGNvZGVCKSkge1xuICAgICAgICAgICAgY29kZUIgLT0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGFyZSBib3RoIGNvZGUgcG9pbnRzXG4gICAgICAgIGNvbnN0IGRpZmYgPSBjb2RlQSAtIGNvZGVCO1xuICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICAgIGNvbnN0IGFMZW4gPSBhRW5kIC0gYVN0YXJ0O1xuICAgIGNvbnN0IGJMZW4gPSBiRW5kIC0gYlN0YXJ0O1xuICAgIGlmIChhTGVuIDwgYkxlbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFMZW4gPiBiTGVuKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0xvd2VyQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDk3IC8qIGEgKi8gJiYgY29kZSA8PSAxMjIgLyogeiAqLztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDY1IC8qIEEgKi8gJiYgY29kZSA8PSA5MCAvKiBaICovO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsc0lnbm9yZUNhc2UoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2UoYSwgYikgPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUpIHtcbiAgICBjb25zdCBjYW5kaWRhdGVMZW5ndGggPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShzdHIsIGNhbmRpZGF0ZSwgMCwgY2FuZGlkYXRlTGVuZ3RoKSA9PT0gMDtcbn1cbi8qKlxuICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgY29tbW9uIHByZWZpeCBvZiB0aGUgdHdvIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25QcmVmaXhMZW5ndGgoYSwgYikge1xuICAgIGxldCBpLCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGkpICE9PSBiLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBzdWZmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4TGVuZ3RoKGEsIGIpIHtcbiAgICBsZXQgaSwgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBjb25zdCBhTGFzdEluZGV4ID0gYS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGJMYXN0SW5kZXggPSBiLmxlbmd0aCAtIDE7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChhLmNoYXJDb2RlQXQoYUxhc3RJbmRleCAtIGkpICE9PSBiLmNoYXJDb2RlQXQoYkxhc3RJbmRleCAtIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgweEQ4MDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhEQkZGKTtcbn1cbi8qKlxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Vycm9nYXRlX3BhaXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgweERDMDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhERkZGKTtcbn1cbi8qKlxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Vycm9nYXRlX3BhaXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDb2RlUG9pbnQoaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKSB7XG4gICAgcmV0dXJuICgoaGlnaFN1cnJvZ2F0ZSAtIDB4RDgwMCkgPDwgMTApICsgKGxvd1N1cnJvZ2F0ZSAtIDB4REMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG4gKiBnZXQgdGhlIGNvZGUgcG9pbnQgdGhhdCBiZWdpbnMgYXQgb2Zmc2V0IGBvZmZzZXRgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0Q29kZVBvaW50KHN0ciwgbGVuLCBvZmZzZXQpIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkgJiYgb2Zmc2V0ICsgMSA8IGxlbikge1xuICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcbiAgICAgICAgaWYgKGlzTG93U3Vycm9nYXRlKG5leHRDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ29kZVBvaW50KGNoYXJDb2RlLCBuZXh0Q2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZTtcbn1cbi8qKlxuICogZ2V0IHRoZSBjb2RlIHBvaW50IHRoYXQgZW5kcyByaWdodCBiZWZvcmUgb2Zmc2V0IGBvZmZzZXRgXG4gKi9cbmZ1bmN0aW9uIGdldFByZXZDb2RlUG9pbnQoc3RyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDEpO1xuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkgJiYgb2Zmc2V0ID4gMSkge1xuICAgICAgICBjb25zdCBwcmV2Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgLSAyKTtcbiAgICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShwcmV2Q2hhckNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUNvZGVQb2ludChwcmV2Q2hhckNvZGUsIGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhckNvZGU7XG59XG5leHBvcnQgY2xhc3MgQ29kZVBvaW50SXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0ciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICAgIHRoaXMuX2xlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgc2V0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIHByZXZDb2RlUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGdldFByZXZDb2RlUG9pbnQodGhpcy5fc3RyLCB0aGlzLl9vZmZzZXQpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgLT0gKGNvZGVQb2ludCA+PSA2NTUzNiAvKiBVTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIG5leHRDb2RlUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGdldE5leHRDb2RlUG9pbnQodGhpcy5fc3RyLCB0aGlzLl9sZW4sIHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIFVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICB9XG4gICAgZW9sKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29mZnNldCA+PSB0aGlzLl9sZW4pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBHcmFwaGVtZUl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdHIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdGhpcy5faXRlcmF0b3IgPSBuZXcgQ29kZVBvaW50SXRlcmF0b3Ioc3RyLCBvZmZzZXQpO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlcmF0b3Iub2Zmc2V0O1xuICAgIH1cbiAgICBuZXh0R3JhcGhlbWVMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoZW1lQnJlYWtUcmVlID0gR3JhcGhlbWVCcmVha1RyZWUuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcbiAgICAgICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IGl0ZXJhdG9yLm9mZnNldDtcbiAgICAgICAgbGV0IGdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUoaXRlcmF0b3IubmV4dENvZGVQb2ludCgpKTtcbiAgICAgICAgd2hpbGUgKCFpdGVyYXRvci5lb2woKSkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgbmV4dEdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUoaXRlcmF0b3IubmV4dENvZGVQb2ludCgpKTtcbiAgICAgICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShncmFwaGVtZUJyZWFrVHlwZSwgbmV4dEdyYXBoZW1lQnJlYWtUeXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgaXRlcmF0b3IgYmFja1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNldE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGhlbWVCcmVha1R5cGUgPSBuZXh0R3JhcGhlbWVCcmVha1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpdGVyYXRvci5vZmZzZXQgLSBpbml0aWFsT2Zmc2V0KTtcbiAgICB9XG4gICAgcHJldkdyYXBoZW1lTGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKSk7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2R3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShpdGVyYXRvci5wcmV2Q29kZVBvaW50KCkpO1xuICAgICAgICAgICAgaWYgKGJyZWFrQmV0d2VlbkdyYXBoZW1lQnJlYWtUeXBlKHByZXZHcmFwaGVtZUJyZWFrVHlwZSwgZ3JhcGhlbWVCcmVha1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBpdGVyYXRvciBiYWNrXG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc2V0T2Zmc2V0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaGVtZUJyZWFrVHlwZSA9IHByZXZHcmFwaGVtZUJyZWFrVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGluaXRpYWxPZmZzZXQgLSBpdGVyYXRvci5vZmZzZXQpO1xuICAgIH1cbiAgICBlb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRvci5lb2woKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbmV4dENoYXJMZW5ndGgoc3RyLCBpbml0aWFsT2Zmc2V0KSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgR3JhcGhlbWVJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xuICAgIHJldHVybiBpdGVyYXRvci5uZXh0R3JhcGhlbWVMZW5ndGgoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmV2Q2hhckxlbmd0aChzdHIsIGluaXRpYWxPZmZzZXQpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBHcmFwaGVtZUl0ZXJhdG9yKHN0ciwgaW5pdGlhbE9mZnNldCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLnByZXZHcmFwaGVtZUxlbmd0aCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYXJDb250YWluaW5nT2Zmc2V0KHN0ciwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDAgJiYgaXNMb3dTdXJyb2dhdGUoc3RyLmNoYXJDb2RlQXQob2Zmc2V0KSkpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgfVxuICAgIGNvbnN0IGVuZE9mZnNldCA9IG9mZnNldCArIG5leHRDaGFyTGVuZ3RoKHN0ciwgb2Zmc2V0KTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGVuZE9mZnNldCAtIHByZXZDaGFyTGVuZ3RoKHN0ciwgZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gW3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRdO1xufVxuLyoqXG4gKiBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYWluL3J0bC10ZXN0LmpzXG4gKi9cbmNvbnN0IENPTlRBSU5TX1JUTCA9IC8oPzpbXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RDAtXFx1MDVGNFxcdTA2MDhcXHUwNjBCXFx1MDYwRFxcdTA2MUItXFx1MDY0QVxcdTA2NkQtXFx1MDY2RlxcdTA2NzEtXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwN0ZFLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODMwLVxcdTA4NThcXHUwODVFLVxcdTA4OEVcXHUwOEEwLVxcdTA4QzlcXHUyMDBGXFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkQzRFxcdUZENTAtXFx1RkRDN1xcdUZERjAtXFx1RkRGQ1xcdUZFNzAtXFx1RkVGQ118XFx1RDgwMltcXHVEQzAwLVxcdUREMUJcXHVERDIwLVxcdURFMDBcXHVERTEwLVxcdURFMzVcXHVERTQwLVxcdURFRTRcXHVERUVCLVxcdURGMzVcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVERDIzXFx1REU4MC1cXHVERUE5XFx1REVBRC1cXHVERjQ1XFx1REY1MS1cXHVERjgxXFx1REY4Ni1cXHVERkY2XXxcXHVEODNBW1xcdURDMDAtXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENEItXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURFQkJdKS87XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyBhbnkgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBpcyBjbGFzc2lmaWVkIGFzIFwiUlwiIG9yIFwiQUxcIi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUlRMKHN0cikge1xuICAgIHJldHVybiBDT05UQUlOU19SVEwudGVzdChzdHIpO1xufVxuY29uc3QgSVNfQkFTSUNfQVNDSUkgPSAvXltcXHRcXG5cXHJcXHgyMC1cXHg3RV0qJC87XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyBvbmx5IGJhc2ljIEFTQ0lJIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlIDMyIC0gMTI2IChpbmNsdWRpbmcgMzIgYW5kIDEyNikgb3IgXFxuLCBcXHIsIFxcdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNpY0FTQ0lJKHN0cikge1xuICAgIHJldHVybiBJU19CQVNJQ19BU0NJSS50ZXN0KHN0cik7XG59XG5leHBvcnQgY29uc3QgVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTID0gL1tcXHUyMDI4XFx1MjAyOV0vOyAvLyBMSU5FIFNFUEFSQVRPUiAoTFMpIG9yIFBBUkFHUkFQSCBTRVBBUkFUT1IgKFBTKVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHN0cmAgY29udGFpbnMgdW51c3VhbCBsaW5lIHRlcm1pbmF0b3JzLCBsaWtlIExTIG9yIFBTXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1VudXN1YWxMaW5lVGVybWluYXRvcnMoc3RyKSB7XG4gICAgcmV0dXJuIFVOVVNVQUxfTElORV9URVJNSU5BVE9SUy50ZXN0KHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGdWxsV2lkdGhDaGFyYWN0ZXIoY2hhckNvZGUpIHtcbiAgICAvLyBEbyBhIGNoZWFwIHRyaWNrIHRvIGJldHRlciBzdXBwb3J0IHdyYXBwaW5nIG9mIHdpZGUgY2hhcmFjdGVycywgdHJlYXQgdGhlbSBhcyAyIGNvbHVtbnNcbiAgICAvLyBodHRwOi8vanJncmFwaGl4Lm5ldC9yZXNlYXJjaC91bmljb2RlX2Jsb2Nrcy5waHBcbiAgICAvLyAgICAgICAgICAyRTgwIC0gMkVGRiAgIENKSyBSYWRpY2FscyBTdXBwbGVtZW50XG4gICAgLy8gICAgICAgICAgMkYwMCAtIDJGREYgICBLYW5neGkgUmFkaWNhbHNcbiAgICAvLyAgICAgICAgICAyRkYwIC0gMkZGRiAgIElkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcbiAgICAvLyAgICAgICAgICAzMDAwIC0gMzAzRiAgIENKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblxuICAgIC8vICAgICAgICAgIDMwNDAgLSAzMDlGICAgSGlyYWdhbmFcbiAgICAvLyAgICAgICAgICAzMEEwIC0gMzBGRiAgIEthdGFrYW5hXG4gICAgLy8gICAgICAgICAgMzEwMCAtIDMxMkYgICBCb3BvbW9mb1xuICAgIC8vICAgICAgICAgIDMxMzAgLSAzMThGICAgSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xuICAgIC8vICAgICAgICAgIDMxOTAgLSAzMTlGICAgS2FuYnVuXG4gICAgLy8gICAgICAgICAgMzFBMCAtIDMxQkYgICBCb3BvbW9mbyBFeHRlbmRlZFxuICAgIC8vICAgICAgICAgIDMxRjAgLSAzMUZGICAgS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1xuICAgIC8vICAgICAgICAgIDMyMDAgLSAzMkZGICAgRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xuICAgIC8vICAgICAgICAgIDMzMDAgLSAzM0ZGICAgQ0pLIENvbXBhdGliaWxpdHlcbiAgICAvLyAgICAgICAgICAzNDAwIC0gNERCRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcbiAgICAvLyAgICAgICAgICA0REMwIC0gNERGRiAgIFlpamluZyBIZXhhZ3JhbSBTeW1ib2xzXG4gICAgLy8gICAgICAgICAgNEUwMCAtIDlGRkYgICBDSksgVW5pZmllZCBJZGVvZ3JhcGhzXG4gICAgLy8gICAgICAgICAgQTAwMCAtIEE0OEYgICBZaSBTeWxsYWJsZXNcbiAgICAvLyAgICAgICAgICBBNDkwIC0gQTRDRiAgIFlpIFJhZGljYWxzXG4gICAgLy8gICAgICAgICAgQUMwMCAtIEQ3QUYgICBIYW5ndWwgU3lsbGFibGVzXG4gICAgLy8gW0lHTk9SRV0gRDgwMCAtIERCN0YgICBIaWdoIFN1cnJvZ2F0ZXNcbiAgICAvLyBbSUdOT1JFXSBEQjgwIC0gREJGRiAgIEhpZ2ggUHJpdmF0ZSBVc2UgU3Vycm9nYXRlc1xuICAgIC8vIFtJR05PUkVdIERDMDAgLSBERkZGICAgTG93IFN1cnJvZ2F0ZXNcbiAgICAvLyBbSUdOT1JFXSBFMDAwIC0gRjhGRiAgIFByaXZhdGUgVXNlIEFyZWFcbiAgICAvLyAgICAgICAgICBGOTAwIC0gRkFGRiAgIENKSyBDb21wYXRpYmlsaXR5IElkZW9ncmFwaHNcbiAgICAvLyBbSUdOT1JFXSBGQjAwIC0gRkI0RiAgIEFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXG4gICAgLy8gW0lHTk9SRV0gRkI1MCAtIEZERkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcbiAgICAvLyBbSUdOT1JFXSBGRTAwIC0gRkUwRiAgIFZhcmlhdGlvbiBTZWxlY3RvcnNcbiAgICAvLyBbSUdOT1JFXSBGRTIwIC0gRkUyRiAgIENvbWJpbmluZyBIYWxmIE1hcmtzXG4gICAgLy8gW0lHTk9SRV0gRkUzMCAtIEZFNEYgICBDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1xuICAgIC8vIFtJR05PUkVdIEZFNTAgLSBGRTZGICAgU21hbGwgRm9ybSBWYXJpYW50c1xuICAgIC8vIFtJR05PUkVdIEZFNzAgLSBGRUZGICAgQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXG4gICAgLy8gICAgICAgICAgRkYwMCAtIEZGRUYgICBIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIC8vICAgICAgICAgICAgICAgW2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbGZ3aWR0aF9hbmRfZnVsbHdpZHRoX2Zvcm1zXVxuICAgIC8vICAgICAgICAgICAgICAgb2Ygd2hpY2ggRkYwMSAtIEZGNUUgZnVsbHdpZHRoIEFTQ0lJIG9mIDIxIHRvIDdFXG4gICAgLy8gW0lHTk9SRV0gICAgYW5kIEZGNjUgLSBGRkRDIGhhbGZ3aWR0aCBvZiBLYXRha2FuYSBhbmQgSGFuZ3VsXG4gICAgLy8gW0lHTk9SRV0gRkZGMCAtIEZGRkYgICBTcGVjaWFsc1xuICAgIHJldHVybiAoKGNoYXJDb2RlID49IDB4MkU4MCAmJiBjaGFyQ29kZSA8PSAweEQ3QUYpXG4gICAgICAgIHx8IChjaGFyQ29kZSA+PSAweEY5MDAgJiYgY2hhckNvZGUgPD0gMHhGQUZGKVxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGRjAxICYmIGNoYXJDb2RlIDw9IDB4RkY1RSkpO1xufVxuLyoqXG4gKiBBIGZhc3QgZnVuY3Rpb24gKHRoZXJlZm9yZSBpbXByZWNpc2UpIHRvIGNoZWNrIGlmIGNvZGUgcG9pbnRzIGFyZSBlbW9qaXMuXG4gKiBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYWluL2Vtb2ppLXRlc3QuanNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1vamlJbXByZWNpc2UoeCkge1xuICAgIHJldHVybiAoKHggPj0gMHgxRjFFNiAmJiB4IDw9IDB4MUYxRkYpIHx8ICh4ID09PSA4OTg2KSB8fCAoeCA9PT0gODk4NykgfHwgKHggPT09IDkyMDApXG4gICAgICAgIHx8ICh4ID09PSA5MjAzKSB8fCAoeCA+PSA5NzI4ICYmIHggPD0gMTAxNzUpIHx8ICh4ID09PSAxMTA4OCkgfHwgKHggPT09IDExMDkzKVxuICAgICAgICB8fCAoeCA+PSAxMjc3NDQgJiYgeCA8PSAxMjg1OTEpIHx8ICh4ID49IDEyODY0MCAmJiB4IDw9IDEyODc2NClcbiAgICAgICAgfHwgKHggPj0gMTI4OTkyICYmIHggPD0gMTI5MDA4KSB8fCAoeCA+PSAxMjkyODAgJiYgeCA8PSAxMjk1MzUpXG4gICAgICAgIHx8ICh4ID49IDEyOTY0OCAmJiB4IDw9IDEyOTc4MikpO1xufVxuLy8gLS0gVVRGLTggQk9NXG5leHBvcnQgY29uc3QgVVRGOF9CT01fQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTI3OSAvKiBVVEY4X0JPTSAqLyk7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aFVURjhCT00oc3RyKSB7XG4gICAgcmV0dXJuICEhKHN0ciAmJiBzdHIubGVuZ3RoID4gMCAmJiBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkgLyogVVRGOF9CT00gKi8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKHRhcmdldCwgaWdub3JlRXNjYXBlZENoYXJzID0gZmFsc2UpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpZ25vcmVFc2NhcGVkQ2hhcnMpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJlcGxhY2UoL1xcXFwuL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC50b0xvd2VyQ2FzZSgpICE9PSB0YXJnZXQ7XG59XG4vKipcbiAqIFByb2R1Y2VzICdhJy0neicsIGZvbGxvd2VkIGJ5ICdBJy0nWicuLi4gZm9sbG93ZWQgYnkgJ2EnLSd6JywgZXRjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlTGV0dGVySGFzaChuKSB7XG4gICAgY29uc3QgTEVUVEVSU19DTlQgPSAoOTAgLyogWiAqLyAtIDY1IC8qIEEgKi8gKyAxKTtcbiAgICBuID0gbiAlICgyICogTEVUVEVSU19DTlQpO1xuICAgIGlmIChuIDwgTEVUVEVSU19DTlQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgLyogYSAqLyArIG4pO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSAvKiBBICovICsgbiAtIExFVFRFUlNfQ05UKTtcbn1cbmZ1bmN0aW9uIGJyZWFrQmV0d2VlbkdyYXBoZW1lQnJlYWtUeXBlKGJyZWFrVHlwZUEsIGJyZWFrVHlwZUIpIHtcbiAgICAvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jR3JhcGhlbWVfQ2x1c3Rlcl9Cb3VuZGFyeV9SdWxlc1xuICAgIC8vICEhISBMZXQncyBtYWtlIHRoZSBjb21tb24gY2FzZSBhIGJpdCBmYXN0ZXJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMCAvKiBPdGhlciAqLykge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LTEzLjAuMGQxMC5odG1sI3RhYmxlXG4gICAgICAgIHJldHVybiAoYnJlYWtUeXBlQiAhPT0gNSAvKiBFeHRlbmQgKi8gJiYgYnJlYWtUeXBlQiAhPT0gNyAvKiBTcGFjaW5nTWFyayAqLyk7XG4gICAgfVxuICAgIC8vIERvIG5vdCBicmVhayBiZXR3ZWVuIGEgQ1IgYW5kIExGLiBPdGhlcndpc2UsIGJyZWFrIGJlZm9yZSBhbmQgYWZ0ZXIgY29udHJvbHMuXG4gICAgLy8gR0IzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENSIMOXIExGXG4gICAgLy8gR0I0ICAgICAgICAgICAgICAgICAgICAgICAoQ29udHJvbCB8IENSIHwgTEYpIMO3XG4gICAgLy8gR0I1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMO3IChDb250cm9sIHwgQ1IgfCBMRilcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMiAvKiBDUiAqLykge1xuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gMyAvKiBMRiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjNcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNCAvKiBDb250cm9sICovIHx8IGJyZWFrVHlwZUEgPT09IDIgLyogQ1IgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMyAvKiBMRiAqLykge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gR0I0XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVCID09PSA0IC8qIENvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMiAvKiBDUiAqLyB8fCBicmVha1R5cGVCID09PSAzIC8qIExGICovKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjVcbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIEhhbmd1bCBzeWxsYWJsZSBzZXF1ZW5jZXMuXG4gICAgLy8gR0I2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMIMOXIChMIHwgViB8IExWIHwgTFZUKVxuICAgIC8vIEdCNyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTFYgfCBWKSDDlyAoViB8IFQpXG4gICAgLy8gR0I4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWVCB8IFQpIMOXIFRcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gOCAvKiBMICovKSB7XG4gICAgICAgIGlmIChicmVha1R5cGVCID09PSA4IC8qIEwgKi8gfHwgYnJlYWtUeXBlQiA9PT0gOSAvKiBWICovIHx8IGJyZWFrVHlwZUIgPT09IDExIC8qIExWICovIHx8IGJyZWFrVHlwZUIgPT09IDEyIC8qIExWVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjZcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMTEgLyogTFYgKi8gfHwgYnJlYWtUeXBlQSA9PT0gOSAvKiBWICovKSB7XG4gICAgICAgIGlmIChicmVha1R5cGVCID09PSA5IC8qIFYgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTAgLyogVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjdcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMTIgLyogTFZUICovIHx8IGJyZWFrVHlwZUEgPT09IDEwIC8qIFQgKi8pIHtcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDEwIC8qIFQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I4XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBleHRlbmRpbmcgY2hhcmFjdGVycyBvciBaV0ouXG4gICAgLy8gR0I5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMOXIChFeHRlbmQgfCBaV0opXG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDUgLyogRXh0ZW5kICovIHx8IGJyZWFrVHlwZUIgPT09IDEzIC8qIFpXSiAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCOVxuICAgIH1cbiAgICAvLyBUaGUgR0I5YSBhbmQgR0I5YiBydWxlcyBvbmx5IGFwcGx5IHRvIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzOlxuICAgIC8vIERvIG5vdCBicmVhayBiZWZvcmUgU3BhY2luZ01hcmtzLCBvciBhZnRlciBQcmVwZW5kIGNoYXJhY3RlcnMuXG4gICAgLy8gR0I5YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMOXIFNwYWNpbmdNYXJrXG4gICAgLy8gR0I5YiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVwZW5kIMOXXG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDcgLyogU3BhY2luZ01hcmsgKi8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjlhXG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxIC8qIFByZXBlbmQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjliXG4gICAgfVxuICAgIC8vIERvIG5vdCBicmVhayB3aXRoaW4gZW1vamkgbW9kaWZpZXIgc2VxdWVuY2VzIG9yIGVtb2ppIHp3aiBzZXF1ZW5jZXMuXG4gICAgLy8gR0IxMSAgICBcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfSBFeHRlbmQqIFpXSiDDlyBcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxMyAvKiBaV0ogKi8gJiYgYnJlYWtUeXBlQiA9PT0gMTQgLyogRXh0ZW5kZWRfUGljdG9ncmFwaGljICovKSB7XG4gICAgICAgIC8vIE5vdGU6IHdlIGFyZSBub3QgaW1wbGVtZW50aW5nIHRoZSBydWxlIGVudGlyZWx5IGhlcmUgdG8gYXZvaWQgaW50cm9kdWNpbmcgc3RhdGVzXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0IxMVxuICAgIH1cbiAgICAvLyBHQjEyICAgICAgICAgICAgICAgICAgICAgICAgICBzb3QgKFJJIFJJKSogUkkgw5cgUklcbiAgICAvLyBHQjEzICAgICAgICAgICAgICAgICAgICAgICAgW15SSV0gKFJJIFJJKSogUkkgw5cgUklcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8gJiYgYnJlYWtUeXBlQiA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8pIHtcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjEyICYgR0IxM1xuICAgIH1cbiAgICAvLyBHQjk5OSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgw7cgQW55XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBHcmFwaGVtZUJyZWFrVHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBnZXRHcmFwaGVtZUJyZWFrUmF3RGF0YSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFKSB7XG4gICAgICAgICAgICBHcmFwaGVtZUJyZWFrVHJlZS5fSU5TVEFOQ0UgPSBuZXcgR3JhcGhlbWVCcmVha1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFO1xuICAgIH1cbiAgICBnZXRHcmFwaGVtZUJyZWFrVHlwZShjb2RlUG9pbnQpIHtcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDAuLjMxXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAzMikge1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gMTAgLyogTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMRiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IDEzIC8qIENhcnJpYWdlUmV0dXJuICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQ1IgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBDb250cm9sICovO1xuICAgICAgICB9XG4gICAgICAgIC8vICEhISBMZXQncyBtYWtlIDdiaXQgQVNDSUkgYSBiaXQgZmFzdGVyOiAzMi4uMTI2XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBjb25zdCBub2RlQ291bnQgPSBkYXRhLmxlbmd0aCAvIDM7XG4gICAgICAgIGxldCBub2RlSW5kZXggPSAxO1xuICAgICAgICB3aGlsZSAobm9kZUluZGV4IDw9IG5vZGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IGRhdGFbMyAqIG5vZGVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBnbyBsZWZ0XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gMiAqIG5vZGVJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA+IGRhdGFbMyAqIG5vZGVJbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhpdFxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhWzMgKiBub2RlSW5kZXggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBPdGhlciAqLztcbiAgICB9XG59XG5HcmFwaGVtZUJyZWFrVHJlZS5fSU5TVEFOQ0UgPSBudWxsO1xuZnVuY3Rpb24gZ2V0R3JhcGhlbWVCcmVha1Jhd0RhdGEoKSB7XG4gICAgLy8gZ2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFpbi9ncmFwaGVtZS1icmVhay5qc1xuICAgIHJldHVybiBKU09OLnBhcnNlKCdbMCwwLDAsNTEyMjksNTEyNTUsMTIsNDQwNjEsNDQwODcsMTIsMTI3NDYyLDEyNzQ4Nyw2LDcwODMsNzA4NSw1LDQ3NjQ1LDQ3NjcxLDEyLDU0ODEzLDU0ODM5LDEyLDEyODY3OCwxMjg2NzgsMTQsMzI3MCwzMjcwLDUsOTkxOSw5OTIzLDE0LDQ1ODUzLDQ1ODc5LDEyLDQ5NDM3LDQ5NDYzLDEyLDUzMDIxLDUzMDQ3LDEyLDcxMjE2LDcxMjE4LDcsMTI4Mzk4LDEyODM5OSwxNCwxMjkzNjAsMTI5Mzc0LDE0LDI1MTksMjUxOSw1LDQ0NDgsNDUxOSw5LDk3NDIsOTc0MiwxNCwxMjMzNiwxMjMzNiwxNCw0NDk1Nyw0NDk4MywxMiw0Njc0OSw0Njc3NSwxMiw0ODU0MSw0ODU2NywxMiw1MDMzMyw1MDM1OSwxMiw1MjEyNSw1MjE1MSwxMiw1MzkxNyw1Mzk0MywxMiw2OTg4OCw2OTg5MCw1LDczMDE4LDczMDE4LDUsMTI3OTkwLDEyNzk5MCwxNCwxMjg1NTgsMTI4NTU5LDE0LDEyODc1OSwxMjg3NjAsMTQsMTI5NjUzLDEyOTY1NSwxNCwyMDI3LDIwMzUsNSwyODkxLDI4OTIsNywzNzYxLDM3NjEsNSw2NjgzLDY2ODMsNSw4MjkzLDgyOTMsNCw5ODI1LDk4MjYsMTQsOTk5OSw5OTk5LDE0LDQzNDUyLDQzNDUzLDUsNDQ1MDksNDQ1MzUsMTIsNDU0MDUsNDU0MzEsMTIsNDYzMDEsNDYzMjcsMTIsNDcxOTcsNDcyMjMsMTIsNDgwOTMsNDgxMTksMTIsNDg5ODksNDkwMTUsMTIsNDk4ODUsNDk5MTEsMTIsNTA3ODEsNTA4MDcsMTIsNTE2NzcsNTE3MDMsMTIsNTI1NzMsNTI1OTksMTIsNTM0NjksNTM0OTUsMTIsNTQzNjUsNTQzOTEsMTIsNjUyNzksNjUyNzksNCw3MDQ3MSw3MDQ3Miw3LDcyMTQ1LDcyMTQ3LDcsMTE5MTczLDExOTE3OSw1LDEyNzc5OSwxMjc4MTgsMTQsMTI4MjQwLDEyODI0NCwxNCwxMjg1MTIsMTI4NTEyLDE0LDEyODY1MiwxMjg2NTIsMTQsMTI4NzIxLDEyODcyMiwxNCwxMjkyOTIsMTI5MjkyLDE0LDEyOTQ0NSwxMjk0NTAsMTQsMTI5NzM0LDEyOTc0MywxNCwxNDc2LDE0NzcsNSwyMzY2LDIzNjgsNywyNzUwLDI3NTIsNywzMDc2LDMwNzYsNSwzNDE1LDM0MTUsNSw0MTQxLDQxNDQsNSw2MTA5LDYxMDksNSw2OTY0LDY5NjQsNSw3Mzk0LDc0MDAsNSw5MTk3LDkxOTgsMTQsOTc3MCw5NzcwLDE0LDk4NzcsOTg3NywxNCw5OTY4LDk5NjksMTQsMTAwODQsMTAwODQsMTQsNDMwNTIsNDMwNTIsNSw0MzcxMyw0MzcxMyw1LDQ0Mjg1LDQ0MzExLDEyLDQ0NzMzLDQ0NzU5LDEyLDQ1MTgxLDQ1MjA3LDEyLDQ1NjI5LDQ1NjU1LDEyLDQ2MDc3LDQ2MTAzLDEyLDQ2NTI1LDQ2NTUxLDEyLDQ2OTczLDQ2OTk5LDEyLDQ3NDIxLDQ3NDQ3LDEyLDQ3ODY5LDQ3ODk1LDEyLDQ4MzE3LDQ4MzQzLDEyLDQ4NzY1LDQ4NzkxLDEyLDQ5MjEzLDQ5MjM5LDEyLDQ5NjYxLDQ5Njg3LDEyLDUwMTA5LDUwMTM1LDEyLDUwNTU3LDUwNTgzLDEyLDUxMDA1LDUxMDMxLDEyLDUxNDUzLDUxNDc5LDEyLDUxOTAxLDUxOTI3LDEyLDUyMzQ5LDUyMzc1LDEyLDUyNzk3LDUyODIzLDEyLDUzMjQ1LDUzMjcxLDEyLDUzNjkzLDUzNzE5LDEyLDU0MTQxLDU0MTY3LDEyLDU0NTg5LDU0NjE1LDEyLDU1MDM3LDU1MDYzLDEyLDY5NTA2LDY5NTA5LDUsNzAxOTEsNzAxOTMsNSw3MDg0MSw3MDg0MSw3LDcxNDYzLDcxNDY3LDUsNzIzMzAsNzIzNDIsNSw5NDAzMSw5NDAzMSw1LDEyMzYyOCwxMjM2MzEsNSwxMjc3NjMsMTI3NzY1LDE0LDEyNzk0MSwxMjc5NDEsMTQsMTI4MDQzLDEyODA2MiwxNCwxMjgzMDIsMTI4MzE3LDE0LDEyODQ2NSwxMjg0NjcsMTQsMTI4NTM5LDEyODUzOSwxNCwxMjg2NDAsMTI4NjQwLDE0LDEyODY2MiwxMjg2NjIsMTQsMTI4NzAzLDEyODcwMywxNCwxMjg3NDUsMTI4NzQ1LDE0LDEyOTAwNCwxMjkwMDcsMTQsMTI5MzI5LDEyOTMzMCwxNCwxMjk0MDIsMTI5NDAyLDE0LDEyOTQ4MywxMjk0ODMsMTQsMTI5Njg2LDEyOTcwNCwxNCwxMzAwNDgsMTMxMDY5LDE0LDE3MywxNzMsNCwxNzU3LDE3NTcsMSwyMjAwLDIyMDcsNSwyNDM0LDI0MzUsNywyNjMxLDI2MzIsNSwyODE3LDI4MTcsNSwzMDA4LDMwMDgsNSwzMjAxLDMyMDEsNSwzMzg3LDMzODgsNSwzNTQyLDM1NDIsNSwzOTAyLDM5MDMsNyw0MTkwLDQxOTIsNSw2MDAyLDYwMDMsNSw2NDM5LDY0NDAsNSw2NzY1LDY3NzAsNyw3MDE5LDcwMjcsNSw3MTU0LDcxNTUsNyw4MjA1LDgyMDUsMTMsODUwNSw4NTA1LDE0LDk2NTQsOTY1NCwxNCw5NzU3LDk3NTcsMTQsOTc5Miw5NzkyLDE0LDk4NTIsOTg1MywxNCw5ODkwLDk4OTQsMTQsOTkzNyw5OTM3LDE0LDk5ODEsOTk4MSwxNCwxMDAzNSwxMDAzNiwxNCwxMTAzNSwxMTAzNiwxNCw0MjY1NCw0MjY1NSw1LDQzMzQ2LDQzMzQ3LDcsNDM1ODcsNDM1ODcsNSw0NDAwNiw0NDAwNyw3LDQ0MTczLDQ0MTk5LDEyLDQ0Mzk3LDQ0NDIzLDEyLDQ0NjIxLDQ0NjQ3LDEyLDQ0ODQ1LDQ0ODcxLDEyLDQ1MDY5LDQ1MDk1LDEyLDQ1MjkzLDQ1MzE5LDEyLDQ1NTE3LDQ1NTQzLDEyLDQ1NzQxLDQ1NzY3LDEyLDQ1OTY1LDQ1OTkxLDEyLDQ2MTg5LDQ2MjE1LDEyLDQ2NDEzLDQ2NDM5LDEyLDQ2NjM3LDQ2NjYzLDEyLDQ2ODYxLDQ2ODg3LDEyLDQ3MDg1LDQ3MTExLDEyLDQ3MzA5LDQ3MzM1LDEyLDQ3NTMzLDQ3NTU5LDEyLDQ3NzU3LDQ3NzgzLDEyLDQ3OTgxLDQ4MDA3LDEyLDQ4MjA1LDQ4MjMxLDEyLDQ4NDI5LDQ4NDU1LDEyLDQ4NjUzLDQ4Njc5LDEyLDQ4ODc3LDQ4OTAzLDEyLDQ5MTAxLDQ5MTI3LDEyLDQ5MzI1LDQ5MzUxLDEyLDQ5NTQ5LDQ5NTc1LDEyLDQ5NzczLDQ5Nzk5LDEyLDQ5OTk3LDUwMDIzLDEyLDUwMjIxLDUwMjQ3LDEyLDUwNDQ1LDUwNDcxLDEyLDUwNjY5LDUwNjk1LDEyLDUwODkzLDUwOTE5LDEyLDUxMTE3LDUxMTQzLDEyLDUxMzQxLDUxMzY3LDEyLDUxNTY1LDUxNTkxLDEyLDUxNzg5LDUxODE1LDEyLDUyMDEzLDUyMDM5LDEyLDUyMjM3LDUyMjYzLDEyLDUyNDYxLDUyNDg3LDEyLDUyNjg1LDUyNzExLDEyLDUyOTA5LDUyOTM1LDEyLDUzMTMzLDUzMTU5LDEyLDUzMzU3LDUzMzgzLDEyLDUzNTgxLDUzNjA3LDEyLDUzODA1LDUzODMxLDEyLDU0MDI5LDU0MDU1LDEyLDU0MjUzLDU0Mjc5LDEyLDU0NDc3LDU0NTAzLDEyLDU0NzAxLDU0NzI3LDEyLDU0OTI1LDU0OTUxLDEyLDU1MTQ5LDU1MTc1LDEyLDY4MTAxLDY4MTAyLDUsNjk3NjIsNjk3NjIsNyw3MDA2Nyw3MDA2OSw3LDcwMzcxLDcwMzc4LDUsNzA3MjAsNzA3MjEsNyw3MTA4Nyw3MTA4Nyw1LDcxMzQxLDcxMzQxLDUsNzE5OTUsNzE5OTYsNSw3MjI0OSw3MjI0OSw3LDcyODUwLDcyODcxLDUsNzMxMDksNzMxMDksNSwxMTg1NzYsMTE4NTk4LDUsMTIxNTA1LDEyMTUxOSw1LDEyNzI0NSwxMjcyNDcsMTQsMTI3NTY4LDEyNzU2OSwxNCwxMjc3NzcsMTI3Nzc3LDE0LDEyNzg3MiwxMjc4OTEsMTQsMTI3OTU2LDEyNzk2NywxNCwxMjgwMTUsMTI4MDE2LDE0LDEyODExMCwxMjgxNzIsMTQsMTI4MjU5LDEyODI1OSwxNCwxMjgzNjcsMTI4MzY4LDE0LDEyODQyNCwxMjg0MjQsMTQsMTI4NDg4LDEyODQ4OCwxNCwxMjg1MzAsMTI4NTMyLDE0LDEyODU1MCwxMjg1NTEsMTQsMTI4NTY2LDEyODU2NiwxNCwxMjg2NDcsMTI4NjQ3LDE0LDEyODY1NiwxMjg2NTYsMTQsMTI4NjY3LDEyODY3MywxNCwxMjg2OTEsMTI4NjkzLDE0LDEyODcxNSwxMjg3MTUsMTQsMTI4NzI4LDEyODczMiwxNCwxMjg3NTIsMTI4NzUyLDE0LDEyODc2NSwxMjg3NjcsMTQsMTI5MDk2LDEyOTEwMywxNCwxMjkzMTEsMTI5MzExLDE0LDEyOTM0NCwxMjkzNDksMTQsMTI5Mzk0LDEyOTM5NCwxNCwxMjk0MTMsMTI5NDI1LDE0LDEyOTQ2NiwxMjk0NzEsMTQsMTI5NTExLDEyOTUzNSwxNCwxMjk2NjQsMTI5NjY2LDE0LDEyOTcxOSwxMjk3MjIsMTQsMTI5NzYwLDEyOTc2NywxNCw5MTc1MzYsOTE3NjMxLDUsMTMsMTMsMiwxMTYwLDExNjEsNSwxNTY0LDE1NjQsNCwxODA3LDE4MDcsMSwyMDg1LDIwODcsNSwyMzA3LDIzMDcsNywyMzgyLDIzODMsNywyNDk3LDI1MDAsNSwyNTYzLDI1NjMsNywyNjc3LDI2NzcsNSwyNzYzLDI3NjQsNywyODc5LDI4NzksNSwyOTE0LDI5MTUsNSwzMDIxLDMwMjEsNSwzMTQyLDMxNDQsNSwzMjYzLDMyNjMsNSwzMjg1LDMyODYsNSwzMzk4LDM0MDAsNywzNTMwLDM1MzAsNSwzNjMzLDM2MzMsNSwzODY0LDM4NjUsNSwzOTc0LDM5NzUsNSw0MTU1LDQxNTYsNyw0MjI5LDQyMzAsNSw1OTA5LDU5MDksNyw2MDc4LDYwODUsNyw2Mjc3LDYyNzgsNSw2NDUxLDY0NTYsNyw2NzQ0LDY3NTAsNSw2ODQ2LDY4NDYsNSw2OTcyLDY5NzIsNSw3MDc0LDcwNzcsNSw3MTQ2LDcxNDgsNyw3MjIyLDcyMjMsNSw3NDE2LDc0MTcsNSw4MjM0LDgyMzgsNCw4NDE3LDg0MTcsNSw5MDAwLDkwMDAsMTQsOTIwMyw5MjAzLDE0LDk3MzAsOTczMSwxNCw5NzQ4LDk3NDksMTQsOTc2Miw5NzYzLDE0LDk3NzYsOTc4MywxNCw5ODAwLDk4MTEsMTQsOTgzMSw5ODMxLDE0LDk4NzIsOTg3MywxNCw5ODgyLDk4ODIsMTQsOTkwMCw5OTAzLDE0LDk5MjksOTkzMywxNCw5OTQxLDk5NjAsMTQsOTk3NCw5OTc0LDE0LDk5ODksOTk4OSwxNCwxMDAwNiwxMDAwNiwxNCwxMDA2MiwxMDA2MiwxNCwxMDE2MCwxMDE2MCwxNCwxMTY0NywxMTY0Nyw1LDEyOTUzLDEyOTUzLDE0LDQzMDE5LDQzMDE5LDUsNDMyMzIsNDMyNDksNSw0MzQ0Myw0MzQ0Myw1LDQzNTY3LDQzNTY4LDcsNDM2OTYsNDM2OTYsNSw0Mzc2NSw0Mzc2NSw3LDQ0MDEzLDQ0MDEzLDUsNDQxMTcsNDQxNDMsMTIsNDQyMjksNDQyNTUsMTIsNDQzNDEsNDQzNjcsMTIsNDQ0NTMsNDQ0NzksMTIsNDQ1NjUsNDQ1OTEsMTIsNDQ2NzcsNDQ3MDMsMTIsNDQ3ODksNDQ4MTUsMTIsNDQ5MDEsNDQ5MjcsMTIsNDUwMTMsNDUwMzksMTIsNDUxMjUsNDUxNTEsMTIsNDUyMzcsNDUyNjMsMTIsNDUzNDksNDUzNzUsMTIsNDU0NjEsNDU0ODcsMTIsNDU1NzMsNDU1OTksMTIsNDU2ODUsNDU3MTEsMTIsNDU3OTcsNDU4MjMsMTIsNDU5MDksNDU5MzUsMTIsNDYwMjEsNDYwNDcsMTIsNDYxMzMsNDYxNTksMTIsNDYyNDUsNDYyNzEsMTIsNDYzNTcsNDYzODMsMTIsNDY0NjksNDY0OTUsMTIsNDY1ODEsNDY2MDcsMTIsNDY2OTMsNDY3MTksMTIsNDY4MDUsNDY4MzEsMTIsNDY5MTcsNDY5NDMsMTIsNDcwMjksNDcwNTUsMTIsNDcxNDEsNDcxNjcsMTIsNDcyNTMsNDcyNzksMTIsNDczNjUsNDczOTEsMTIsNDc0NzcsNDc1MDMsMTIsNDc1ODksNDc2MTUsMTIsNDc3MDEsNDc3MjcsMTIsNDc4MTMsNDc4MzksMTIsNDc5MjUsNDc5NTEsMTIsNDgwMzcsNDgwNjMsMTIsNDgxNDksNDgxNzUsMTIsNDgyNjEsNDgyODcsMTIsNDgzNzMsNDgzOTksMTIsNDg0ODUsNDg1MTEsMTIsNDg1OTcsNDg2MjMsMTIsNDg3MDksNDg3MzUsMTIsNDg4MjEsNDg4NDcsMTIsNDg5MzMsNDg5NTksMTIsNDkwNDUsNDkwNzEsMTIsNDkxNTcsNDkxODMsMTIsNDkyNjksNDkyOTUsMTIsNDkzODEsNDk0MDcsMTIsNDk0OTMsNDk1MTksMTIsNDk2MDUsNDk2MzEsMTIsNDk3MTcsNDk3NDMsMTIsNDk4MjksNDk4NTUsMTIsNDk5NDEsNDk5NjcsMTIsNTAwNTMsNTAwNzksMTIsNTAxNjUsNTAxOTEsMTIsNTAyNzcsNTAzMDMsMTIsNTAzODksNTA0MTUsMTIsNTA1MDEsNTA1MjcsMTIsNTA2MTMsNTA2MzksMTIsNTA3MjUsNTA3NTEsMTIsNTA4MzcsNTA4NjMsMTIsNTA5NDksNTA5NzUsMTIsNTEwNjEsNTEwODcsMTIsNTExNzMsNTExOTksMTIsNTEyODUsNTEzMTEsMTIsNTEzOTcsNTE0MjMsMTIsNTE1MDksNTE1MzUsMTIsNTE2MjEsNTE2NDcsMTIsNTE3MzMsNTE3NTksMTIsNTE4NDUsNTE4NzEsMTIsNTE5NTcsNTE5ODMsMTIsNTIwNjksNTIwOTUsMTIsNTIxODEsNTIyMDcsMTIsNTIyOTMsNTIzMTksMTIsNTI0MDUsNTI0MzEsMTIsNTI1MTcsNTI1NDMsMTIsNTI2MjksNTI2NTUsMTIsNTI3NDEsNTI3NjcsMTIsNTI4NTMsNTI4NzksMTIsNTI5NjUsNTI5OTEsMTIsNTMwNzcsNTMxMDMsMTIsNTMxODksNTMyMTUsMTIsNTMzMDEsNTMzMjcsMTIsNTM0MTMsNTM0MzksMTIsNTM1MjUsNTM1NTEsMTIsNTM2MzcsNTM2NjMsMTIsNTM3NDksNTM3NzUsMTIsNTM4NjEsNTM4ODcsMTIsNTM5NzMsNTM5OTksMTIsNTQwODUsNTQxMTEsMTIsNTQxOTcsNTQyMjMsMTIsNTQzMDksNTQzMzUsMTIsNTQ0MjEsNTQ0NDcsMTIsNTQ1MzMsNTQ1NTksMTIsNTQ2NDUsNTQ2NzEsMTIsNTQ3NTcsNTQ3ODMsMTIsNTQ4NjksNTQ4OTUsMTIsNTQ5ODEsNTUwMDcsMTIsNTUwOTMsNTUxMTksMTIsNTUyNDMsNTUyOTEsMTAsNjYwNDUsNjYwNDUsNSw2ODMyNSw2ODMyNiw1LDY5Njg4LDY5NzAyLDUsNjk4MTcsNjk4MTgsNSw2OTk1Nyw2OTk1OCw3LDcwMDg5LDcwMDkyLDUsNzAxOTgsNzAxOTksNSw3MDQ2Miw3MDQ2Miw1LDcwNTAyLDcwNTA4LDUsNzA3NTAsNzA3NTAsNSw3MDg0Niw3MDg0Niw3LDcxMTAwLDcxMTAxLDUsNzEyMzAsNzEyMzAsNyw3MTM1MSw3MTM1MSw1LDcxNzM3LDcxNzM4LDUsNzIwMDAsNzIwMDAsNyw3MjE2MCw3MjE2MCw1LDcyMjczLDcyMjc4LDUsNzI3NTIsNzI3NTgsNSw3Mjg4Miw3Mjg4Myw1LDczMDMxLDczMDMxLDUsNzM0NjEsNzM0NjIsNyw5NDE5Miw5NDE5Myw3LDExOTE0OSwxMTkxNDksNywxMjE0MDMsMTIxNDUyLDUsMTIyOTE1LDEyMjkxNiw1LDEyNjk4MCwxMjY5ODAsMTQsMTI3MzU4LDEyNzM1OSwxNCwxMjc1MzUsMTI3NTM1LDE0LDEyNzc1OSwxMjc3NTksMTQsMTI3NzcxLDEyNzc3MSwxNCwxMjc3OTIsMTI3NzkzLDE0LDEyNzgyNSwxMjc4NjcsMTQsMTI3ODk3LDEyNzg5OSwxNCwxMjc5NDUsMTI3OTQ1LDE0LDEyNzk4NSwxMjc5ODYsMTQsMTI4MDAwLDEyODAwNywxNCwxMjgwMjEsMTI4MDIxLDE0LDEyODA2NiwxMjgxMDAsMTQsMTI4MTg0LDEyODIzNSwxNCwxMjgyNDksMTI4MjUyLDE0LDEyODI2NiwxMjgyNzYsMTQsMTI4MzM1LDEyODMzNSwxNCwxMjgzNzksMTI4MzkwLDE0LDEyODQwNywxMjg0MTksMTQsMTI4NDQ0LDEyODQ0NCwxNCwxMjg0ODEsMTI4NDgxLDE0LDEyODQ5OSwxMjg0OTksMTQsMTI4NTI2LDEyODUyNiwxNCwxMjg1MzYsMTI4NTM2LDE0LDEyODU0MywxMjg1NDMsMTQsMTI4NTU2LDEyODU1NiwxNCwxMjg1NjQsMTI4NTY0LDE0LDEyODU3NywxMjg1ODAsMTQsMTI4NjQzLDEyODY0NSwxNCwxMjg2NDksMTI4NjQ5LDE0LDEyODY1NCwxMjg2NTQsMTQsMTI4NjYwLDEyODY2MCwxNCwxMjg2NjQsMTI4NjY0LDE0LDEyODY3NSwxMjg2NzUsMTQsMTI4Njg2LDEyODY4OSwxNCwxMjg2OTUsMTI4Njk2LDE0LDEyODcwNSwxMjg3MDksMTQsMTI4NzE3LDEyODcxOSwxNCwxMjg3MjUsMTI4NzI1LDE0LDEyODczNiwxMjg3NDEsMTQsMTI4NzQ3LDEyODc0OCwxNCwxMjg3NTUsMTI4NzU1LDE0LDEyODc2MiwxMjg3NjIsMTQsMTI4OTgxLDEyODk5MSwxNCwxMjkwMDksMTI5MDIzLDE0LDEyOTE2MCwxMjkxNjcsMTQsMTI5Mjk2LDEyOTMwNCwxNCwxMjkzMjAsMTI5MzI3LDE0LDEyOTM0MCwxMjkzNDIsMTQsMTI5MzU2LDEyOTM1NiwxNCwxMjkzODgsMTI5MzkyLDE0LDEyOTM5OSwxMjk0MDAsMTQsMTI5NDA0LDEyOTQwNywxNCwxMjk0MzIsMTI5NDQyLDE0LDEyOTQ1NCwxMjk0NTUsMTQsMTI5NDczLDEyOTQ3NCwxNCwxMjk0ODUsMTI5NDg3LDE0LDEyOTY0OCwxMjk2NTEsMTQsMTI5NjU5LDEyOTY2MCwxNCwxMjk2NzEsMTI5Njc5LDE0LDEyOTcwOSwxMjk3MTEsMTQsMTI5NzI4LDEyOTczMCwxNCwxMjk3NTEsMTI5NzUzLDE0LDEyOTc3NiwxMjk3ODIsMTQsOTE3NTA1LDkxNzUwNSw0LDkxNzc2MCw5MTc5OTksNSwxMCwxMCwzLDEyNywxNTksNCw3NjgsODc5LDUsMTQ3MSwxNDcxLDUsMTUzNiwxNTQxLDEsMTY0OCwxNjQ4LDUsMTc2NywxNzY4LDUsMTg0MCwxODY2LDUsMjA3MCwyMDczLDUsMjEzNywyMTM5LDUsMjI3NCwyMjc0LDEsMjM2MywyMzYzLDcsMjM3NywyMzgwLDcsMjQwMiwyNDAzLDUsMjQ5NCwyNDk0LDUsMjUwNywyNTA4LDcsMjU1OCwyNTU4LDUsMjYyMiwyNjI0LDcsMjY0MSwyNjQxLDUsMjY5MSwyNjkxLDcsMjc1OSwyNzYwLDUsMjc4NiwyNzg3LDUsMjg3NiwyODc2LDUsMjg4MSwyODg0LDUsMjkwMSwyOTAyLDUsMzAwNiwzMDA2LDUsMzAxNCwzMDE2LDcsMzA3MiwzMDcyLDUsMzEzNCwzMTM2LDUsMzE1NywzMTU4LDUsMzI2MCwzMjYwLDUsMzI2NiwzMjY2LDUsMzI3NCwzMjc1LDcsMzMyOCwzMzI5LDUsMzM5MSwzMzkyLDcsMzQwNSwzNDA1LDUsMzQ1NywzNDU3LDUsMzUzNiwzNTM3LDcsMzU1MSwzNTUxLDUsMzYzNiwzNjQyLDUsMzc2NCwzNzcyLDUsMzg5NSwzODk1LDUsMzk2NywzOTY3LDcsMzk5Myw0MDI4LDUsNDE0Niw0MTUxLDUsNDE4Miw0MTgzLDcsNDIyNiw0MjI2LDUsNDI1Myw0MjUzLDUsNDk1Nyw0OTU5LDUsNTk0MCw1OTQwLDcsNjA3MCw2MDcwLDcsNjA4Nyw2MDg4LDcsNjE1OCw2MTU4LDQsNjQzMiw2NDM0LDUsNjQ0OCw2NDQ5LDcsNjY3OSw2NjgwLDUsNjc0Miw2NzQyLDUsNjc1NCw2NzU0LDUsNjc4Myw2NzgzLDUsNjkxMiw2OTE1LDUsNjk2Niw2OTcwLDUsNjk3OCw2OTc4LDUsNzA0Miw3MDQyLDcsNzA4MCw3MDgxLDUsNzE0Myw3MTQzLDcsNzE1MCw3MTUwLDcsNzIxMiw3MjE5LDUsNzM4MCw3MzkyLDUsNzQxMiw3NDEyLDUsODIwMyw4MjAzLDQsODIzMiw4MjMyLDQsODI2NSw4MjY1LDE0LDg0MDAsODQxMiw1LDg0MjEsODQzMiw1LDg2MTcsODYxOCwxNCw5MTY3LDkxNjcsMTQsOTIwMCw5MjAwLDE0LDk0MTAsOTQxMCwxNCw5NzIzLDk3MjYsMTQsOTczMyw5NzMzLDE0LDk3NDUsOTc0NSwxNCw5NzUyLDk3NTIsMTQsOTc2MCw5NzYwLDE0LDk3NjYsOTc2NiwxNCw5Nzc0LDk3NzQsMTQsOTc4Niw5Nzg2LDE0LDk3OTQsOTc5NCwxNCw5ODIzLDk4MjMsMTQsOTgyOCw5ODI4LDE0LDk4MzMsOTg1MCwxNCw5ODU1LDk4NTUsMTQsOTg3NSw5ODc1LDE0LDk4ODAsOTg4MCwxNCw5ODg1LDk4ODcsMTQsOTg5Niw5ODk3LDE0LDk5MDYsOTkxNiwxNCw5OTI2LDk5MjcsMTQsOTkzNSw5OTM1LDE0LDk5MzksOTkzOSwxNCw5OTYyLDk5NjIsMTQsOTk3Miw5OTcyLDE0LDk5NzgsOTk3OCwxNCw5OTg2LDk5ODYsMTQsOTk5Nyw5OTk3LDE0LDEwMDAyLDEwMDAyLDE0LDEwMDE3LDEwMDE3LDE0LDEwMDU1LDEwMDU1LDE0LDEwMDcxLDEwMDcxLDE0LDEwMTMzLDEwMTM1LDE0LDEwNTQ4LDEwNTQ5LDE0LDExMDkzLDExMDkzLDE0LDEyMzMwLDEyMzMzLDUsMTI0NDEsMTI0NDIsNSw0MjYwOCw0MjYxMCw1LDQzMDEwLDQzMDEwLDUsNDMwNDUsNDMwNDYsNSw0MzE4OCw0MzIwMyw3LDQzMzAyLDQzMzA5LDUsNDMzOTIsNDMzOTQsNSw0MzQ0Niw0MzQ0OSw1LDQzNDkzLDQzNDkzLDUsNDM1NzEsNDM1NzIsNyw0MzU5Nyw0MzU5Nyw3LDQzNzAzLDQzNzA0LDUsNDM3NTYsNDM3NTcsNSw0NDAwMyw0NDAwNCw3LDQ0MDA5LDQ0MDEwLDcsNDQwMzMsNDQwNTksMTIsNDQwODksNDQxMTUsMTIsNDQxNDUsNDQxNzEsMTIsNDQyMDEsNDQyMjcsMTIsNDQyNTcsNDQyODMsMTIsNDQzMTMsNDQzMzksMTIsNDQzNjksNDQzOTUsMTIsNDQ0MjUsNDQ0NTEsMTIsNDQ0ODEsNDQ1MDcsMTIsNDQ1MzcsNDQ1NjMsMTIsNDQ1OTMsNDQ2MTksMTIsNDQ2NDksNDQ2NzUsMTIsNDQ3MDUsNDQ3MzEsMTIsNDQ3NjEsNDQ3ODcsMTIsNDQ4MTcsNDQ4NDMsMTIsNDQ4NzMsNDQ4OTksMTIsNDQ5MjksNDQ5NTUsMTIsNDQ5ODUsNDUwMTEsMTIsNDUwNDEsNDUwNjcsMTIsNDUwOTcsNDUxMjMsMTIsNDUxNTMsNDUxNzksMTIsNDUyMDksNDUyMzUsMTIsNDUyNjUsNDUyOTEsMTIsNDUzMjEsNDUzNDcsMTIsNDUzNzcsNDU0MDMsMTIsNDU0MzMsNDU0NTksMTIsNDU0ODksNDU1MTUsMTIsNDU1NDUsNDU1NzEsMTIsNDU2MDEsNDU2MjcsMTIsNDU2NTcsNDU2ODMsMTIsNDU3MTMsNDU3MzksMTIsNDU3NjksNDU3OTUsMTIsNDU4MjUsNDU4NTEsMTIsNDU4ODEsNDU5MDcsMTIsNDU5MzcsNDU5NjMsMTIsNDU5OTMsNDYwMTksMTIsNDYwNDksNDYwNzUsMTIsNDYxMDUsNDYxMzEsMTIsNDYxNjEsNDYxODcsMTIsNDYyMTcsNDYyNDMsMTIsNDYyNzMsNDYyOTksMTIsNDYzMjksNDYzNTUsMTIsNDYzODUsNDY0MTEsMTIsNDY0NDEsNDY0NjcsMTIsNDY0OTcsNDY1MjMsMTIsNDY1NTMsNDY1NzksMTIsNDY2MDksNDY2MzUsMTIsNDY2NjUsNDY2OTEsMTIsNDY3MjEsNDY3NDcsMTIsNDY3NzcsNDY4MDMsMTIsNDY4MzMsNDY4NTksMTIsNDY4ODksNDY5MTUsMTIsNDY5NDUsNDY5NzEsMTIsNDcwMDEsNDcwMjcsMTIsNDcwNTcsNDcwODMsMTIsNDcxMTMsNDcxMzksMTIsNDcxNjksNDcxOTUsMTIsNDcyMjUsNDcyNTEsMTIsNDcyODEsNDczMDcsMTIsNDczMzcsNDczNjMsMTIsNDczOTMsNDc0MTksMTIsNDc0NDksNDc0NzUsMTIsNDc1MDUsNDc1MzEsMTIsNDc1NjEsNDc1ODcsMTIsNDc2MTcsNDc2NDMsMTIsNDc2NzMsNDc2OTksMTIsNDc3MjksNDc3NTUsMTIsNDc3ODUsNDc4MTEsMTIsNDc4NDEsNDc4NjcsMTIsNDc4OTcsNDc5MjMsMTIsNDc5NTMsNDc5NzksMTIsNDgwMDksNDgwMzUsMTIsNDgwNjUsNDgwOTEsMTIsNDgxMjEsNDgxNDcsMTIsNDgxNzcsNDgyMDMsMTIsNDgyMzMsNDgyNTksMTIsNDgyODksNDgzMTUsMTIsNDgzNDUsNDgzNzEsMTIsNDg0MDEsNDg0MjcsMTIsNDg0NTcsNDg0ODMsMTIsNDg1MTMsNDg1MzksMTIsNDg1NjksNDg1OTUsMTIsNDg2MjUsNDg2NTEsMTIsNDg2ODEsNDg3MDcsMTIsNDg3MzcsNDg3NjMsMTIsNDg3OTMsNDg4MTksMTIsNDg4NDksNDg4NzUsMTIsNDg5MDUsNDg5MzEsMTIsNDg5NjEsNDg5ODcsMTIsNDkwMTcsNDkwNDMsMTIsNDkwNzMsNDkwOTksMTIsNDkxMjksNDkxNTUsMTIsNDkxODUsNDkyMTEsMTIsNDkyNDEsNDkyNjcsMTIsNDkyOTcsNDkzMjMsMTIsNDkzNTMsNDkzNzksMTIsNDk0MDksNDk0MzUsMTIsNDk0NjUsNDk0OTEsMTIsNDk1MjEsNDk1NDcsMTIsNDk1NzcsNDk2MDMsMTIsNDk2MzMsNDk2NTksMTIsNDk2ODksNDk3MTUsMTIsNDk3NDUsNDk3NzEsMTIsNDk4MDEsNDk4MjcsMTIsNDk4NTcsNDk4ODMsMTIsNDk5MTMsNDk5MzksMTIsNDk5NjksNDk5OTUsMTIsNTAwMjUsNTAwNTEsMTIsNTAwODEsNTAxMDcsMTIsNTAxMzcsNTAxNjMsMTIsNTAxOTMsNTAyMTksMTIsNTAyNDksNTAyNzUsMTIsNTAzMDUsNTAzMzEsMTIsNTAzNjEsNTAzODcsMTIsNTA0MTcsNTA0NDMsMTIsNTA0NzMsNTA0OTksMTIsNTA1MjksNTA1NTUsMTIsNTA1ODUsNTA2MTEsMTIsNTA2NDEsNTA2NjcsMTIsNTA2OTcsNTA3MjMsMTIsNTA3NTMsNTA3NzksMTIsNTA4MDksNTA4MzUsMTIsNTA4NjUsNTA4OTEsMTIsNTA5MjEsNTA5NDcsMTIsNTA5NzcsNTEwMDMsMTIsNTEwMzMsNTEwNTksMTIsNTEwODksNTExMTUsMTIsNTExNDUsNTExNzEsMTIsNTEyMDEsNTEyMjcsMTIsNTEyNTcsNTEyODMsMTIsNTEzMTMsNTEzMzksMTIsNTEzNjksNTEzOTUsMTIsNTE0MjUsNTE0NTEsMTIsNTE0ODEsNTE1MDcsMTIsNTE1MzcsNTE1NjMsMTIsNTE1OTMsNTE2MTksMTIsNTE2NDksNTE2NzUsMTIsNTE3MDUsNTE3MzEsMTIsNTE3NjEsNTE3ODcsMTIsNTE4MTcsNTE4NDMsMTIsNTE4NzMsNTE4OTksMTIsNTE5MjksNTE5NTUsMTIsNTE5ODUsNTIwMTEsMTIsNTIwNDEsNTIwNjcsMTIsNTIwOTcsNTIxMjMsMTIsNTIxNTMsNTIxNzksMTIsNTIyMDksNTIyMzUsMTIsNTIyNjUsNTIyOTEsMTIsNTIzMjEsNTIzNDcsMTIsNTIzNzcsNTI0MDMsMTIsNTI0MzMsNTI0NTksMTIsNTI0ODksNTI1MTUsMTIsNTI1NDUsNTI1NzEsMTIsNTI2MDEsNTI2MjcsMTIsNTI2NTcsNTI2ODMsMTIsNTI3MTMsNTI3MzksMTIsNTI3NjksNTI3OTUsMTIsNTI4MjUsNTI4NTEsMTIsNTI4ODEsNTI5MDcsMTIsNTI5MzcsNTI5NjMsMTIsNTI5OTMsNTMwMTksMTIsNTMwNDksNTMwNzUsMTIsNTMxMDUsNTMxMzEsMTIsNTMxNjEsNTMxODcsMTIsNTMyMTcsNTMyNDMsMTIsNTMyNzMsNTMyOTksMTIsNTMzMjksNTMzNTUsMTIsNTMzODUsNTM0MTEsMTIsNTM0NDEsNTM0NjcsMTIsNTM0OTcsNTM1MjMsMTIsNTM1NTMsNTM1NzksMTIsNTM2MDksNTM2MzUsMTIsNTM2NjUsNTM2OTEsMTIsNTM3MjEsNTM3NDcsMTIsNTM3NzcsNTM4MDMsMTIsNTM4MzMsNTM4NTksMTIsNTM4ODksNTM5MTUsMTIsNTM5NDUsNTM5NzEsMTIsNTQwMDEsNTQwMjcsMTIsNTQwNTcsNTQwODMsMTIsNTQxMTMsNTQxMzksMTIsNTQxNjksNTQxOTUsMTIsNTQyMjUsNTQyNTEsMTIsNTQyODEsNTQzMDcsMTIsNTQzMzcsNTQzNjMsMTIsNTQzOTMsNTQ0MTksMTIsNTQ0NDksNTQ0NzUsMTIsNTQ1MDUsNTQ1MzEsMTIsNTQ1NjEsNTQ1ODcsMTIsNTQ2MTcsNTQ2NDMsMTIsNTQ2NzMsNTQ2OTksMTIsNTQ3MjksNTQ3NTUsMTIsNTQ3ODUsNTQ4MTEsMTIsNTQ4NDEsNTQ4NjcsMTIsNTQ4OTcsNTQ5MjMsMTIsNTQ5NTMsNTQ5NzksMTIsNTUwMDksNTUwMzUsMTIsNTUwNjUsNTUwOTEsMTIsNTUxMjEsNTUxNDcsMTIsNTUxNzcsNTUyMDMsMTIsNjUwMjQsNjUwMzksNSw2NTUyMCw2NTUyOCw0LDY2NDIyLDY2NDI2LDUsNjgxNTIsNjgxNTQsNSw2OTI5MSw2OTI5Miw1LDY5NjMzLDY5NjMzLDUsNjk3NDcsNjk3NDgsNSw2OTgxMSw2OTgxNCw1LDY5ODI2LDY5ODI2LDUsNjk5MzIsNjk5MzIsNyw3MDAxNiw3MDAxNyw1LDcwMDc5LDcwMDgwLDcsNzAwOTUsNzAwOTUsNSw3MDE5Niw3MDE5Niw1LDcwMzY3LDcwMzY3LDUsNzA0MDIsNzA0MDMsNyw3MDQ2NCw3MDQ2NCw1LDcwNDg3LDcwNDg3LDUsNzA3MDksNzA3MTEsNyw3MDcyNSw3MDcyNSw3LDcwODMzLDcwODM0LDcsNzA4NDMsNzA4NDQsNyw3MDg0OSw3MDg0OSw3LDcxMDkwLDcxMDkzLDUsNzExMDMsNzExMDQsNSw3MTIyNyw3MTIyOCw3LDcxMzM5LDcxMzM5LDUsNzEzNDQsNzEzNDksNSw3MTQ1OCw3MTQ2MSw1LDcxNzI3LDcxNzM1LDUsNzE5ODUsNzE5ODksNyw3MTk5OCw3MTk5OCw1LDcyMDAyLDcyMDAyLDcsNzIxNTQsNzIxNTUsNSw3MjE5Myw3MjIwMiw1LDcyMjUxLDcyMjU0LDUsNzIyODEsNzIyODMsNSw3MjM0NCw3MjM0NSw1LDcyNzY2LDcyNzY2LDcsNzI4NzQsNzI4ODAsNSw3Mjg4NSw3Mjg4Niw1LDczMDIzLDczMDI5LDUsNzMxMDQsNzMxMDUsNSw3MzExMSw3MzExMSw1LDkyOTEyLDkyOTE2LDUsOTQwOTUsOTQwOTgsNSwxMTM4MjQsMTEzODI3LDQsMTE5MTQyLDExOTE0Miw3LDExOTE1NSwxMTkxNjIsNCwxMTkzNjIsMTE5MzY0LDUsMTIxNDc2LDEyMTQ3Niw1LDEyMjg4OCwxMjI5MDQsNSwxMjMxODQsMTIzMTkwLDUsMTI1MjUyLDEyNTI1OCw1LDEyNzE4MywxMjcxODMsMTQsMTI3MzQwLDEyNzM0MywxNCwxMjczNzcsMTI3Mzg2LDE0LDEyNzQ5MSwxMjc1MDMsMTQsMTI3NTQ4LDEyNzU1MSwxNCwxMjc3NDQsMTI3NzU2LDE0LDEyNzc2MSwxMjc3NjEsMTQsMTI3NzY5LDEyNzc2OSwxNCwxMjc3NzMsMTI3Nzc0LDE0LDEyNzc4MCwxMjc3ODgsMTQsMTI3Nzk2LDEyNzc5NywxNCwxMjc4MjAsMTI3ODIzLDE0LDEyNzg2OSwxMjc4NjksMTQsMTI3ODk0LDEyNzg5NSwxNCwxMjc5MDIsMTI3OTAzLDE0LDEyNzk0MywxMjc5NDMsMTQsMTI3OTQ3LDEyNzk1MCwxNCwxMjc5NzIsMTI3OTcyLDE0LDEyNzk4OCwxMjc5ODgsMTQsMTI3OTkyLDEyNzk5NCwxNCwxMjgwMDksMTI4MDExLDE0LDEyODAxOSwxMjgwMTksMTQsMTI4MDIzLDEyODA0MSwxNCwxMjgwNjQsMTI4MDY0LDE0LDEyODEwMiwxMjgxMDcsMTQsMTI4MTc0LDEyODE4MSwxNCwxMjgyMzgsMTI4MjM4LDE0LDEyODI0NiwxMjgyNDcsMTQsMTI4MjU0LDEyODI1NCwxNCwxMjgyNjQsMTI4MjY0LDE0LDEyODI3OCwxMjgyOTksMTQsMTI4MzI5LDEyODMzMCwxNCwxMjgzNDgsMTI4MzU5LDE0LDEyODM3MSwxMjgzNzcsMTQsMTI4MzkyLDEyODM5MywxNCwxMjg0MDEsMTI4NDA0LDE0LDEyODQyMSwxMjg0MjEsMTQsMTI4NDMzLDEyODQzNCwxNCwxMjg0NTAsMTI4NDUyLDE0LDEyODQ3NiwxMjg0NzgsMTQsMTI4NDgzLDEyODQ4MywxNCwxMjg0OTUsMTI4NDk1LDE0LDEyODUwNiwxMjg1MDYsMTQsMTI4NTE5LDEyODUyMCwxNCwxMjg1MjgsMTI4NTI4LDE0LDEyODUzNCwxMjg1MzQsMTQsMTI4NTM4LDEyODUzOCwxNCwxMjg1NDAsMTI4NTQyLDE0LDEyODU0NCwxMjg1NDksMTQsMTI4NTUyLDEyODU1NSwxNCwxMjg1NTcsMTI4NTU3LDE0LDEyODU2MCwxMjg1NjMsMTQsMTI4NTY1LDEyODU2NSwxNCwxMjg1NjcsMTI4NTc2LDE0LDEyODU4MSwxMjg1OTEsMTQsMTI4NjQxLDEyODY0MiwxNCwxMjg2NDYsMTI4NjQ2LDE0LDEyODY0OCwxMjg2NDgsMTQsMTI4NjUwLDEyODY1MSwxNCwxMjg2NTMsMTI4NjUzLDE0LDEyODY1NSwxMjg2NTUsMTQsMTI4NjU3LDEyODY1OSwxNCwxMjg2NjEsMTI4NjYxLDE0LDEyODY2MywxMjg2NjMsMTQsMTI4NjY1LDEyODY2NiwxNCwxMjg2NzQsMTI4Njc0LDE0LDEyODY3NiwxMjg2NzcsMTQsMTI4Njc5LDEyODY4NSwxNCwxMjg2OTAsMTI4NjkwLDE0LDEyODY5NCwxMjg2OTQsMTQsMTI4Njk3LDEyODcwMiwxNCwxMjg3MDQsMTI4NzA0LDE0LDEyODcxMCwxMjg3MTQsMTQsMTI4NzE2LDEyODcxNiwxNCwxMjg3MjAsMTI4NzIwLDE0LDEyODcyMywxMjg3MjQsMTQsMTI4NzI2LDEyODcyNywxNCwxMjg3MzMsMTI4NzM1LDE0LDEyODc0MiwxMjg3NDQsMTQsMTI4NzQ2LDEyODc0NiwxNCwxMjg3NDksMTI4NzUxLDE0LDEyODc1MywxMjg3NTQsMTQsMTI4NzU2LDEyODc1OCwxNCwxMjg3NjEsMTI4NzYxLDE0LDEyODc2MywxMjg3NjQsMTQsMTI4ODg0LDEyODg5NSwxNCwxMjg5OTIsMTI5MDAzLDE0LDEyOTAwOCwxMjkwMDgsMTQsMTI5MDM2LDEyOTAzOSwxNCwxMjkxMTQsMTI5MTE5LDE0LDEyOTE5OCwxMjkyNzksMTQsMTI5MjkzLDEyOTI5NSwxNCwxMjkzMDUsMTI5MzEwLDE0LDEyOTMxMiwxMjkzMTksMTQsMTI5MzI4LDEyOTMyOCwxNCwxMjkzMzEsMTI5MzM4LDE0LDEyOTM0MywxMjkzNDMsMTQsMTI5MzUxLDEyOTM1NSwxNCwxMjkzNTcsMTI5MzU5LDE0LDEyOTM3NSwxMjkzODcsMTQsMTI5MzkzLDEyOTM5MywxNCwxMjkzOTUsMTI5Mzk4LDE0LDEyOTQwMSwxMjk0MDEsMTQsMTI5NDAzLDEyOTQwMywxNCwxMjk0MDgsMTI5NDEyLDE0LDEyOTQyNiwxMjk0MzEsMTQsMTI5NDQzLDEyOTQ0NCwxNCwxMjk0NTEsMTI5NDUzLDE0LDEyOTQ1NiwxMjk0NjUsMTQsMTI5NDcyLDEyOTQ3MiwxNCwxMjk0NzUsMTI5NDgyLDE0LDEyOTQ4NCwxMjk0ODQsMTQsMTI5NDg4LDEyOTUxMCwxNCwxMjk1MzYsMTI5NjQ3LDE0LDEyOTY1MiwxMjk2NTIsMTQsMTI5NjU2LDEyOTY1OCwxNCwxMjk2NjEsMTI5NjYzLDE0LDEyOTY2NywxMjk2NzAsMTQsMTI5NjgwLDEyOTY4NSwxNCwxMjk3MDUsMTI5NzA4LDE0LDEyOTcxMiwxMjk3MTgsMTQsMTI5NzIzLDEyOTcyNywxNCwxMjk3MzEsMTI5NzMzLDE0LDEyOTc0NCwxMjk3NTAsMTQsMTI5NzU0LDEyOTc1OSwxNCwxMjk3NjgsMTI5Nzc1LDE0LDEyOTc4MywxMjk3OTEsMTQsOTE3NTA0LDkxNzUwNCw0LDkxNzUwNiw5MTc1MzUsNCw5MTc2MzIsOTE3NzU5LDQsOTE4MDAwLDkyMTU5OSw0LDAsOSw0LDExLDEyLDQsMTQsMzEsNCwxNjksMTY5LDE0LDE3NCwxNzQsMTQsMTE1NSwxMTU5LDUsMTQyNSwxNDY5LDUsMTQ3MywxNDc0LDUsMTQ3OSwxNDc5LDUsMTU1MiwxNTYyLDUsMTYxMSwxNjMxLDUsMTc1MCwxNzU2LDUsMTc1OSwxNzY0LDUsMTc3MCwxNzczLDUsMTgwOSwxODA5LDUsMTk1OCwxOTY4LDUsMjA0NSwyMDQ1LDUsMjA3NSwyMDgzLDUsMjA4OSwyMDkzLDUsMjE5MiwyMTkzLDEsMjI1MCwyMjczLDUsMjI3NSwyMzA2LDUsMjM2MiwyMzYyLDUsMjM2NCwyMzY0LDUsMjM2OSwyMzc2LDUsMjM4MSwyMzgxLDUsMjM4NSwyMzkxLDUsMjQzMywyNDMzLDUsMjQ5MiwyNDkyLDUsMjQ5NSwyNDk2LDcsMjUwMywyNTA0LDcsMjUwOSwyNTA5LDUsMjUzMCwyNTMxLDUsMjU2MSwyNTYyLDUsMjYyMCwyNjIwLDUsMjYyNSwyNjI2LDUsMjYzNSwyNjM3LDUsMjY3MiwyNjczLDUsMjY4OSwyNjkwLDUsMjc0OCwyNzQ4LDUsMjc1MywyNzU3LDUsMjc2MSwyNzYxLDcsMjc2NSwyNzY1LDUsMjgxMCwyODE1LDUsMjgxOCwyODE5LDcsMjg3OCwyODc4LDUsMjg4MCwyODgwLDcsMjg4NywyODg4LDcsMjg5MywyODkzLDUsMjkwMywyOTAzLDUsMjk0NiwyOTQ2LDUsMzAwNywzMDA3LDcsMzAwOSwzMDEwLDcsMzAxOCwzMDIwLDcsMzAzMSwzMDMxLDUsMzA3MywzMDc1LDcsMzEzMiwzMTMyLDUsMzEzNywzMTQwLDcsMzE0NiwzMTQ5LDUsMzE3MCwzMTcxLDUsMzIwMiwzMjAzLDcsMzI2MiwzMjYyLDcsMzI2NCwzMjY1LDcsMzI2NywzMjY4LDcsMzI3MSwzMjcyLDcsMzI3NiwzMjc3LDUsMzI5OCwzMjk5LDUsMzMzMCwzMzMxLDcsMzM5MCwzMzkwLDUsMzM5MywzMzk2LDUsMzQwMiwzNDA0LDcsMzQwNiwzNDA2LDEsMzQyNiwzNDI3LDUsMzQ1OCwzNDU5LDcsMzUzNSwzNTM1LDUsMzUzOCwzNTQwLDUsMzU0NCwzNTUwLDcsMzU3MCwzNTcxLDcsMzYzNSwzNjM1LDcsMzY1NSwzNjYyLDUsMzc2MywzNzYzLDcsMzc4NCwzNzg5LDUsMzg5MywzODkzLDUsMzg5NywzODk3LDUsMzk1MywzOTY2LDUsMzk2OCwzOTcyLDUsMzk4MSwzOTkxLDUsNDAzOCw0MDM4LDUsNDE0NSw0MTQ1LDcsNDE1Myw0MTU0LDUsNDE1Nyw0MTU4LDUsNDE4NCw0MTg1LDUsNDIwOSw0MjEyLDUsNDIyOCw0MjI4LDcsNDIzNyw0MjM3LDUsNDM1Miw0NDQ3LDgsNDUyMCw0NjA3LDEwLDU5MDYsNTkwOCw1LDU5MzgsNTkzOSw1LDU5NzAsNTk3MSw1LDYwNjgsNjA2OSw1LDYwNzEsNjA3Nyw1LDYwODYsNjA4Niw1LDYwODksNjA5OSw1LDYxNTUsNjE1Nyw1LDYxNTksNjE1OSw1LDYzMTMsNjMxMyw1LDY0MzUsNjQzOCw3LDY0NDEsNjQ0Myw3LDY0NTAsNjQ1MCw1LDY0NTcsNjQ1OSw1LDY2ODEsNjY4Miw3LDY3NDEsNjc0MSw3LDY3NDMsNjc0Myw3LDY3NTIsNjc1Miw1LDY3NTcsNjc2NCw1LDY3NzEsNjc4MCw1LDY4MzIsNjg0NSw1LDY4NDcsNjg2Miw1LDY5MTYsNjkxNiw3LDY5NjUsNjk2NSw1LDY5NzEsNjk3MSw3LDY5NzMsNjk3Nyw3LDY5NzksNjk4MCw3LDcwNDAsNzA0MSw1LDcwNzMsNzA3Myw3LDcwNzgsNzA3OSw3LDcwODIsNzA4Miw3LDcxNDIsNzE0Miw1LDcxNDQsNzE0NSw1LDcxNDksNzE0OSw1LDcxNTEsNzE1Myw1LDcyMDQsNzIxMSw3LDcyMjAsNzIyMSw3LDczNzYsNzM3OCw1LDczOTMsNzM5Myw3LDc0MDUsNzQwNSw1LDc0MTUsNzQxNSw3LDc2MTYsNzY3OSw1LDgyMDQsODIwNCw1LDgyMDYsODIwNyw0LDgyMzMsODIzMyw0LDgyNTIsODI1MiwxNCw4Mjg4LDgyOTIsNCw4Mjk0LDgzMDMsNCw4NDEzLDg0MTYsNSw4NDE4LDg0MjAsNSw4NDgyLDg0ODIsMTQsODU5Niw4NjAxLDE0LDg5ODYsODk4NywxNCw5MDk2LDkwOTYsMTQsOTE5Myw5MTk2LDE0LDkxOTksOTE5OSwxNCw5MjAxLDkyMDIsMTQsOTIwOCw5MjEwLDE0LDk2NDIsOTY0MywxNCw5NjY0LDk2NjQsMTQsOTcyOCw5NzI5LDE0LDk3MzIsOTczMiwxNCw5NzM1LDk3NDEsMTQsOTc0Myw5NzQ0LDE0LDk3NDYsOTc0NiwxNCw5NzUwLDk3NTEsMTQsOTc1Myw5NzU2LDE0LDk3NTgsOTc1OSwxNCw5NzYxLDk3NjEsMTQsOTc2NCw5NzY1LDE0LDk3NjcsOTc2OSwxNCw5NzcxLDk3NzMsMTQsOTc3NSw5Nzc1LDE0LDk3ODQsOTc4NSwxNCw5Nzg3LDk3OTEsMTQsOTc5Myw5NzkzLDE0LDk3OTUsOTc5OSwxNCw5ODEyLDk4MjIsMTQsOTgyNCw5ODI0LDE0LDk4MjcsOTgyNywxNCw5ODI5LDk4MzAsMTQsOTgzMiw5ODMyLDE0LDk4NTEsOTg1MSwxNCw5ODU0LDk4NTQsMTQsOTg1Niw5ODYxLDE0LDk4NzQsOTg3NCwxNCw5ODc2LDk4NzYsMTQsOTg3OCw5ODc5LDE0LDk4ODEsOTg4MSwxNCw5ODgzLDk4ODQsMTQsOTg4OCw5ODg5LDE0LDk4OTUsOTg5NSwxNCw5ODk4LDk4OTksMTQsOTkwNCw5OTA1LDE0LDk5MTcsOTkxOCwxNCw5OTI0LDk5MjUsMTQsOTkyOCw5OTI4LDE0LDk5MzQsOTkzNCwxNCw5OTM2LDk5MzYsMTQsOTkzOCw5OTM4LDE0LDk5NDAsOTk0MCwxNCw5OTYxLDk5NjEsMTQsOTk2Myw5OTY3LDE0LDk5NzAsOTk3MSwxNCw5OTczLDk5NzMsMTQsOTk3NSw5OTc3LDE0LDk5NzksOTk4MCwxNCw5OTgyLDk5ODUsMTQsOTk4Nyw5OTg4LDE0LDk5OTIsOTk5NiwxNCw5OTk4LDk5OTgsMTQsMTAwMDAsMTAwMDEsMTQsMTAwMDQsMTAwMDQsMTQsMTAwMTMsMTAwMTMsMTQsMTAwMjQsMTAwMjQsMTQsMTAwNTIsMTAwNTIsMTQsMTAwNjAsMTAwNjAsMTQsMTAwNjcsMTAwNjksMTQsMTAwODMsMTAwODMsMTQsMTAwODUsMTAwODcsMTQsMTAxNDUsMTAxNDUsMTQsMTAxNzUsMTAxNzUsMTQsMTEwMTMsMTEwMTUsMTQsMTEwODgsMTEwODgsMTQsMTE1MDMsMTE1MDUsNSwxMTc0NCwxMTc3NSw1LDEyMzM0LDEyMzM1LDUsMTIzNDksMTIzNDksMTQsMTI5NTEsMTI5NTEsMTQsNDI2MDcsNDI2MDcsNSw0MjYxMiw0MjYyMSw1LDQyNzM2LDQyNzM3LDUsNDMwMTQsNDMwMTQsNSw0MzA0Myw0MzA0NCw3LDQzMDQ3LDQzMDQ3LDcsNDMxMzYsNDMxMzcsNyw0MzIwNCw0MzIwNSw1LDQzMjYzLDQzMjYzLDUsNDMzMzUsNDMzNDUsNSw0MzM2MCw0MzM4OCw4LDQzMzk1LDQzMzk1LDcsNDM0NDQsNDM0NDUsNyw0MzQ1MCw0MzQ1MSw3LDQzNDU0LDQzNDU2LDcsNDM1NjEsNDM1NjYsNSw0MzU2OSw0MzU3MCw1LDQzNTczLDQzNTc0LDUsNDM1OTYsNDM1OTYsNSw0MzY0NCw0MzY0NCw1LDQzNjk4LDQzNzAwLDUsNDM3MTAsNDM3MTEsNSw0Mzc1NSw0Mzc1NSw3LDQzNzU4LDQzNzU5LDcsNDM3NjYsNDM3NjYsNSw0NDAwNSw0NDAwNSw1LDQ0MDA4LDQ0MDA4LDUsNDQwMTIsNDQwMTIsNyw0NDAzMiw0NDAzMiwxMSw0NDA2MCw0NDA2MCwxMSw0NDA4OCw0NDA4OCwxMSw0NDExNiw0NDExNiwxMSw0NDE0NCw0NDE0NCwxMSw0NDE3Miw0NDE3MiwxMSw0NDIwMCw0NDIwMCwxMSw0NDIyOCw0NDIyOCwxMSw0NDI1Niw0NDI1NiwxMSw0NDI4NCw0NDI4NCwxMSw0NDMxMiw0NDMxMiwxMSw0NDM0MCw0NDM0MCwxMSw0NDM2OCw0NDM2OCwxMSw0NDM5Niw0NDM5NiwxMSw0NDQyNCw0NDQyNCwxMSw0NDQ1Miw0NDQ1MiwxMSw0NDQ4MCw0NDQ4MCwxMSw0NDUwOCw0NDUwOCwxMSw0NDUzNiw0NDUzNiwxMSw0NDU2NCw0NDU2NCwxMSw0NDU5Miw0NDU5MiwxMSw0NDYyMCw0NDYyMCwxMSw0NDY0OCw0NDY0OCwxMSw0NDY3Niw0NDY3NiwxMSw0NDcwNCw0NDcwNCwxMSw0NDczMiw0NDczMiwxMSw0NDc2MCw0NDc2MCwxMSw0NDc4OCw0NDc4OCwxMSw0NDgxNiw0NDgxNiwxMSw0NDg0NCw0NDg0NCwxMSw0NDg3Miw0NDg3MiwxMSw0NDkwMCw0NDkwMCwxMSw0NDkyOCw0NDkyOCwxMSw0NDk1Niw0NDk1NiwxMSw0NDk4NCw0NDk4NCwxMSw0NTAxMiw0NTAxMiwxMSw0NTA0MCw0NTA0MCwxMSw0NTA2OCw0NTA2OCwxMSw0NTA5Niw0NTA5NiwxMSw0NTEyNCw0NTEyNCwxMSw0NTE1Miw0NTE1MiwxMSw0NTE4MCw0NTE4MCwxMSw0NTIwOCw0NTIwOCwxMSw0NTIzNiw0NTIzNiwxMSw0NTI2NCw0NTI2NCwxMSw0NTI5Miw0NTI5MiwxMSw0NTMyMCw0NTMyMCwxMSw0NTM0OCw0NTM0OCwxMSw0NTM3Niw0NTM3NiwxMSw0NTQwNCw0NTQwNCwxMSw0NTQzMiw0NTQzMiwxMSw0NTQ2MCw0NTQ2MCwxMSw0NTQ4OCw0NTQ4OCwxMSw0NTUxNiw0NTUxNiwxMSw0NTU0NCw0NTU0NCwxMSw0NTU3Miw0NTU3MiwxMSw0NTYwMCw0NTYwMCwxMSw0NTYyOCw0NTYyOCwxMSw0NTY1Niw0NTY1NiwxMSw0NTY4NCw0NTY4NCwxMSw0NTcxMiw0NTcxMiwxMSw0NTc0MCw0NTc0MCwxMSw0NTc2OCw0NTc2OCwxMSw0NTc5Niw0NTc5NiwxMSw0NTgyNCw0NTgyNCwxMSw0NTg1Miw0NTg1MiwxMSw0NTg4MCw0NTg4MCwxMSw0NTkwOCw0NTkwOCwxMSw0NTkzNiw0NTkzNiwxMSw0NTk2NCw0NTk2NCwxMSw0NTk5Miw0NTk5MiwxMSw0NjAyMCw0NjAyMCwxMSw0NjA0OCw0NjA0OCwxMSw0NjA3Niw0NjA3NiwxMSw0NjEwNCw0NjEwNCwxMSw0NjEzMiw0NjEzMiwxMSw0NjE2MCw0NjE2MCwxMSw0NjE4OCw0NjE4OCwxMSw0NjIxNiw0NjIxNiwxMSw0NjI0NCw0NjI0NCwxMSw0NjI3Miw0NjI3MiwxMSw0NjMwMCw0NjMwMCwxMSw0NjMyOCw0NjMyOCwxMSw0NjM1Niw0NjM1NiwxMSw0NjM4NCw0NjM4NCwxMSw0NjQxMiw0NjQxMiwxMSw0NjQ0MCw0NjQ0MCwxMSw0NjQ2OCw0NjQ2OCwxMSw0NjQ5Niw0NjQ5NiwxMSw0NjUyNCw0NjUyNCwxMSw0NjU1Miw0NjU1MiwxMSw0NjU4MCw0NjU4MCwxMSw0NjYwOCw0NjYwOCwxMSw0NjYzNiw0NjYzNiwxMSw0NjY2NCw0NjY2NCwxMSw0NjY5Miw0NjY5MiwxMSw0NjcyMCw0NjcyMCwxMSw0Njc0OCw0Njc0OCwxMSw0Njc3Niw0Njc3NiwxMSw0NjgwNCw0NjgwNCwxMSw0NjgzMiw0NjgzMiwxMSw0Njg2MCw0Njg2MCwxMSw0Njg4OCw0Njg4OCwxMSw0NjkxNiw0NjkxNiwxMSw0Njk0NCw0Njk0NCwxMSw0Njk3Miw0Njk3MiwxMSw0NzAwMCw0NzAwMCwxMSw0NzAyOCw0NzAyOCwxMSw0NzA1Niw0NzA1NiwxMSw0NzA4NCw0NzA4NCwxMSw0NzExMiw0NzExMiwxMSw0NzE0MCw0NzE0MCwxMSw0NzE2OCw0NzE2OCwxMSw0NzE5Niw0NzE5NiwxMSw0NzIyNCw0NzIyNCwxMSw0NzI1Miw0NzI1MiwxMSw0NzI4MCw0NzI4MCwxMSw0NzMwOCw0NzMwOCwxMSw0NzMzNiw0NzMzNiwxMSw0NzM2NCw0NzM2NCwxMSw0NzM5Miw0NzM5MiwxMSw0NzQyMCw0NzQyMCwxMSw0NzQ0OCw0NzQ0OCwxMSw0NzQ3Niw0NzQ3NiwxMSw0NzUwNCw0NzUwNCwxMSw0NzUzMiw0NzUzMiwxMSw0NzU2MCw0NzU2MCwxMSw0NzU4OCw0NzU4OCwxMSw0NzYxNiw0NzYxNiwxMSw0NzY0NCw0NzY0NCwxMSw0NzY3Miw0NzY3MiwxMSw0NzcwMCw0NzcwMCwxMSw0NzcyOCw0NzcyOCwxMSw0Nzc1Niw0Nzc1NiwxMSw0Nzc4NCw0Nzc4NCwxMSw0NzgxMiw0NzgxMiwxMSw0Nzg0MCw0Nzg0MCwxMSw0Nzg2OCw0Nzg2OCwxMSw0Nzg5Niw0Nzg5NiwxMSw0NzkyNCw0NzkyNCwxMSw0Nzk1Miw0Nzk1MiwxMSw0Nzk4MCw0Nzk4MCwxMSw0ODAwOCw0ODAwOCwxMSw0ODAzNiw0ODAzNiwxMSw0ODA2NCw0ODA2NCwxMSw0ODA5Miw0ODA5MiwxMSw0ODEyMCw0ODEyMCwxMSw0ODE0OCw0ODE0OCwxMSw0ODE3Niw0ODE3NiwxMSw0ODIwNCw0ODIwNCwxMSw0ODIzMiw0ODIzMiwxMSw0ODI2MCw0ODI2MCwxMSw0ODI4OCw0ODI4OCwxMSw0ODMxNiw0ODMxNiwxMSw0ODM0NCw0ODM0NCwxMSw0ODM3Miw0ODM3MiwxMSw0ODQwMCw0ODQwMCwxMSw0ODQyOCw0ODQyOCwxMSw0ODQ1Niw0ODQ1NiwxMSw0ODQ4NCw0ODQ4NCwxMSw0ODUxMiw0ODUxMiwxMSw0ODU0MCw0ODU0MCwxMSw0ODU2OCw0ODU2OCwxMSw0ODU5Niw0ODU5NiwxMSw0ODYyNCw0ODYyNCwxMSw0ODY1Miw0ODY1MiwxMSw0ODY4MCw0ODY4MCwxMSw0ODcwOCw0ODcwOCwxMSw0ODczNiw0ODczNiwxMSw0ODc2NCw0ODc2NCwxMSw0ODc5Miw0ODc5MiwxMSw0ODgyMCw0ODgyMCwxMSw0ODg0OCw0ODg0OCwxMSw0ODg3Niw0ODg3NiwxMSw0ODkwNCw0ODkwNCwxMSw0ODkzMiw0ODkzMiwxMSw0ODk2MCw0ODk2MCwxMSw0ODk4OCw0ODk4OCwxMSw0OTAxNiw0OTAxNiwxMSw0OTA0NCw0OTA0NCwxMSw0OTA3Miw0OTA3MiwxMSw0OTEwMCw0OTEwMCwxMSw0OTEyOCw0OTEyOCwxMSw0OTE1Niw0OTE1NiwxMSw0OTE4NCw0OTE4NCwxMSw0OTIxMiw0OTIxMiwxMSw0OTI0MCw0OTI0MCwxMSw0OTI2OCw0OTI2OCwxMSw0OTI5Niw0OTI5NiwxMSw0OTMyNCw0OTMyNCwxMSw0OTM1Miw0OTM1MiwxMSw0OTM4MCw0OTM4MCwxMSw0OTQwOCw0OTQwOCwxMSw0OTQzNiw0OTQzNiwxMSw0OTQ2NCw0OTQ2NCwxMSw0OTQ5Miw0OTQ5MiwxMSw0OTUyMCw0OTUyMCwxMSw0OTU0OCw0OTU0OCwxMSw0OTU3Niw0OTU3NiwxMSw0OTYwNCw0OTYwNCwxMSw0OTYzMiw0OTYzMiwxMSw0OTY2MCw0OTY2MCwxMSw0OTY4OCw0OTY4OCwxMSw0OTcxNiw0OTcxNiwxMSw0OTc0NCw0OTc0NCwxMSw0OTc3Miw0OTc3MiwxMSw0OTgwMCw0OTgwMCwxMSw0OTgyOCw0OTgyOCwxMSw0OTg1Niw0OTg1NiwxMSw0OTg4NCw0OTg4NCwxMSw0OTkxMiw0OTkxMiwxMSw0OTk0MCw0OTk0MCwxMSw0OTk2OCw0OTk2OCwxMSw0OTk5Niw0OTk5NiwxMSw1MDAyNCw1MDAyNCwxMSw1MDA1Miw1MDA1MiwxMSw1MDA4MCw1MDA4MCwxMSw1MDEwOCw1MDEwOCwxMSw1MDEzNiw1MDEzNiwxMSw1MDE2NCw1MDE2NCwxMSw1MDE5Miw1MDE5MiwxMSw1MDIyMCw1MDIyMCwxMSw1MDI0OCw1MDI0OCwxMSw1MDI3Niw1MDI3NiwxMSw1MDMwNCw1MDMwNCwxMSw1MDMzMiw1MDMzMiwxMSw1MDM2MCw1MDM2MCwxMSw1MDM4OCw1MDM4OCwxMSw1MDQxNiw1MDQxNiwxMSw1MDQ0NCw1MDQ0NCwxMSw1MDQ3Miw1MDQ3MiwxMSw1MDUwMCw1MDUwMCwxMSw1MDUyOCw1MDUyOCwxMSw1MDU1Niw1MDU1NiwxMSw1MDU4NCw1MDU4NCwxMSw1MDYxMiw1MDYxMiwxMSw1MDY0MCw1MDY0MCwxMSw1MDY2OCw1MDY2OCwxMSw1MDY5Niw1MDY5NiwxMSw1MDcyNCw1MDcyNCwxMSw1MDc1Miw1MDc1MiwxMSw1MDc4MCw1MDc4MCwxMSw1MDgwOCw1MDgwOCwxMSw1MDgzNiw1MDgzNiwxMSw1MDg2NCw1MDg2NCwxMSw1MDg5Miw1MDg5MiwxMSw1MDkyMCw1MDkyMCwxMSw1MDk0OCw1MDk0OCwxMSw1MDk3Niw1MDk3NiwxMSw1MTAwNCw1MTAwNCwxMSw1MTAzMiw1MTAzMiwxMSw1MTA2MCw1MTA2MCwxMSw1MTA4OCw1MTA4OCwxMSw1MTExNiw1MTExNiwxMSw1MTE0NCw1MTE0NCwxMSw1MTE3Miw1MTE3MiwxMSw1MTIwMCw1MTIwMCwxMSw1MTIyOCw1MTIyOCwxMSw1MTI1Niw1MTI1NiwxMSw1MTI4NCw1MTI4NCwxMSw1MTMxMiw1MTMxMiwxMSw1MTM0MCw1MTM0MCwxMSw1MTM2OCw1MTM2OCwxMSw1MTM5Niw1MTM5NiwxMSw1MTQyNCw1MTQyNCwxMSw1MTQ1Miw1MTQ1MiwxMSw1MTQ4MCw1MTQ4MCwxMSw1MTUwOCw1MTUwOCwxMSw1MTUzNiw1MTUzNiwxMSw1MTU2NCw1MTU2NCwxMSw1MTU5Miw1MTU5MiwxMSw1MTYyMCw1MTYyMCwxMSw1MTY0OCw1MTY0OCwxMSw1MTY3Niw1MTY3NiwxMSw1MTcwNCw1MTcwNCwxMSw1MTczMiw1MTczMiwxMSw1MTc2MCw1MTc2MCwxMSw1MTc4OCw1MTc4OCwxMSw1MTgxNiw1MTgxNiwxMSw1MTg0NCw1MTg0NCwxMSw1MTg3Miw1MTg3MiwxMSw1MTkwMCw1MTkwMCwxMSw1MTkyOCw1MTkyOCwxMSw1MTk1Niw1MTk1NiwxMSw1MTk4NCw1MTk4NCwxMSw1MjAxMiw1MjAxMiwxMSw1MjA0MCw1MjA0MCwxMSw1MjA2OCw1MjA2OCwxMSw1MjA5Niw1MjA5NiwxMSw1MjEyNCw1MjEyNCwxMSw1MjE1Miw1MjE1MiwxMSw1MjE4MCw1MjE4MCwxMSw1MjIwOCw1MjIwOCwxMSw1MjIzNiw1MjIzNiwxMSw1MjI2NCw1MjI2NCwxMSw1MjI5Miw1MjI5MiwxMSw1MjMyMCw1MjMyMCwxMSw1MjM0OCw1MjM0OCwxMSw1MjM3Niw1MjM3NiwxMSw1MjQwNCw1MjQwNCwxMSw1MjQzMiw1MjQzMiwxMSw1MjQ2MCw1MjQ2MCwxMSw1MjQ4OCw1MjQ4OCwxMSw1MjUxNiw1MjUxNiwxMSw1MjU0NCw1MjU0NCwxMSw1MjU3Miw1MjU3MiwxMSw1MjYwMCw1MjYwMCwxMSw1MjYyOCw1MjYyOCwxMSw1MjY1Niw1MjY1NiwxMSw1MjY4NCw1MjY4NCwxMSw1MjcxMiw1MjcxMiwxMSw1Mjc0MCw1Mjc0MCwxMSw1Mjc2OCw1Mjc2OCwxMSw1Mjc5Niw1Mjc5NiwxMSw1MjgyNCw1MjgyNCwxMSw1Mjg1Miw1Mjg1MiwxMSw1Mjg4MCw1Mjg4MCwxMSw1MjkwOCw1MjkwOCwxMSw1MjkzNiw1MjkzNiwxMSw1Mjk2NCw1Mjk2NCwxMSw1Mjk5Miw1Mjk5MiwxMSw1MzAyMCw1MzAyMCwxMSw1MzA0OCw1MzA0OCwxMSw1MzA3Niw1MzA3NiwxMSw1MzEwNCw1MzEwNCwxMSw1MzEzMiw1MzEzMiwxMSw1MzE2MCw1MzE2MCwxMSw1MzE4OCw1MzE4OCwxMSw1MzIxNiw1MzIxNiwxMSw1MzI0NCw1MzI0NCwxMSw1MzI3Miw1MzI3MiwxMSw1MzMwMCw1MzMwMCwxMSw1MzMyOCw1MzMyOCwxMSw1MzM1Niw1MzM1NiwxMSw1MzM4NCw1MzM4NCwxMSw1MzQxMiw1MzQxMiwxMSw1MzQ0MCw1MzQ0MCwxMSw1MzQ2OCw1MzQ2OCwxMSw1MzQ5Niw1MzQ5NiwxMSw1MzUyNCw1MzUyNCwxMSw1MzU1Miw1MzU1MiwxMSw1MzU4MCw1MzU4MCwxMSw1MzYwOCw1MzYwOCwxMSw1MzYzNiw1MzYzNiwxMSw1MzY2NCw1MzY2NCwxMSw1MzY5Miw1MzY5MiwxMSw1MzcyMCw1MzcyMCwxMSw1Mzc0OCw1Mzc0OCwxMSw1Mzc3Niw1Mzc3NiwxMSw1MzgwNCw1MzgwNCwxMSw1MzgzMiw1MzgzMiwxMSw1Mzg2MCw1Mzg2MCwxMSw1Mzg4OCw1Mzg4OCwxMSw1MzkxNiw1MzkxNiwxMSw1Mzk0NCw1Mzk0NCwxMSw1Mzk3Miw1Mzk3MiwxMSw1NDAwMCw1NDAwMCwxMSw1NDAyOCw1NDAyOCwxMSw1NDA1Niw1NDA1NiwxMSw1NDA4NCw1NDA4NCwxMSw1NDExMiw1NDExMiwxMSw1NDE0MCw1NDE0MCwxMSw1NDE2OCw1NDE2OCwxMSw1NDE5Niw1NDE5NiwxMSw1NDIyNCw1NDIyNCwxMSw1NDI1Miw1NDI1MiwxMSw1NDI4MCw1NDI4MCwxMSw1NDMwOCw1NDMwOCwxMSw1NDMzNiw1NDMzNiwxMSw1NDM2NCw1NDM2NCwxMSw1NDM5Miw1NDM5MiwxMSw1NDQyMCw1NDQyMCwxMSw1NDQ0OCw1NDQ0OCwxMSw1NDQ3Niw1NDQ3NiwxMSw1NDUwNCw1NDUwNCwxMSw1NDUzMiw1NDUzMiwxMSw1NDU2MCw1NDU2MCwxMSw1NDU4OCw1NDU4OCwxMSw1NDYxNiw1NDYxNiwxMSw1NDY0NCw1NDY0NCwxMSw1NDY3Miw1NDY3MiwxMSw1NDcwMCw1NDcwMCwxMSw1NDcyOCw1NDcyOCwxMSw1NDc1Niw1NDc1NiwxMSw1NDc4NCw1NDc4NCwxMSw1NDgxMiw1NDgxMiwxMSw1NDg0MCw1NDg0MCwxMSw1NDg2OCw1NDg2OCwxMSw1NDg5Niw1NDg5NiwxMSw1NDkyNCw1NDkyNCwxMSw1NDk1Miw1NDk1MiwxMSw1NDk4MCw1NDk4MCwxMSw1NTAwOCw1NTAwOCwxMSw1NTAzNiw1NTAzNiwxMSw1NTA2NCw1NTA2NCwxMSw1NTA5Miw1NTA5MiwxMSw1NTEyMCw1NTEyMCwxMSw1NTE0OCw1NTE0OCwxMSw1NTE3Niw1NTE3NiwxMSw1NTIxNiw1NTIzOCw5LDY0Mjg2LDY0Mjg2LDUsNjUwNTYsNjUwNzEsNSw2NTQzOCw2NTQzOSw1LDY1NTI5LDY1NTMxLDQsNjYyNzIsNjYyNzIsNSw2ODA5Nyw2ODA5OSw1LDY4MTA4LDY4MTExLDUsNjgxNTksNjgxNTksNSw2ODkwMCw2ODkwMyw1LDY5NDQ2LDY5NDU2LDUsNjk2MzIsNjk2MzIsNyw2OTYzNCw2OTYzNCw3LDY5NzQ0LDY5NzQ0LDUsNjk3NTksNjk3NjEsNSw2OTgwOCw2OTgxMCw3LDY5ODE1LDY5ODE2LDcsNjk4MjEsNjk4MjEsMSw2OTgzNyw2OTgzNywxLDY5OTI3LDY5OTMxLDUsNjk5MzMsNjk5NDAsNSw3MDAwMyw3MDAwMyw1LDcwMDE4LDcwMDE4LDcsNzAwNzAsNzAwNzgsNSw3MDA4Miw3MDA4MywxLDcwMDk0LDcwMDk0LDcsNzAxODgsNzAxOTAsNyw3MDE5NCw3MDE5NSw3LDcwMTk3LDcwMTk3LDcsNzAyMDYsNzAyMDYsNSw3MDM2OCw3MDM3MCw3LDcwNDAwLDcwNDAxLDUsNzA0NTksNzA0NjAsNSw3MDQ2Myw3MDQ2Myw3LDcwNDY1LDcwNDY4LDcsNzA0NzUsNzA0NzcsNyw3MDQ5OCw3MDQ5OSw3LDcwNTEyLDcwNTE2LDUsNzA3MTIsNzA3MTksNSw3MDcyMiw3MDcyNCw1LDcwNzI2LDcwNzI2LDUsNzA4MzIsNzA4MzIsNSw3MDgzNSw3MDg0MCw1LDcwODQyLDcwODQyLDUsNzA4NDUsNzA4NDUsNSw3MDg0Nyw3MDg0OCw1LDcwODUwLDcwODUxLDUsNzEwODgsNzEwODksNyw3MTA5Niw3MTA5OSw3LDcxMTAyLDcxMTAyLDcsNzExMzIsNzExMzMsNSw3MTIxOSw3MTIyNiw1LDcxMjI5LDcxMjI5LDUsNzEyMzEsNzEyMzIsNSw3MTM0MCw3MTM0MCw3LDcxMzQyLDcxMzQzLDcsNzEzNTAsNzEzNTAsNyw3MTQ1Myw3MTQ1NSw1LDcxNDYyLDcxNDYyLDcsNzE3MjQsNzE3MjYsNyw3MTczNiw3MTczNiw3LDcxOTg0LDcxOTg0LDUsNzE5OTEsNzE5OTIsNyw3MTk5Nyw3MTk5Nyw3LDcxOTk5LDcxOTk5LDEsNzIwMDEsNzIwMDEsMSw3MjAwMyw3MjAwMyw1LDcyMTQ4LDcyMTUxLDUsNzIxNTYsNzIxNTksNyw3MjE2NCw3MjE2NCw3LDcyMjQzLDcyMjQ4LDUsNzIyNTAsNzIyNTAsMSw3MjI2Myw3MjI2Myw1LDcyMjc5LDcyMjgwLDcsNzIzMjQsNzIzMjksMSw3MjM0Myw3MjM0Myw3LDcyNzUxLDcyNzUxLDcsNzI3NjAsNzI3NjUsNSw3Mjc2Nyw3Mjc2Nyw1LDcyODczLDcyODczLDcsNzI4ODEsNzI4ODEsNyw3Mjg4NCw3Mjg4NCw3LDczMDA5LDczMDE0LDUsNzMwMjAsNzMwMjEsNSw3MzAzMCw3MzAzMCwxLDczMDk4LDczMTAyLDcsNzMxMDcsNzMxMDgsNyw3MzExMCw3MzExMCw3LDczNDU5LDczNDYwLDUsNzg4OTYsNzg5MDQsNCw5Mjk3Niw5Mjk4Miw1LDk0MDMzLDk0MDg3LDcsOTQxODAsOTQxODAsNSwxMTM4MjEsMTEzODIyLDUsMTE4NTI4LDExODU3Myw1LDExOTE0MSwxMTkxNDEsNSwxMTkxNDMsMTE5MTQ1LDUsMTE5MTUwLDExOTE1NCw1LDExOTE2MywxMTkxNzAsNSwxMTkyMTAsMTE5MjEzLDUsMTIxMzQ0LDEyMTM5OCw1LDEyMTQ2MSwxMjE0NjEsNSwxMjE0OTksMTIxNTAzLDUsMTIyODgwLDEyMjg4Niw1LDEyMjkwNywxMjI5MTMsNSwxMjI5MTgsMTIyOTIyLDUsMTIzNTY2LDEyMzU2Niw1LDEyNTEzNiwxMjUxNDIsNSwxMjY5NzYsMTI2OTc5LDE0LDEyNjk4MSwxMjcxODIsMTQsMTI3MTg0LDEyNzIzMSwxNCwxMjcyNzksMTI3Mjc5LDE0LDEyNzM0NCwxMjczNDUsMTQsMTI3Mzc0LDEyNzM3NCwxNCwxMjc0MDUsMTI3NDYxLDE0LDEyNzQ4OSwxMjc0OTAsMTQsMTI3NTE0LDEyNzUxNCwxNCwxMjc1MzgsMTI3NTQ2LDE0LDEyNzU2MSwxMjc1NjcsMTQsMTI3NTcwLDEyNzc0MywxNCwxMjc3NTcsMTI3NzU4LDE0LDEyNzc2MCwxMjc3NjAsMTQsMTI3NzYyLDEyNzc2MiwxNCwxMjc3NjYsMTI3NzY4LDE0LDEyNzc3MCwxMjc3NzAsMTQsMTI3NzcyLDEyNzc3MiwxNCwxMjc3NzUsMTI3Nzc2LDE0LDEyNzc3OCwxMjc3NzksMTQsMTI3Nzg5LDEyNzc5MSwxNCwxMjc3OTQsMTI3Nzk1LDE0LDEyNzc5OCwxMjc3OTgsMTQsMTI3ODE5LDEyNzgxOSwxNCwxMjc4MjQsMTI3ODI0LDE0LDEyNzg2OCwxMjc4NjgsMTQsMTI3ODcwLDEyNzg3MSwxNCwxMjc4OTIsMTI3ODkzLDE0LDEyNzg5NiwxMjc4OTYsMTQsMTI3OTAwLDEyNzkwMSwxNCwxMjc5MDQsMTI3OTQwLDE0LDEyNzk0MiwxMjc5NDIsMTQsMTI3OTQ0LDEyNzk0NCwxNCwxMjc5NDYsMTI3OTQ2LDE0LDEyNzk1MSwxMjc5NTUsMTQsMTI3OTY4LDEyNzk3MSwxNCwxMjc5NzMsMTI3OTg0LDE0LDEyNzk4NywxMjc5ODcsMTQsMTI3OTg5LDEyNzk4OSwxNCwxMjc5OTEsMTI3OTkxLDE0LDEyNzk5NSwxMjc5OTksNSwxMjgwMDgsMTI4MDA4LDE0LDEyODAxMiwxMjgwMTQsMTQsMTI4MDE3LDEyODAxOCwxNCwxMjgwMjAsMTI4MDIwLDE0LDEyODAyMiwxMjgwMjIsMTQsMTI4MDQyLDEyODA0MiwxNCwxMjgwNjMsMTI4MDYzLDE0LDEyODA2NSwxMjgwNjUsMTQsMTI4MTAxLDEyODEwMSwxNCwxMjgxMDgsMTI4MTA5LDE0LDEyODE3MywxMjgxNzMsMTQsMTI4MTgyLDEyODE4MywxNCwxMjgyMzYsMTI4MjM3LDE0LDEyODIzOSwxMjgyMzksMTQsMTI4MjQ1LDEyODI0NSwxNCwxMjgyNDgsMTI4MjQ4LDE0LDEyODI1MywxMjgyNTMsMTQsMTI4MjU1LDEyODI1OCwxNCwxMjgyNjAsMTI4MjYzLDE0LDEyODI2NSwxMjgyNjUsMTQsMTI4Mjc3LDEyODI3NywxNCwxMjgzMDAsMTI4MzAxLDE0LDEyODMyNiwxMjgzMjgsMTQsMTI4MzMxLDEyODMzNCwxNCwxMjgzMzYsMTI4MzQ3LDE0LDEyODM2MCwxMjgzNjYsMTQsMTI4MzY5LDEyODM3MCwxNCwxMjgzNzgsMTI4Mzc4LDE0LDEyODM5MSwxMjgzOTEsMTQsMTI4Mzk0LDEyODM5NywxNCwxMjg0MDAsMTI4NDAwLDE0LDEyODQwNSwxMjg0MDYsMTQsMTI4NDIwLDEyODQyMCwxNCwxMjg0MjIsMTI4NDIzLDE0LDEyODQyNSwxMjg0MzIsMTQsMTI4NDM1LDEyODQ0MywxNCwxMjg0NDUsMTI4NDQ5LDE0LDEyODQ1MywxMjg0NjQsMTQsMTI4NDY4LDEyODQ3NSwxNCwxMjg0NzksMTI4NDgwLDE0LDEyODQ4MiwxMjg0ODIsMTQsMTI4NDg0LDEyODQ4NywxNCwxMjg0ODksMTI4NDk0LDE0LDEyODQ5NiwxMjg0OTgsMTQsMTI4NTAwLDEyODUwNSwxNCwxMjg1MDcsMTI4NTExLDE0LDEyODUxMywxMjg1MTgsMTQsMTI4NTIxLDEyODUyNSwxNCwxMjg1MjcsMTI4NTI3LDE0LDEyODUyOSwxMjg1MjksMTQsMTI4NTMzLDEyODUzMywxNCwxMjg1MzUsMTI4NTM1LDE0LDEyODUzNywxMjg1MzcsMTRdJyk7XG59XG4vLyNlbmRyZWdpb25cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG9mZnNldCBhZnRlciBwZXJmb3JtaW5nIGEgbGVmdCBkZWxldGUgb24gdGhlIGdpdmVuIHN0cmluZyxcbiAqIHdoaWxlIGNvbnNpZGVyaW5nIHVuaWNvZGUgZ3JhcGhlbWUvZW1vamkgcnVsZXMuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlZnREZWxldGVPZmZzZXQob2Zmc2V0LCBzdHIpIHtcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZGVsZXRlIGVtb2ppIHBhcnQuXG4gICAgY29uc3QgZW1vamlPZmZzZXQgPSBnZXRPZmZzZXRCZWZvcmVMYXN0RW1vamlDb21wb25lbnQob2Zmc2V0LCBzdHIpO1xuICAgIGlmIChlbW9qaU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbW9qaU9mZnNldDtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHNraXAgYSBzaW5nbGUgY29kZSBwb2ludC5cbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBDb2RlUG9pbnRJdGVyYXRvcihzdHIsIG9mZnNldCk7XG4gICAgaXRlcmF0b3IucHJldkNvZGVQb2ludCgpO1xuICAgIHJldHVybiBpdGVyYXRvci5vZmZzZXQ7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRCZWZvcmVMYXN0RW1vamlDb21wb25lbnQoaW5pdGlhbE9mZnNldCwgc3RyKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHI1MS90cjUxLTE0Lmh0bWwjRUJORl9hbmRfUmVnZXggZm9yIHRoZVxuICAgIC8vIHN0cnVjdHVyZSBvZiBlbW9qaXMuXG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgQ29kZVBvaW50SXRlcmF0b3Ioc3RyLCBpbml0aWFsT2Zmc2V0KTtcbiAgICBsZXQgY29kZVBvaW50ID0gaXRlcmF0b3IucHJldkNvZGVQb2ludCgpO1xuICAgIC8vIFNraXAgbW9kaWZpZXJzXG4gICAgd2hpbGUgKChpc0Vtb2ppTW9kaWZpZXIoY29kZVBvaW50KSB8fCBjb2RlUG9pbnQgPT09IDY1MDM5IC8qIGVtb2ppVmFyaWFudFNlbGVjdG9yICovIHx8IGNvZGVQb2ludCA9PT0gODQxOSAvKiBlbmNsb3NpbmdLZXlDYXAgKi8pKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIENhbm5vdCBza2lwIG1vZGlmaWVyLCBubyBwcmVjZWRpbmcgZW1vamkgYmFzZS5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50ID0gaXRlcmF0b3IucHJldkNvZGVQb2ludCgpO1xuICAgIH1cbiAgICAvLyBFeHBlY3QgYmFzZSBlbW9qaVxuICAgIGlmICghaXNFbW9qaUltcHJlY2lzZShjb2RlUG9pbnQpKSB7XG4gICAgICAgIC8vIFVuZXhwZWN0ZWQgY29kZSBwb2ludCwgbm90IGEgdmFsaWQgZW1vamkuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCByZXN1bHRPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgaWYgKHJlc3VsdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gU2tpcCBvcHRpb25hbCBaV0ogY29kZSBwb2ludHMgdGhhdCBjb21iaW5lIG11bHRpcGxlIGVtb2ppcy5cbiAgICAgICAgLy8gSW4gdGhlb3J5LCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhhdCBaV0ogYWN0dWFsbHkgY29tYmluZXMgbXVsdGlwbGUgZW1vamlzXG4gICAgICAgIC8vIHRvIHByZXZlbnQgZGVsZXRpbmcgWldKcyBpbiBzaXR1YXRpb25zIHdlIGRpZG4ndCBhY2NvdW50IGZvci5cbiAgICAgICAgY29uc3Qgb3B0aW9uYWxad2pDb2RlUG9pbnQgPSBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XG4gICAgICAgIGlmIChvcHRpb25hbFp3akNvZGVQb2ludCA9PT0gODIwNSAvKiB6d2ogKi8pIHtcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IGl0ZXJhdG9yLm9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xufVxuZnVuY3Rpb24gaXNFbW9qaU1vZGlmaWVyKGNvZGVQb2ludCkge1xuICAgIHJldHVybiAweDFGM0ZCIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgxRjNGRjtcbn1cbmV4cG9ydCBjb25zdCBub0JyZWFrV2hpdGVzcGFjZSA9ICdcXHhhMCc7XG5leHBvcnQgY2xhc3MgQW1iaWd1b3VzQ2hhcmFjdGVycyB7XG4gICAgY29uc3RydWN0b3IoY29uZnVzYWJsZURpY3Rpb25hcnkpIHtcbiAgICAgICAgdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeSA9IGNvbmZ1c2FibGVEaWN0aW9uYXJ5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UobG9jYWxlcykge1xuICAgICAgICByZXR1cm4gQW1iaWd1b3VzQ2hhcmFjdGVycy5jYWNoZS5nZXQoQXJyYXkuZnJvbShsb2NhbGVzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4gQW1iaWd1b3VzQ2hhcmFjdGVycy5fbG9jYWxlcy5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBpc0FtYmlndW91cyhjb2RlUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZnVzYWJsZURpY3Rpb25hcnkuaGFzKGNvZGVQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vbiBiYXNpYyBBU0NJSSBjb2RlIHBvaW50IHRoYXQgdGhlIGdpdmVuIGNvZGUgcG9pbnQgY2FuIGJlIGNvbmZ1c2VkLFxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiBzdWNoIGNvZGUgcG9pbnQgZG9lcyBub3RlIGV4aXN0LlxuICAgICAqL1xuICAgIGdldFByaW1hcnlDb25mdXNhYmxlKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeS5nZXQoY29kZVBvaW50KTtcbiAgICB9XG4gICAgZ2V0Q29uZnVzYWJsZUNvZGVQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuY29uZnVzYWJsZURpY3Rpb25hcnkua2V5cygpKTtcbiAgICB9XG59XG5fYSA9IEFtYmlndW91c0NoYXJhY3RlcnM7XG5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmFtYmlndW91c0NoYXJhY3RlckRhdGEgPSBuZXcgTGF6eSgoKSA9PiB7XG4gICAgLy8gR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWRpZXQvdnNjb2RlLXVuaWNvZGUtZGF0YVxuICAgIC8vIFN0b3JlZCBhcyBrZXkxLCB2YWx1ZTEsIGtleTIsIHZhbHVlMiwgLi4uXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoJ3tcXFwiX2NvbW1vblxcXCI6WzgyMzIsMzIsODIzMywzMiw1NzYwLDMyLDgxOTIsMzIsODE5MywzMiw4MTk0LDMyLDgxOTUsMzIsODE5NiwzMiw4MTk3LDMyLDgxOTgsMzIsODIwMCwzMiw4MjAxLDMyLDgyMDIsMzIsODI4NywzMiw4MTk5LDMyLDgyMzksMzIsMjA0Miw5NSw2NTEwMSw5NSw2NTEwMiw5NSw2NTEwMyw5NSw4MjA4LDQ1LDgyMDksNDUsODIxMCw0NSw2NTExMiw0NSwxNzQ4LDQ1LDgyNTksNDUsNzI3LDQ1LDg3MjIsNDUsMTAxMzQsNDUsMTE0NTAsNDUsMTU0OSw0NCwxNjQzLDQ0LDgyMTgsNDQsMTg0LDQ0LDQyMjMzLDQ0LDg5NCw1OSwyMzA3LDU4LDI2OTEsNTgsMTQxNyw1OCwxNzk1LDU4LDE3OTYsNTgsNTg2OCw1OCw2NTA3Miw1OCw2MTQ3LDU4LDYxNTMsNTgsODI4Miw1OCwxNDc1LDU4LDc2MCw1OCw0Mjg4OSw1OCw4NzU4LDU4LDcyMCw1OCw0MjIzNyw1OCw0NTEsMzMsMTE2MDEsMzMsNjYwLDYzLDU3Nyw2MywyNDI5LDYzLDUwMzgsNjMsNDI3MzEsNjMsMTE5MTQ5LDQ2LDgyMjgsNDYsMTc5Myw0NiwxNzk0LDQ2LDQyNTEwLDQ2LDY4MTc2LDQ2LDE2MzIsNDYsMTc3Niw0Niw0MjIzMiw0NiwxMzczLDk2LDY1Mjg3LDk2LDgyMTksOTYsODI0Miw5NiwxMzcwLDk2LDE1MjMsOTYsODE3NSw5Niw2NTM0NCw5Niw5MDAsOTYsODE4OSw5Niw4MTI1LDk2LDgxMjcsOTYsODE5MCw5Niw2OTcsOTYsODg0LDk2LDcxMiw5Niw3MTQsOTYsNzE1LDk2LDc1Niw5Niw2OTksOTYsNzAxLDk2LDcwMCw5Niw3MDIsOTYsNDI4OTIsOTYsMTQ5Nyw5NiwyMDM2LDk2LDIwMzcsOTYsNTE5NCw5Niw1ODM2LDk2LDk0MDMzLDk2LDk0MDM0LDk2LDY1MzM5LDkxLDEwMDg4LDQwLDEwMDk4LDQwLDEyMzA4LDQwLDY0ODMwLDQwLDY1MzQxLDkzLDEwMDg5LDQxLDEwMDk5LDQxLDEyMzA5LDQxLDY0ODMxLDQxLDEwMTAwLDEyMywxMTkwNjAsMTIzLDEwMTAxLDEyNSw2NTM0Miw5NCw4MjcwLDQyLDE2NDUsNDIsODcyNyw0Miw2NjMzNSw0Miw1OTQxLDQ3LDgyNTcsNDcsODcyNSw0Nyw4MjYwLDQ3LDk1ODUsNDcsMTAxODcsNDcsMTA3NDQsNDcsMTE5MzU0LDQ3LDEyNzU1LDQ3LDEyMzM5LDQ3LDExNDYyLDQ3LDIwMDMxLDQ3LDEyMDM1LDQ3LDY1MzQwLDkyLDY1MTI4LDkyLDg3MjYsOTIsMTAxODksOTIsMTA3NDEsOTIsMTA3NDUsOTIsMTE5MzExLDkyLDExOTM1NSw5MiwxMjc1Niw5MiwyMDAyMiw5MiwxMjAzNCw5Miw0Mjg3MiwzOCw3MDgsOTQsNzEwLDk0LDU4NjksNDMsMTAxMzMsNDMsNjYyMDMsNDMsODI0OSw2MCwxMDA5NCw2MCw3MDYsNjAsMTE5MzUwLDYwLDUxNzYsNjAsNTgxMCw2MCw1MTIwLDYxLDExODQwLDYxLDEyNDQ4LDYxLDQyMjM5LDYxLDgyNTAsNjIsMTAwOTUsNjIsNzA3LDYyLDExOTM1MSw2Miw1MTcxLDYyLDk0MDE1LDYyLDgyNzUsMTI2LDczMiwxMjYsODEyOCwxMjYsODc2NCwxMjYsNjUzNzIsMTI0LDY1MjkzLDQ1LDEyMDc4NCw1MCwxMjA3OTQsNTAsMTIwODA0LDUwLDEyMDgxNCw1MCwxMjA4MjQsNTAsMTMwMDM0LDUwLDQyODQyLDUwLDQyMyw1MCwxMDAwLDUwLDQyNTY0LDUwLDUzMTEsNTAsNDI3MzUsNTAsMTE5MzAyLDUxLDEyMDc4NSw1MSwxMjA3OTUsNTEsMTIwODA1LDUxLDEyMDgxNSw1MSwxMjA4MjUsNTEsMTMwMDM1LDUxLDQyOTIzLDUxLDU0MCw1MSw0MzksNTEsNDI4NTgsNTEsMTE0NjgsNTEsMTI0OCw1MSw5NDAxMSw1MSw3MTg4Miw1MSwxMjA3ODYsNTIsMTIwNzk2LDUyLDEyMDgwNiw1MiwxMjA4MTYsNTIsMTIwODI2LDUyLDEzMDAzNiw1Miw1MDcwLDUyLDcxODU1LDUyLDEyMDc4Nyw1MywxMjA3OTcsNTMsMTIwODA3LDUzLDEyMDgxNyw1MywxMjA4MjcsNTMsMTMwMDM3LDUzLDQ0NCw1Myw3MTg2Nyw1MywxMjA3ODgsNTQsMTIwNzk4LDU0LDEyMDgwOCw1NCwxMjA4MTgsNTQsMTIwODI4LDU0LDEzMDAzOCw1NCwxMTQ3NCw1NCw1MTAyLDU0LDcxODkzLDU0LDExOTMxNCw1NSwxMjA3ODksNTUsMTIwNzk5LDU1LDEyMDgwOSw1NSwxMjA4MTksNTUsMTIwODI5LDU1LDEzMDAzOSw1NSw2Njc3MCw1NSw3MTg3OCw1NSwyODE5LDU2LDI1MzgsNTYsMjY2Niw1NiwxMjUxMzEsNTYsMTIwNzkwLDU2LDEyMDgwMCw1NiwxMjA4MTAsNTYsMTIwODIwLDU2LDEyMDgzMCw1NiwxMzAwNDAsNTYsNTQ3LDU2LDU0Niw1Niw2NjMzMCw1NiwyNjYzLDU3LDI5MjAsNTcsMjU0MSw1NywzNDM3LDU3LDEyMDc5MSw1NywxMjA4MDEsNTcsMTIwODExLDU3LDEyMDgyMSw1NywxMjA4MzEsNTcsMTMwMDQxLDU3LDQyODYyLDU3LDExNDY2LDU3LDcxODg0LDU3LDcxODUyLDU3LDcxODk0LDU3LDkwODIsOTcsNjUzNDUsOTcsMTE5ODM0LDk3LDExOTg4Niw5NywxMTk5MzgsOTcsMTE5OTkwLDk3LDEyMDA0Miw5NywxMjAwOTQsOTcsMTIwMTQ2LDk3LDEyMDE5OCw5NywxMjAyNTAsOTcsMTIwMzAyLDk3LDEyMDM1NCw5NywxMjA0MDYsOTcsMTIwNDU4LDk3LDU5Myw5Nyw5NDUsOTcsMTIwNTE0LDk3LDEyMDU3Miw5NywxMjA2MzAsOTcsMTIwNjg4LDk3LDEyMDc0Niw5Nyw2NTMxMyw2NSwxMTk4MDgsNjUsMTE5ODYwLDY1LDExOTkxMiw2NSwxMTk5NjQsNjUsMTIwMDE2LDY1LDEyMDA2OCw2NSwxMjAxMjAsNjUsMTIwMTcyLDY1LDEyMDIyNCw2NSwxMjAyNzYsNjUsMTIwMzI4LDY1LDEyMDM4MCw2NSwxMjA0MzIsNjUsOTEzLDY1LDEyMDQ4OCw2NSwxMjA1NDYsNjUsMTIwNjA0LDY1LDEyMDY2Miw2NSwxMjA3MjAsNjUsNTAzNCw2NSw1NTczLDY1LDQyMjIyLDY1LDk0MDE2LDY1LDY2MjA4LDY1LDExOTgzNSw5OCwxMTk4ODcsOTgsMTE5OTM5LDk4LDExOTk5MSw5OCwxMjAwNDMsOTgsMTIwMDk1LDk4LDEyMDE0Nyw5OCwxMjAxOTksOTgsMTIwMjUxLDk4LDEyMDMwMyw5OCwxMjAzNTUsOTgsMTIwNDA3LDk4LDEyMDQ1OSw5OCwzODgsOTgsNTA3MSw5OCw1MjM0LDk4LDU1NTEsOTgsNjUzMTQsNjYsODQ5Miw2NiwxMTk4MDksNjYsMTE5ODYxLDY2LDExOTkxMyw2NiwxMjAwMTcsNjYsMTIwMDY5LDY2LDEyMDEyMSw2NiwxMjAxNzMsNjYsMTIwMjI1LDY2LDEyMDI3Nyw2NiwxMjAzMjksNjYsMTIwMzgxLDY2LDEyMDQzMyw2Niw0MjkzMiw2Niw5MTQsNjYsMTIwNDg5LDY2LDEyMDU0Nyw2NiwxMjA2MDUsNjYsMTIwNjYzLDY2LDEyMDcyMSw2Niw1MTA4LDY2LDU2MjMsNjYsNDIxOTIsNjYsNjYxNzgsNjYsNjYyMDksNjYsNjYzMDUsNjYsNjUzNDcsOTksODU3Myw5OSwxMTk4MzYsOTksMTE5ODg4LDk5LDExOTk0MCw5OSwxMTk5OTIsOTksMTIwMDQ0LDk5LDEyMDA5Niw5OSwxMjAxNDgsOTksMTIwMjAwLDk5LDEyMDI1Miw5OSwxMjAzMDQsOTksMTIwMzU2LDk5LDEyMDQwOCw5OSwxMjA0NjAsOTksNzQyOCw5OSwxMDEwLDk5LDExNDI5LDk5LDQzOTUxLDk5LDY2NjIxLDk5LDEyODg0NCw2Nyw3MTkyMiw2Nyw3MTkxMyw2Nyw2NTMxNSw2Nyw4NTU3LDY3LDg0NTAsNjcsODQ5Myw2NywxMTk4MTAsNjcsMTE5ODYyLDY3LDExOTkxNCw2NywxMTk5NjYsNjcsMTIwMDE4LDY3LDEyMDE3NCw2NywxMjAyMjYsNjcsMTIwMjc4LDY3LDEyMDMzMCw2NywxMjAzODIsNjcsMTIwNDM0LDY3LDEwMTcsNjcsMTE0MjgsNjcsNTA4Nyw2Nyw0MjIwMiw2Nyw2NjIxMCw2Nyw2NjMwNiw2Nyw2NjU4MSw2Nyw2Njg0NCw2Nyw4NTc0LDEwMCw4NTE4LDEwMCwxMTk4MzcsMTAwLDExOTg4OSwxMDAsMTE5OTQxLDEwMCwxMTk5OTMsMTAwLDEyMDA0NSwxMDAsMTIwMDk3LDEwMCwxMjAxNDksMTAwLDEyMDIwMSwxMDAsMTIwMjUzLDEwMCwxMjAzMDUsMTAwLDEyMDM1NywxMDAsMTIwNDA5LDEwMCwxMjA0NjEsMTAwLDEyODEsMTAwLDUwOTUsMTAwLDUyMzEsMTAwLDQyMTk0LDEwMCw4NTU4LDY4LDg1MTcsNjgsMTE5ODExLDY4LDExOTg2Myw2OCwxMTk5MTUsNjgsMTE5OTY3LDY4LDEyMDAxOSw2OCwxMjAwNzEsNjgsMTIwMTIzLDY4LDEyMDE3NSw2OCwxMjAyMjcsNjgsMTIwMjc5LDY4LDEyMDMzMSw2OCwxMjAzODMsNjgsMTIwNDM1LDY4LDUwMjQsNjgsNTU5OCw2OCw1NjEwLDY4LDQyMTk1LDY4LDg0OTQsMTAxLDY1MzQ5LDEwMSw4NDk1LDEwMSw4NTE5LDEwMSwxMTk4MzgsMTAxLDExOTg5MCwxMDEsMTE5OTQyLDEwMSwxMjAwNDYsMTAxLDEyMDA5OCwxMDEsMTIwMTUwLDEwMSwxMjAyMDIsMTAxLDEyMDI1NCwxMDEsMTIwMzA2LDEwMSwxMjAzNTgsMTAxLDEyMDQxMCwxMDEsMTIwNDYyLDEwMSw0MzgyNiwxMDEsMTIxMywxMDEsODk1OSw2OSw2NTMxNyw2OSw4NDk2LDY5LDExOTgxMiw2OSwxMTk4NjQsNjksMTE5OTE2LDY5LDEyMDAyMCw2OSwxMjAwNzIsNjksMTIwMTI0LDY5LDEyMDE3Niw2OSwxMjAyMjgsNjksMTIwMjgwLDY5LDEyMDMzMiw2OSwxMjAzODQsNjksMTIwNDM2LDY5LDkxNyw2OSwxMjA0OTIsNjksMTIwNTUwLDY5LDEyMDYwOCw2OSwxMjA2NjYsNjksMTIwNzI0LDY5LDExNTc3LDY5LDUwMzYsNjksNDIyMjQsNjksNzE4NDYsNjksNzE4NTQsNjksNjYxODIsNjksMTE5ODM5LDEwMiwxMTk4OTEsMTAyLDExOTk0MywxMDIsMTE5OTk1LDEwMiwxMjAwNDcsMTAyLDEyMDA5OSwxMDIsMTIwMTUxLDEwMiwxMjAyMDMsMTAyLDEyMDI1NSwxMDIsMTIwMzA3LDEwMiwxMjAzNTksMTAyLDEyMDQxMSwxMDIsMTIwNDYzLDEwMiw0MzgyOSwxMDIsNDI5MDUsMTAyLDM4MywxMDIsNzgzNywxMDIsMTQxMiwxMDIsMTE5MzE1LDcwLDg0OTcsNzAsMTE5ODEzLDcwLDExOTg2NSw3MCwxMTk5MTcsNzAsMTIwMDIxLDcwLDEyMDA3Myw3MCwxMjAxMjUsNzAsMTIwMTc3LDcwLDEyMDIyOSw3MCwxMjAyODEsNzAsMTIwMzMzLDcwLDEyMDM4NSw3MCwxMjA0MzcsNzAsNDI5MDQsNzAsOTg4LDcwLDEyMDc3OCw3MCw1NTU2LDcwLDQyMjA1LDcwLDcxODc0LDcwLDcxODQyLDcwLDY2MTgzLDcwLDY2MjEzLDcwLDY2ODUzLDcwLDY1MzUxLDEwMyw4NDU4LDEwMywxMTk4NDAsMTAzLDExOTg5MiwxMDMsMTE5OTQ0LDEwMywxMjAwNDgsMTAzLDEyMDEwMCwxMDMsMTIwMTUyLDEwMywxMjAyMDQsMTAzLDEyMDI1NiwxMDMsMTIwMzA4LDEwMywxMjAzNjAsMTAzLDEyMDQxMiwxMDMsMTIwNDY0LDEwMyw2MDksMTAzLDc1NTUsMTAzLDM5NywxMDMsMTQwOSwxMDMsMTE5ODE0LDcxLDExOTg2Niw3MSwxMTk5MTgsNzEsMTE5OTcwLDcxLDEyMDAyMiw3MSwxMjAwNzQsNzEsMTIwMTI2LDcxLDEyMDE3OCw3MSwxMjAyMzAsNzEsMTIwMjgyLDcxLDEyMDMzNCw3MSwxMjAzODYsNzEsMTIwNDM4LDcxLDEyOTIsNzEsNTA1Niw3MSw1MTA3LDcxLDQyMTk4LDcxLDY1MzUyLDEwNCw4NDYyLDEwNCwxMTk4NDEsMTA0LDExOTk0NSwxMDQsMTE5OTk3LDEwNCwxMjAwNDksMTA0LDEyMDEwMSwxMDQsMTIwMTUzLDEwNCwxMjAyMDUsMTA0LDEyMDI1NywxMDQsMTIwMzA5LDEwNCwxMjAzNjEsMTA0LDEyMDQxMywxMDQsMTIwNDY1LDEwNCwxMjExLDEwNCwxMzkyLDEwNCw1MDU4LDEwNCw2NTMyMCw3Miw4NDU5LDcyLDg0NjAsNzIsODQ2MSw3MiwxMTk4MTUsNzIsMTE5ODY3LDcyLDExOTkxOSw3MiwxMjAwMjMsNzIsMTIwMTc5LDcyLDEyMDIzMSw3MiwxMjAyODMsNzIsMTIwMzM1LDcyLDEyMDM4Nyw3MiwxMjA0MzksNzIsOTE5LDcyLDEyMDQ5NCw3MiwxMjA1NTIsNzIsMTIwNjEwLDcyLDEyMDY2OCw3MiwxMjA3MjYsNzIsMTE0MDYsNzIsNTA1MSw3Miw1NTAwLDcyLDQyMjE1LDcyLDY2MjU1LDcyLDczMSwxMDUsOTA3NSwxMDUsNjUzNTMsMTA1LDg1NjAsMTA1LDg1MDUsMTA1LDg1MjAsMTA1LDExOTg0MiwxMDUsMTE5ODk0LDEwNSwxMTk5NDYsMTA1LDExOTk5OCwxMDUsMTIwMDUwLDEwNSwxMjAxMDIsMTA1LDEyMDE1NCwxMDUsMTIwMjA2LDEwNSwxMjAyNTgsMTA1LDEyMDMxMCwxMDUsMTIwMzYyLDEwNSwxMjA0MTQsMTA1LDEyMDQ2NiwxMDUsMTIwNDg0LDEwNSw2MTgsMTA1LDYxNywxMDUsOTUzLDEwNSw4MTI2LDEwNSw4OTAsMTA1LDEyMDUyMiwxMDUsMTIwNTgwLDEwNSwxMjA2MzgsMTA1LDEyMDY5NiwxMDUsMTIwNzU0LDEwNSwxMTEwLDEwNSw0MjU2NywxMDUsMTIzMSwxMDUsNDM4OTMsMTA1LDUwMjksMTA1LDcxODc1LDEwNSw2NTM1NCwxMDYsODUyMSwxMDYsMTE5ODQzLDEwNiwxMTk4OTUsMTA2LDExOTk0NywxMDYsMTE5OTk5LDEwNiwxMjAwNTEsMTA2LDEyMDEwMywxMDYsMTIwMTU1LDEwNiwxMjAyMDcsMTA2LDEyMDI1OSwxMDYsMTIwMzExLDEwNiwxMjAzNjMsMTA2LDEyMDQxNSwxMDYsMTIwNDY3LDEwNiwxMDExLDEwNiwxMTEyLDEwNiw2NTMyMiw3NCwxMTk4MTcsNzQsMTE5ODY5LDc0LDExOTkyMSw3NCwxMTk5NzMsNzQsMTIwMDI1LDc0LDEyMDA3Nyw3NCwxMjAxMjksNzQsMTIwMTgxLDc0LDEyMDIzMyw3NCwxMjAyODUsNzQsMTIwMzM3LDc0LDEyMDM4OSw3NCwxMjA0NDEsNzQsNDI5MzAsNzQsODk1LDc0LDEwMzIsNzQsNTAzNSw3NCw1MjYxLDc0LDQyMjAxLDc0LDExOTg0NCwxMDcsMTE5ODk2LDEwNywxMTk5NDgsMTA3LDEyMDAwMCwxMDcsMTIwMDUyLDEwNywxMjAxMDQsMTA3LDEyMDE1NiwxMDcsMTIwMjA4LDEwNywxMjAyNjAsMTA3LDEyMDMxMiwxMDcsMTIwMzY0LDEwNywxMjA0MTYsMTA3LDEyMDQ2OCwxMDcsODQ5MCw3NSw2NTMyMyw3NSwxMTk4MTgsNzUsMTE5ODcwLDc1LDExOTkyMiw3NSwxMTk5NzQsNzUsMTIwMDI2LDc1LDEyMDA3OCw3NSwxMjAxMzAsNzUsMTIwMTgyLDc1LDEyMDIzNCw3NSwxMjAyODYsNzUsMTIwMzM4LDc1LDEyMDM5MCw3NSwxMjA0NDIsNzUsOTIyLDc1LDEyMDQ5Nyw3NSwxMjA1NTUsNzUsMTIwNjEzLDc1LDEyMDY3MSw3NSwxMjA3MjksNzUsMTE0MTIsNzUsNTA5NCw3NSw1ODQ1LDc1LDQyMTk5LDc1LDY2ODQwLDc1LDE0NzIsMTA4LDg3MzksNzMsOTIxMyw3Myw2NTUxMiw3MywxNjMzLDEwOCwxNzc3LDczLDY2MzM2LDEwOCwxMjUxMjcsMTA4LDEyMDc4Myw3MywxMjA3OTMsNzMsMTIwODAzLDczLDEyMDgxMyw3MywxMjA4MjMsNzMsMTMwMDMzLDczLDY1MzIxLDczLDg1NDQsNzMsODQ2NCw3Myw4NDY1LDczLDExOTgxNiw3MywxMTk4NjgsNzMsMTE5OTIwLDczLDEyMDAyNCw3MywxMjAxMjgsNzMsMTIwMTgwLDczLDEyMDIzMiw3MywxMjAyODQsNzMsMTIwMzM2LDczLDEyMDM4OCw3MywxMjA0NDAsNzMsNjUzNTYsMTA4LDg1NzIsNzMsODQ2NywxMDgsMTE5ODQ1LDEwOCwxMTk4OTcsMTA4LDExOTk0OSwxMDgsMTIwMDAxLDEwOCwxMjAwNTMsMTA4LDEyMDEwNSw3MywxMjAxNTcsNzMsMTIwMjA5LDczLDEyMDI2MSw3MywxMjAzMTMsNzMsMTIwMzY1LDczLDEyMDQxNyw3MywxMjA0NjksNzMsNDQ4LDczLDEyMDQ5Niw3MywxMjA1NTQsNzMsMTIwNjEyLDczLDEyMDY3MCw3MywxMjA3MjgsNzMsMTE0MTAsNzMsMTAzMCw3MywxMjE2LDczLDE0OTMsMTA4LDE1MDMsMTA4LDE1NzUsMTA4LDEyNjQ2NCwxMDgsMTI2NTkyLDEwOCw2NTE2NiwxMDgsNjUxNjUsMTA4LDE5OTQsMTA4LDExNTk5LDczLDU4MjUsNzMsNDIyMjYsNzMsOTM5OTIsNzMsNjYxODYsMTI0LDY2MzEzLDEyNCwxMTkzMzgsNzYsODU1Niw3Niw4NDY2LDc2LDExOTgxOSw3NiwxMTk4NzEsNzYsMTE5OTIzLDc2LDEyMDAyNyw3NiwxMjAwNzksNzYsMTIwMTMxLDc2LDEyMDE4Myw3NiwxMjAyMzUsNzYsMTIwMjg3LDc2LDEyMDMzOSw3NiwxMjAzOTEsNzYsMTIwNDQzLDc2LDExNDcyLDc2LDUwODYsNzYsNTI5MCw3Niw0MjIwOSw3Niw5Mzk3NCw3Niw3MTg0Myw3Niw3MTg1OCw3Niw2NjU4Nyw3Niw2Njg1NCw3Niw2NTMyNSw3Nyw4NTU5LDc3LDg0OTksNzcsMTE5ODIwLDc3LDExOTg3Miw3NywxMTk5MjQsNzcsMTIwMDI4LDc3LDEyMDA4MCw3NywxMjAxMzIsNzcsMTIwMTg0LDc3LDEyMDIzNiw3NywxMjAyODgsNzcsMTIwMzQwLDc3LDEyMDM5Miw3NywxMjA0NDQsNzcsOTI0LDc3LDEyMDQ5OSw3NywxMjA1NTcsNzcsMTIwNjE1LDc3LDEyMDY3Myw3NywxMjA3MzEsNzcsMTAxOCw3NywxMTQxNiw3Nyw1MDQ3LDc3LDU2MTYsNzcsNTg0Niw3Nyw0MjIwNyw3Nyw2NjIyNCw3Nyw2NjMyMSw3NywxMTk4NDcsMTEwLDExOTg5OSwxMTAsMTE5OTUxLDExMCwxMjAwMDMsMTEwLDEyMDA1NSwxMTAsMTIwMTA3LDExMCwxMjAxNTksMTEwLDEyMDIxMSwxMTAsMTIwMjYzLDExMCwxMjAzMTUsMTEwLDEyMDM2NywxMTAsMTIwNDE5LDExMCwxMjA0NzEsMTEwLDE0MDAsMTEwLDE0MDQsMTEwLDY1MzI2LDc4LDg0NjksNzgsMTE5ODIxLDc4LDExOTg3Myw3OCwxMTk5MjUsNzgsMTE5OTc3LDc4LDEyMDAyOSw3OCwxMjAwODEsNzgsMTIwMTg1LDc4LDEyMDIzNyw3OCwxMjAyODksNzgsMTIwMzQxLDc4LDEyMDM5Myw3OCwxMjA0NDUsNzgsOTI1LDc4LDEyMDUwMCw3OCwxMjA1NTgsNzgsMTIwNjE2LDc4LDEyMDY3NCw3OCwxMjA3MzIsNzgsMTE0MTgsNzgsNDIyMDgsNzgsNjY4MzUsNzgsMzA3NCwxMTEsMzIwMiwxMTEsMzMzMCwxMTEsMzQ1OCwxMTEsMjQwNiwxMTEsMjY2MiwxMTEsMjc5MCwxMTEsMzA0NiwxMTEsMzE3NCwxMTEsMzMwMiwxMTEsMzQzMCwxMTEsMzY2NCwxMTEsMzc5MiwxMTEsNDE2MCwxMTEsMTYzNywxMTEsMTc4MSwxMTEsNjUzNTksMTExLDg1MDAsMTExLDExOTg0OCwxMTEsMTE5OTAwLDExMSwxMTk5NTIsMTExLDEyMDA1NiwxMTEsMTIwMTA4LDExMSwxMjAxNjAsMTExLDEyMDIxMiwxMTEsMTIwMjY0LDExMSwxMjAzMTYsMTExLDEyMDM2OCwxMTEsMTIwNDIwLDExMSwxMjA0NzIsMTExLDc0MzksMTExLDc0NDEsMTExLDQzODM3LDExMSw5NTksMTExLDEyMDUyOCwxMTEsMTIwNTg2LDExMSwxMjA2NDQsMTExLDEyMDcwMiwxMTEsMTIwNzYwLDExMSw5NjMsMTExLDEyMDUzMiwxMTEsMTIwNTkwLDExMSwxMjA2NDgsMTExLDEyMDcwNiwxMTEsMTIwNzY0LDExMSwxMTQyMywxMTEsNDM1MSwxMTEsMTQxMywxMTEsMTUwNSwxMTEsMTYwNywxMTEsMTI2NTAwLDExMSwxMjY1NjQsMTExLDEyNjU5NiwxMTEsNjUyNTksMTExLDY1MjYwLDExMSw2NTI1OCwxMTEsNjUyNTcsMTExLDE3MjYsMTExLDY0NDI4LDExMSw2NDQyOSwxMTEsNjQ0MjcsMTExLDY0NDI2LDExMSwxNzI5LDExMSw2NDQyNCwxMTEsNjQ0MjUsMTExLDY0NDIzLDExMSw2NDQyMiwxMTEsMTc0OSwxMTEsMzM2MCwxMTEsNDEyNSwxMTEsNjY3OTQsMTExLDcxODgwLDExMSw3MTg5NSwxMTEsNjY2MDQsMTExLDE5ODQsNzksMjUzNCw3OSwyOTE4LDc5LDEyMjk1LDc5LDcwODY0LDc5LDcxOTA0LDc5LDEyMDc4Miw3OSwxMjA3OTIsNzksMTIwODAyLDc5LDEyMDgxMiw3OSwxMjA4MjIsNzksMTMwMDMyLDc5LDY1MzI3LDc5LDExOTgyMiw3OSwxMTk4NzQsNzksMTE5OTI2LDc5LDExOTk3OCw3OSwxMjAwMzAsNzksMTIwMDgyLDc5LDEyMDEzNCw3OSwxMjAxODYsNzksMTIwMjM4LDc5LDEyMDI5MCw3OSwxMjAzNDIsNzksMTIwMzk0LDc5LDEyMDQ0Niw3OSw5MjcsNzksMTIwNTAyLDc5LDEyMDU2MCw3OSwxMjA2MTgsNzksMTIwNjc2LDc5LDEyMDczNCw3OSwxMTQyMiw3OSwxMzY1LDc5LDExNjA0LDc5LDQ4MTYsNzksMjg0OCw3OSw2Njc1NCw3OSw0MjIyNyw3OSw3MTg2MSw3OSw2NjE5NCw3OSw2NjIxOSw3OSw2NjU2NCw3OSw2NjgzOCw3OSw5MDc2LDExMiw2NTM2MCwxMTIsMTE5ODQ5LDExMiwxMTk5MDEsMTEyLDExOTk1MywxMTIsMTIwMDA1LDExMiwxMjAwNTcsMTEyLDEyMDEwOSwxMTIsMTIwMTYxLDExMiwxMjAyMTMsMTEyLDEyMDI2NSwxMTIsMTIwMzE3LDExMiwxMjAzNjksMTEyLDEyMDQyMSwxMTIsMTIwNDczLDExMiw5NjEsMTEyLDEyMDUzMCwxMTIsMTIwNTQ0LDExMiwxMjA1ODgsMTEyLDEyMDYwMiwxMTIsMTIwNjQ2LDExMiwxMjA2NjAsMTEyLDEyMDcwNCwxMTIsMTIwNzE4LDExMiwxMjA3NjIsMTEyLDEyMDc3NiwxMTIsMTE0MjcsMTEyLDY1MzI4LDgwLDg0NzMsODAsMTE5ODIzLDgwLDExOTg3NSw4MCwxMTk5MjcsODAsMTE5OTc5LDgwLDEyMDAzMSw4MCwxMjAwODMsODAsMTIwMTg3LDgwLDEyMDIzOSw4MCwxMjAyOTEsODAsMTIwMzQzLDgwLDEyMDM5NSw4MCwxMjA0NDcsODAsOTI5LDgwLDEyMDUwNCw4MCwxMjA1NjIsODAsMTIwNjIwLDgwLDEyMDY3OCw4MCwxMjA3MzYsODAsMTE0MjYsODAsNTA5MCw4MCw1MjI5LDgwLDQyMTkzLDgwLDY2MTk3LDgwLDExOTg1MCwxMTMsMTE5OTAyLDExMywxMTk5NTQsMTEzLDEyMDAwNiwxMTMsMTIwMDU4LDExMywxMjAxMTAsMTEzLDEyMDE2MiwxMTMsMTIwMjE0LDExMywxMjAyNjYsMTEzLDEyMDMxOCwxMTMsMTIwMzcwLDExMywxMjA0MjIsMTEzLDEyMDQ3NCwxMTMsMTMwNywxMTMsMTM3OSwxMTMsMTM4MiwxMTMsODQ3NCw4MSwxMTk4MjQsODEsMTE5ODc2LDgxLDExOTkyOCw4MSwxMTk5ODAsODEsMTIwMDMyLDgxLDEyMDA4NCw4MSwxMjAxODgsODEsMTIwMjQwLDgxLDEyMDI5Miw4MSwxMjAzNDQsODEsMTIwMzk2LDgxLDEyMDQ0OCw4MSwxMTYwNSw4MSwxMTk4NTEsMTE0LDExOTkwMywxMTQsMTE5OTU1LDExNCwxMjAwMDcsMTE0LDEyMDA1OSwxMTQsMTIwMTExLDExNCwxMjAxNjMsMTE0LDEyMDIxNSwxMTQsMTIwMjY3LDExNCwxMjAzMTksMTE0LDEyMDM3MSwxMTQsMTIwNDIzLDExNCwxMjA0NzUsMTE0LDQzODQ3LDExNCw0Mzg0OCwxMTQsNzQ2MiwxMTQsMTEzOTcsMTE0LDQzOTA1LDExNCwxMTkzMTgsODIsODQ3NSw4Miw4NDc2LDgyLDg0NzcsODIsMTE5ODI1LDgyLDExOTg3Nyw4MiwxMTk5MjksODIsMTIwMDMzLDgyLDEyMDE4OSw4MiwxMjAyNDEsODIsMTIwMjkzLDgyLDEyMDM0NSw4MiwxMjAzOTcsODIsMTIwNDQ5LDgyLDQyMiw4Miw1MDI1LDgyLDUwNzQsODIsNjY3NDAsODIsNTUxMSw4Miw0MjIxMSw4Miw5NDAwNSw4Miw2NTM2MywxMTUsMTE5ODUyLDExNSwxMTk5MDQsMTE1LDExOTk1NiwxMTUsMTIwMDA4LDExNSwxMjAwNjAsMTE1LDEyMDExMiwxMTUsMTIwMTY0LDExNSwxMjAyMTYsMTE1LDEyMDI2OCwxMTUsMTIwMzIwLDExNSwxMjAzNzIsMTE1LDEyMDQyNCwxMTUsMTIwNDc2LDExNSw0MjgwMSwxMTUsNDQ1LDExNSwxMTA5LDExNSw0Mzk0NiwxMTUsNzE4NzMsMTE1LDY2NjMyLDExNSw2NTMzMSw4MywxMTk4MjYsODMsMTE5ODc4LDgzLDExOTkzMCw4MywxMTk5ODIsODMsMTIwMDM0LDgzLDEyMDA4Niw4MywxMjAxMzgsODMsMTIwMTkwLDgzLDEyMDI0Miw4MywxMjAyOTQsODMsMTIwMzQ2LDgzLDEyMDM5OCw4MywxMjA0NTAsODMsMTAyOSw4MywxMzU5LDgzLDUwNzcsODMsNTA4Miw4Myw0MjIxMCw4Myw5NDAxMCw4Myw2NjE5OCw4Myw2NjU5Miw4MywxMTk4NTMsMTE2LDExOTkwNSwxMTYsMTE5OTU3LDExNiwxMjAwMDksMTE2LDEyMDA2MSwxMTYsMTIwMTEzLDExNiwxMjAxNjUsMTE2LDEyMDIxNywxMTYsMTIwMjY5LDExNiwxMjAzMjEsMTE2LDEyMDM3MywxMTYsMTIwNDI1LDExNiwxMjA0NzcsMTE2LDg4NjgsODQsMTAyMDEsODQsMTI4ODcyLDg0LDY1MzMyLDg0LDExOTgyNyw4NCwxMTk4NzksODQsMTE5OTMxLDg0LDExOTk4Myw4NCwxMjAwMzUsODQsMTIwMDg3LDg0LDEyMDEzOSw4NCwxMjAxOTEsODQsMTIwMjQzLDg0LDEyMDI5NSw4NCwxMjAzNDcsODQsMTIwMzk5LDg0LDEyMDQ1MSw4NCw5MzIsODQsMTIwNTA3LDg0LDEyMDU2NSw4NCwxMjA2MjMsODQsMTIwNjgxLDg0LDEyMDczOSw4NCwxMTQzMCw4NCw1MDI2LDg0LDQyMTk2LDg0LDkzOTYyLDg0LDcxODY4LDg0LDY2MTk5LDg0LDY2MjI1LDg0LDY2MzI1LDg0LDExOTg1NCwxMTcsMTE5OTA2LDExNywxMTk5NTgsMTE3LDEyMDAxMCwxMTcsMTIwMDYyLDExNywxMjAxMTQsMTE3LDEyMDE2NiwxMTcsMTIwMjE4LDExNywxMjAyNzAsMTE3LDEyMDMyMiwxMTcsMTIwMzc0LDExNywxMjA0MjYsMTE3LDEyMDQ3OCwxMTcsNDI5MTEsMTE3LDc0NTIsMTE3LDQzODU0LDExNyw0Mzg1OCwxMTcsNjUxLDExNyw5NjUsMTE3LDEyMDUzNCwxMTcsMTIwNTkyLDExNywxMjA2NTAsMTE3LDEyMDcwOCwxMTcsMTIwNzY2LDExNywxNDA1LDExNyw2NjgwNiwxMTcsNzE4OTYsMTE3LDg3NDYsODUsODg5OSw4NSwxMTk4MjgsODUsMTE5ODgwLDg1LDExOTkzMiw4NSwxMTk5ODQsODUsMTIwMDM2LDg1LDEyMDA4OCw4NSwxMjAxNDAsODUsMTIwMTkyLDg1LDEyMDI0NCw4NSwxMjAyOTYsODUsMTIwMzQ4LDg1LDEyMDQwMCw4NSwxMjA0NTIsODUsMTM1Nyw4NSw0NjA4LDg1LDY2NzY2LDg1LDUxOTYsODUsNDIyMjgsODUsOTQwMTgsODUsNzE4NjQsODUsODc0NCwxMTgsODg5NywxMTgsNjUzNjYsMTE4LDg1NjQsMTE4LDExOTg1NSwxMTgsMTE5OTA3LDExOCwxMTk5NTksMTE4LDEyMDAxMSwxMTgsMTIwMDYzLDExOCwxMjAxMTUsMTE4LDEyMDE2NywxMTgsMTIwMjE5LDExOCwxMjAyNzEsMTE4LDEyMDMyMywxMTgsMTIwMzc1LDExOCwxMjA0MjcsMTE4LDEyMDQ3OSwxMTgsNzQ1NiwxMTgsOTU3LDExOCwxMjA1MjYsMTE4LDEyMDU4NCwxMTgsMTIwNjQyLDExOCwxMjA3MDAsMTE4LDEyMDc1OCwxMTgsMTE0MSwxMTgsMTQ5NiwxMTgsNzE0MzAsMTE4LDQzOTQ1LDExOCw3MTg3MiwxMTgsMTE5MzA5LDg2LDE2MzksODYsMTc4Myw4Niw4NTQ4LDg2LDExOTgyOSw4NiwxMTk4ODEsODYsMTE5OTMzLDg2LDExOTk4NSw4NiwxMjAwMzcsODYsMTIwMDg5LDg2LDEyMDE0MSw4NiwxMjAxOTMsODYsMTIwMjQ1LDg2LDEyMDI5Nyw4NiwxMjAzNDksODYsMTIwNDAxLDg2LDEyMDQ1Myw4NiwxMTQwLDg2LDExNTc2LDg2LDUwODEsODYsNTE2Nyw4Niw0MjcxOSw4Niw0MjIxNCw4Niw5Mzk2MCw4Niw3MTg0MCw4Niw2Njg0NSw4Niw2MjMsMTE5LDExOTg1NiwxMTksMTE5OTA4LDExOSwxMTk5NjAsMTE5LDEyMDAxMiwxMTksMTIwMDY0LDExOSwxMjAxMTYsMTE5LDEyMDE2OCwxMTksMTIwMjIwLDExOSwxMjAyNzIsMTE5LDEyMDMyNCwxMTksMTIwMzc2LDExOSwxMjA0MjgsMTE5LDEyMDQ4MCwxMTksNzQ1NywxMTksMTEyMSwxMTksMTMwOSwxMTksMTM3NywxMTksNzE0MzQsMTE5LDcxNDM4LDExOSw3MTQzOSwxMTksNDM5MDcsMTE5LDcxOTE5LDg3LDcxOTEwLDg3LDExOTgzMCw4NywxMTk4ODIsODcsMTE5OTM0LDg3LDExOTk4Niw4NywxMjAwMzgsODcsMTIwMDkwLDg3LDEyMDE0Miw4NywxMjAxOTQsODcsMTIwMjQ2LDg3LDEyMDI5OCw4NywxMjAzNTAsODcsMTIwNDAyLDg3LDEyMDQ1NCw4NywxMzA4LDg3LDUwNDMsODcsNTA3Niw4Nyw0MjIxOCw4Nyw1NzQyLDEyMCwxMDUzOSwxMjAsMTA1NDAsMTIwLDEwNzk5LDEyMCw2NTM2OCwxMjAsODU2OSwxMjAsMTE5ODU3LDEyMCwxMTk5MDksMTIwLDExOTk2MSwxMjAsMTIwMDEzLDEyMCwxMjAwNjUsMTIwLDEyMDExNywxMjAsMTIwMTY5LDEyMCwxMjAyMjEsMTIwLDEyMDI3MywxMjAsMTIwMzI1LDEyMCwxMjAzNzcsMTIwLDEyMDQyOSwxMjAsMTIwNDgxLDEyMCw1NDQxLDEyMCw1NTAxLDEyMCw1NzQxLDg4LDk1ODcsODgsNjYzMzgsODgsNzE5MTYsODgsNjUzMzYsODgsODU1Myw4OCwxMTk4MzEsODgsMTE5ODgzLDg4LDExOTkzNSw4OCwxMTk5ODcsODgsMTIwMDM5LDg4LDEyMDA5MSw4OCwxMjAxNDMsODgsMTIwMTk1LDg4LDEyMDI0Nyw4OCwxMjAyOTksODgsMTIwMzUxLDg4LDEyMDQwMyw4OCwxMjA0NTUsODgsNDI5MzEsODgsOTM1LDg4LDEyMDUxMCw4OCwxMjA1NjgsODgsMTIwNjI2LDg4LDEyMDY4NCw4OCwxMjA3NDIsODgsMTE0MzYsODgsMTE2MTMsODgsNTgxNSw4OCw0MjIxOSw4OCw2NjE5Miw4OCw2NjIyOCw4OCw2NjMyNyw4OCw2Njg1NSw4OCw2MTEsMTIxLDc1NjQsMTIxLDY1MzY5LDEyMSwxMTk4NTgsMTIxLDExOTkxMCwxMjEsMTE5OTYyLDEyMSwxMjAwMTQsMTIxLDEyMDA2NiwxMjEsMTIwMTE4LDEyMSwxMjAxNzAsMTIxLDEyMDIyMiwxMjEsMTIwMjc0LDEyMSwxMjAzMjYsMTIxLDEyMDM3OCwxMjEsMTIwNDMwLDEyMSwxMjA0ODIsMTIxLDY1NSwxMjEsNzkzNSwxMjEsNDM4NjYsMTIxLDk0NywxMjEsODUwOSwxMjEsMTIwNTE2LDEyMSwxMjA1NzQsMTIxLDEyMDYzMiwxMjEsMTIwNjkwLDEyMSwxMjA3NDgsMTIxLDExOTksMTIxLDQzMjcsMTIxLDcxOTAwLDEyMSw2NTMzNyw4OSwxMTk4MzIsODksMTE5ODg0LDg5LDExOTkzNiw4OSwxMTk5ODgsODksMTIwMDQwLDg5LDEyMDA5Miw4OSwxMjAxNDQsODksMTIwMTk2LDg5LDEyMDI0OCw4OSwxMjAzMDAsODksMTIwMzUyLDg5LDEyMDQwNCw4OSwxMjA0NTYsODksOTMzLDg5LDk3OCw4OSwxMjA1MDgsODksMTIwNTY2LDg5LDEyMDYyNCw4OSwxMjA2ODIsODksMTIwNzQwLDg5LDExNDMyLDg5LDExOTgsODksNTAzMyw4OSw1MDUzLDg5LDQyMjIwLDg5LDk0MDE5LDg5LDcxODQ0LDg5LDY2MjI2LDg5LDExOTg1OSwxMjIsMTE5OTExLDEyMiwxMTk5NjMsMTIyLDEyMDAxNSwxMjIsMTIwMDY3LDEyMiwxMjAxMTksMTIyLDEyMDE3MSwxMjIsMTIwMjIzLDEyMiwxMjAyNzUsMTIyLDEyMDMyNywxMjIsMTIwMzc5LDEyMiwxMjA0MzEsMTIyLDEyMDQ4MywxMjIsNzQ1OCwxMjIsNDM5MjMsMTIyLDcxODc2LDEyMiw2NjI5Myw5MCw3MTkwOSw5MCw2NTMzOCw5MCw4NDg0LDkwLDg0ODgsOTAsMTE5ODMzLDkwLDExOTg4NSw5MCwxMTk5MzcsOTAsMTE5OTg5LDkwLDEyMDA0MSw5MCwxMjAxOTcsOTAsMTIwMjQ5LDkwLDEyMDMwMSw5MCwxMjAzNTMsOTAsMTIwNDA1LDkwLDEyMDQ1Nyw5MCw5MTgsOTAsMTIwNDkzLDkwLDEyMDU1MSw5MCwxMjA2MDksOTAsMTIwNjY3LDkwLDEyMDcyNSw5MCw1MDU5LDkwLDQyMjA0LDkwLDcxODQ5LDkwLDY1MjgyLDM0LDY1Mjg0LDM2LDY1Mjg1LDM3LDY1Mjg2LDM4LDY1MjkwLDQyLDY1MjkxLDQzLDY1Mjk0LDQ2LDY1Mjk1LDQ3LDY1Mjk2LDQ4LDY1Mjk3LDQ5LDY1Mjk4LDUwLDY1Mjk5LDUxLDY1MzAwLDUyLDY1MzAxLDUzLDY1MzAyLDU0LDY1MzAzLDU1LDY1MzA0LDU2LDY1MzA1LDU3LDY1MzA4LDYwLDY1MzA5LDYxLDY1MzEwLDYyLDY1MzEyLDY0LDY1MzE2LDY4LDY1MzE4LDcwLDY1MzE5LDcxLDY1MzI0LDc2LDY1MzI5LDgxLDY1MzMwLDgyLDY1MzMzLDg1LDY1MzM0LDg2LDY1MzM1LDg3LDY1MzQzLDk1LDY1MzQ2LDk4LDY1MzQ4LDEwMCw2NTM1MCwxMDIsNjUzNTUsMTA3LDY1MzU3LDEwOSw2NTM1OCwxMTAsNjUzNjEsMTEzLDY1MzYyLDExNCw2NTM2NCwxMTYsNjUzNjUsMTE3LDY1MzY3LDExOSw2NTM3MCwxMjIsNjUzNzEsMTIzLDY1MzczLDEyNV0sXFxcIl9kZWZhdWx0XFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImNzXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJkZVxcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiZXNcXFwiOls4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSwxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiZnJcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjQ1LDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiaXRcXFwiOlsxNjAsMzIsODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImphXFxcIjpbODIxMSw0NSw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyOTIsNDQsNjUzMDcsNTldLFxcXCJrb1xcXCI6WzgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwicGxcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwicHQtQlJcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwicXBzLXBsb2NcXFwiOlsxNjAsMzIsODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwicnVcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDMwNSwxMDUsOTIxLDczLDEwMDksMTEyLDIxNSwxMjAsNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJ0clxcXCI6WzE2MCwzMiw4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJ6aC1oYW5zXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1Mjg4LDQwLDY1Mjg5LDQxXSxcXFwiemgtaGFudFxcXCI6WzgyMTEsNDUsNjUzNzQsMTI2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTMwNyw1OV19Jyk7XG59KTtcbkFtYmlndW91c0NoYXJhY3RlcnMuY2FjaGUgPSBuZXcgTFJVQ2FjaGVkQ29tcHV0ZWQoKGxvY2FsZXMpID0+IHtcbiAgICBmdW5jdGlvbiBhcnJheVRvTWFwKGFycikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGFycltpXSwgYXJyW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VNYXBzKG1hcDEsIG1hcDIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcChtYXAxKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwMikge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RNYXBzKG1hcDEsIG1hcDIpIHtcbiAgICAgICAgaWYgKCFtYXAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcDEpIHtcbiAgICAgICAgICAgIGlmIChtYXAyLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gX2EuYW1iaWd1b3VzQ2hhcmFjdGVyRGF0YS5nZXRWYWx1ZSgpO1xuICAgIGxldCBmaWx0ZXJlZExvY2FsZXMgPSBsb2NhbGVzLmZpbHRlcigobCkgPT4gIWwuc3RhcnRzV2l0aCgnXycpICYmIGwgaW4gZGF0YSk7XG4gICAgaWYgKGZpbHRlcmVkTG9jYWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZmlsdGVyZWRMb2NhbGVzID0gWydfZGVmYXVsdCddO1xuICAgIH1cbiAgICBsZXQgbGFuZ3VhZ2VTcGVjaWZpY01hcCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGxvY2FsZSBvZiBmaWx0ZXJlZExvY2FsZXMpIHtcbiAgICAgICAgY29uc3QgbWFwID0gYXJyYXlUb01hcChkYXRhW2xvY2FsZV0pO1xuICAgICAgICBsYW5ndWFnZVNwZWNpZmljTWFwID0gaW50ZXJzZWN0TWFwcyhsYW5ndWFnZVNwZWNpZmljTWFwLCBtYXApO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25NYXAgPSBhcnJheVRvTWFwKGRhdGFbJ19jb21tb24nXSk7XG4gICAgY29uc3QgbWFwID0gbWVyZ2VNYXBzKGNvbW1vbk1hcCwgbGFuZ3VhZ2VTcGVjaWZpY01hcCk7XG4gICAgcmV0dXJuIG5ldyBBbWJpZ3VvdXNDaGFyYWN0ZXJzKG1hcCk7XG59KTtcbkFtYmlndW91c0NoYXJhY3RlcnMuX2xvY2FsZXMgPSBuZXcgTGF6eSgoKSA9PiBPYmplY3Qua2V5cyhBbWJpZ3VvdXNDaGFyYWN0ZXJzLmFtYmlndW91c0NoYXJhY3RlckRhdGEuZ2V0VmFsdWUoKSkuZmlsdGVyKChrKSA9PiAhay5zdGFydHNXaXRoKCdfJykpKTtcbmV4cG9ydCBjbGFzcyBJbnZpc2libGVDaGFyYWN0ZXJzIHtcbiAgICBzdGF0aWMgZ2V0UmF3RGF0YSgpIHtcbiAgICAgICAgLy8gR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9oZWRpZXQvdnNjb2RlLXVuaWNvZGUtZGF0YVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSgnWzksMTAsMTEsMTIsMTMsMzIsMTI3LDE2MCwxNzMsODQ3LDE1NjQsNDQ0Nyw0NDQ4LDYwNjgsNjA2OSw2MTU1LDYxNTYsNjE1Nyw2MTU4LDczNTUsNzM1Niw4MTkyLDgxOTMsODE5NCw4MTk1LDgxOTYsODE5Nyw4MTk4LDgxOTksODIwMCw4MjAxLDgyMDIsODIwMyw4MjA0LDgyMDUsODIwNiw4MjA3LDgyMzQsODIzNSw4MjM2LDgyMzcsODIzOCw4MjM5LDgyODcsODI4OCw4Mjg5LDgyOTAsODI5MSw4MjkyLDgyOTMsODI5NCw4Mjk1LDgyOTYsODI5Nyw4Mjk4LDgyOTksODMwMCw4MzAxLDgzMDIsODMwMywxMDI0MCwxMjI4OCwxMjY0NCw2NTAyNCw2NTAyNSw2NTAyNiw2NTAyNyw2NTAyOCw2NTAyOSw2NTAzMCw2NTAzMSw2NTAzMiw2NTAzMyw2NTAzNCw2NTAzNSw2NTAzNiw2NTAzNyw2NTAzOCw2NTAzOSw2NTI3OSw2NTQ0MCw2NTUyMCw2NTUyMSw2NTUyMiw2NTUyMyw2NTUyNCw2NTUyNSw2NTUyNiw2NTUyNyw2NTUyOCw2NTUzMiw3ODg0NCwxMTkxNTUsMTE5MTU2LDExOTE1NywxMTkxNTgsMTE5MTU5LDExOTE2MCwxMTkxNjEsMTE5MTYyLDkxNzUwNCw5MTc1MDUsOTE3NTA2LDkxNzUwNyw5MTc1MDgsOTE3NTA5LDkxNzUxMCw5MTc1MTEsOTE3NTEyLDkxNzUxMyw5MTc1MTQsOTE3NTE1LDkxNzUxNiw5MTc1MTcsOTE3NTE4LDkxNzUxOSw5MTc1MjAsOTE3NTIxLDkxNzUyMiw5MTc1MjMsOTE3NTI0LDkxNzUyNSw5MTc1MjYsOTE3NTI3LDkxNzUyOCw5MTc1MjksOTE3NTMwLDkxNzUzMSw5MTc1MzIsOTE3NTMzLDkxNzUzNCw5MTc1MzUsOTE3NTM2LDkxNzUzNyw5MTc1MzgsOTE3NTM5LDkxNzU0MCw5MTc1NDEsOTE3NTQyLDkxNzU0Myw5MTc1NDQsOTE3NTQ1LDkxNzU0Niw5MTc1NDcsOTE3NTQ4LDkxNzU0OSw5MTc1NTAsOTE3NTUxLDkxNzU1Miw5MTc1NTMsOTE3NTU0LDkxNzU1NSw5MTc1NTYsOTE3NTU3LDkxNzU1OCw5MTc1NTksOTE3NTYwLDkxNzU2MSw5MTc1NjIsOTE3NTYzLDkxNzU2NCw5MTc1NjUsOTE3NTY2LDkxNzU2Nyw5MTc1NjgsOTE3NTY5LDkxNzU3MCw5MTc1NzEsOTE3NTcyLDkxNzU3Myw5MTc1NzQsOTE3NTc1LDkxNzU3Niw5MTc1NzcsOTE3NTc4LDkxNzU3OSw5MTc1ODAsOTE3NTgxLDkxNzU4Miw5MTc1ODMsOTE3NTg0LDkxNzU4NSw5MTc1ODYsOTE3NTg3LDkxNzU4OCw5MTc1ODksOTE3NTkwLDkxNzU5MSw5MTc1OTIsOTE3NTkzLDkxNzU5NCw5MTc1OTUsOTE3NTk2LDkxNzU5Nyw5MTc1OTgsOTE3NTk5LDkxNzYwMCw5MTc2MDEsOTE3NjAyLDkxNzYwMyw5MTc2MDQsOTE3NjA1LDkxNzYwNiw5MTc2MDcsOTE3NjA4LDkxNzYwOSw5MTc2MTAsOTE3NjExLDkxNzYxMiw5MTc2MTMsOTE3NjE0LDkxNzYxNSw5MTc2MTYsOTE3NjE3LDkxNzYxOCw5MTc2MTksOTE3NjIwLDkxNzYyMSw5MTc2MjIsOTE3NjIzLDkxNzYyNCw5MTc2MjUsOTE3NjI2LDkxNzYyNyw5MTc2MjgsOTE3NjI5LDkxNzYzMCw5MTc2MzEsOTE3NzYwLDkxNzc2MSw5MTc3NjIsOTE3NzYzLDkxNzc2NCw5MTc3NjUsOTE3NzY2LDkxNzc2Nyw5MTc3NjgsOTE3NzY5LDkxNzc3MCw5MTc3NzEsOTE3NzcyLDkxNzc3Myw5MTc3NzQsOTE3Nzc1LDkxNzc3Niw5MTc3NzcsOTE3Nzc4LDkxNzc3OSw5MTc3ODAsOTE3NzgxLDkxNzc4Miw5MTc3ODMsOTE3Nzg0LDkxNzc4NSw5MTc3ODYsOTE3Nzg3LDkxNzc4OCw5MTc3ODksOTE3NzkwLDkxNzc5MSw5MTc3OTIsOTE3NzkzLDkxNzc5NCw5MTc3OTUsOTE3Nzk2LDkxNzc5Nyw5MTc3OTgsOTE3Nzk5LDkxNzgwMCw5MTc4MDEsOTE3ODAyLDkxNzgwMyw5MTc4MDQsOTE3ODA1LDkxNzgwNiw5MTc4MDcsOTE3ODA4LDkxNzgwOSw5MTc4MTAsOTE3ODExLDkxNzgxMiw5MTc4MTMsOTE3ODE0LDkxNzgxNSw5MTc4MTYsOTE3ODE3LDkxNzgxOCw5MTc4MTksOTE3ODIwLDkxNzgyMSw5MTc4MjIsOTE3ODIzLDkxNzgyNCw5MTc4MjUsOTE3ODI2LDkxNzgyNyw5MTc4MjgsOTE3ODI5LDkxNzgzMCw5MTc4MzEsOTE3ODMyLDkxNzgzMyw5MTc4MzQsOTE3ODM1LDkxNzgzNiw5MTc4MzcsOTE3ODM4LDkxNzgzOSw5MTc4NDAsOTE3ODQxLDkxNzg0Miw5MTc4NDMsOTE3ODQ0LDkxNzg0NSw5MTc4NDYsOTE3ODQ3LDkxNzg0OCw5MTc4NDksOTE3ODUwLDkxNzg1MSw5MTc4NTIsOTE3ODUzLDkxNzg1NCw5MTc4NTUsOTE3ODU2LDkxNzg1Nyw5MTc4NTgsOTE3ODU5LDkxNzg2MCw5MTc4NjEsOTE3ODYyLDkxNzg2Myw5MTc4NjQsOTE3ODY1LDkxNzg2Niw5MTc4NjcsOTE3ODY4LDkxNzg2OSw5MTc4NzAsOTE3ODcxLDkxNzg3Miw5MTc4NzMsOTE3ODc0LDkxNzg3NSw5MTc4NzYsOTE3ODc3LDkxNzg3OCw5MTc4NzksOTE3ODgwLDkxNzg4MSw5MTc4ODIsOTE3ODgzLDkxNzg4NCw5MTc4ODUsOTE3ODg2LDkxNzg4Nyw5MTc4ODgsOTE3ODg5LDkxNzg5MCw5MTc4OTEsOTE3ODkyLDkxNzg5Myw5MTc4OTQsOTE3ODk1LDkxNzg5Niw5MTc4OTcsOTE3ODk4LDkxNzg5OSw5MTc5MDAsOTE3OTAxLDkxNzkwMiw5MTc5MDMsOTE3OTA0LDkxNzkwNSw5MTc5MDYsOTE3OTA3LDkxNzkwOCw5MTc5MDksOTE3OTEwLDkxNzkxMSw5MTc5MTIsOTE3OTEzLDkxNzkxNCw5MTc5MTUsOTE3OTE2LDkxNzkxNyw5MTc5MTgsOTE3OTE5LDkxNzkyMCw5MTc5MjEsOTE3OTIyLDkxNzkyMyw5MTc5MjQsOTE3OTI1LDkxNzkyNiw5MTc5MjcsOTE3OTI4LDkxNzkyOSw5MTc5MzAsOTE3OTMxLDkxNzkzMiw5MTc5MzMsOTE3OTM0LDkxNzkzNSw5MTc5MzYsOTE3OTM3LDkxNzkzOCw5MTc5MzksOTE3OTQwLDkxNzk0MSw5MTc5NDIsOTE3OTQzLDkxNzk0NCw5MTc5NDUsOTE3OTQ2LDkxNzk0Nyw5MTc5NDgsOTE3OTQ5LDkxNzk1MCw5MTc5NTEsOTE3OTUyLDkxNzk1Myw5MTc5NTQsOTE3OTU1LDkxNzk1Niw5MTc5NTcsOTE3OTU4LDkxNzk1OSw5MTc5NjAsOTE3OTYxLDkxNzk2Miw5MTc5NjMsOTE3OTY0LDkxNzk2NSw5MTc5NjYsOTE3OTY3LDkxNzk2OCw5MTc5NjksOTE3OTcwLDkxNzk3MSw5MTc5NzIsOTE3OTczLDkxNzk3NCw5MTc5NzUsOTE3OTc2LDkxNzk3Nyw5MTc5NzgsOTE3OTc5LDkxNzk4MCw5MTc5ODEsOTE3OTgyLDkxNzk4Myw5MTc5ODQsOTE3OTg1LDkxNzk4Niw5MTc5ODcsOTE3OTg4LDkxNzk4OSw5MTc5OTAsOTE3OTkxLDkxNzk5Miw5MTc5OTMsOTE3OTk0LDkxNzk5NSw5MTc5OTYsOTE3OTk3LDkxNzk5OCw5MTc5OTldJyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREYXRhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgU2V0KEludmlzaWJsZUNoYXJhY3RlcnMuZ2V0UmF3RGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGlzSW52aXNpYmxlQ2hhcmFjdGVyKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gSW52aXNpYmxlQ2hhcmFjdGVycy5nZXREYXRhKCkuaGFzKGNvZGVQb2ludCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29kZVBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIEludmlzaWJsZUNoYXJhY3RlcnMuZ2V0RGF0YSgpO1xuICAgIH1cbn1cbkludmlzaWJsZUNoYXJhY3RlcnMuX2RhdGEgPSB1bmRlZmluZWQ7XG4iLCIvKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgQXJyYXkgb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBTdHJpbmcgb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSBgb2JqZWN0YCBidXQgKipub3QqKlxuICpcdGBudWxsYCwgYW4gYGFycmF5YCwgYSBgcmVnZXhwYCwgbm9yIGEgYGRhdGVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgLy8gVGhlIG1ldGhvZCBjYW4ndCBkbyBhIHR5cGUgY2FzdCBzaW5jZSB0aGVyZSBhcmUgdHlwZSAobGlrZSBzdHJpbmdzKSB3aGljaFxuICAgIC8vIGFyZSBzdWJjbGFzc2VzIG9mIGFueSBwdXQgbm90IHBvc2l0dmVseSBtYXRjaGVkIGJ5IHRoZSBmdW5jdGlvbi4gSGVuY2UgdHlwZVxuICAgIC8vIG5hcnJvd2luZyByZXN1bHRzIGluIHdyb25nIHJlc3VsdHMuXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gICAgICAgICYmIG9iaiAhPT0gbnVsbFxuICAgICAgICAmJiAhQXJyYXkuaXNBcnJheShvYmopXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAmJiAhKG9iaiBpbnN0YW5jZW9mIERhdGUpO1xufVxuLyoqXG4gKiBJbiAqKmNvbnRyYXN0KiogdG8ganVzdCBjaGVja2luZyBgdHlwZW9mYCB0aGlzIHdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yIGBOYU5gLlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBOdW1iZXIgb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ob2JqKSk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhbiBJdGVyYWJsZSwgY2FzdGluZyB0byB0aGUgZ2l2ZW4gZ2VuZXJpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IEJvb2xlYW4gb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiAob2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBkZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKGFyZykge1xuICAgIHJldHVybiAhaXNVbmRlZmluZWRPck51bGwoYXJnKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwob2JqKSB7XG4gICAgcmV0dXJuIChpc1VuZGVmaW5lZChvYmopIHx8IG9iaiA9PT0gbnVsbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZShjb25kaXRpb24sIHR5cGUpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSA/IGBVbmV4cGVjdGVkIHR5cGUsIGV4cGVjdGVkICcke3R5cGV9J2AgOiAnVW5leHBlY3RlZCB0eXBlJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGFyZ3VtZW50IHBhc3NlZCBpbiBpcyBuZWl0aGVyIHVuZGVmaW5lZCBub3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzRGVmaW5lZChhcmcpIHtcbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwoYXJnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBGYWlsZWQ6IGFyZ3VtZW50IGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgRnVuY3Rpb24gb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RyYWludHMoYXJncywgY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhcmdzLmxlbmd0aCwgY29uc3RyYWludHMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29uc3RyYWludChhcmdzW2ldLCBjb25zdHJhaW50c1tpXSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RyYWludChhcmcsIGNvbnN0cmFpbnQpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgIT09IGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggY29uc3RyYWludDogdHlwZW9mICR7Y29uc3RyYWludH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWRPck51bGwoYXJnKSAmJiBhcmcuY29uc3RydWN0b3IgPT09IGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RyYWludC5sZW5ndGggPT09IDEgJiYgY29uc3RyYWludC5jYWxsKHVuZGVmaW5lZCwgYXJnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggb25lIG9mIHRoZXNlIGNvbnN0cmFpbnRzOiBhcmcgaW5zdGFuY2VvZiBjb25zdHJhaW50LCBhcmcuY29uc3RydWN0b3IgPT09IGNvbnN0cmFpbnQsIG5vciBjb25zdHJhaW50KGFyZykgPT09IHRydWVgKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgd2hpbGUgKE9iamVjdC5wcm90b3R5cGUgIT09IHByb3RvKSB7XG4gICAgICAgIHJlcyA9IHJlcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pKTtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1ldGhvZE5hbWVzKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgZ2V0QWxsUHJvcGVydHlOYW1lcyhvYmopKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtZXRob2RzLnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZHM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJveHlPYmplY3QobWV0aG9kTmFtZXMsIGludm9rZSkge1xuICAgIGNvbnN0IGNyZWF0ZVByb3h5TWV0aG9kID0gKG1ldGhvZCkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IGNyZWF0ZVByb3h5TWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBudWxsIHRvIHVuZGVmaW5lZCwgcGFzc2VzIGFsbCBvdGhlciB2YWx1ZXMgdGhyb3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhOdWxsQXNVbmRlZmluZWQoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gdW5kZWZpbmVkIDogeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbWVzc2FnZSA9ICdVbnJlYWNoYWJsZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1VpbnQ4KHYpIHtcbiAgICBpZiAodiA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh2ID4gMjU1IC8qIE1BWF9VSU5UXzggKi8pIHtcbiAgICAgICAgcmV0dXJuIDI1NSAvKiBNQVhfVUlOVF84ICovO1xuICAgIH1cbiAgICByZXR1cm4gdiB8IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VaW50MzIodikge1xuICAgIGlmICh2IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHYgPiA0Mjk0OTY3Mjk1IC8qIE1BWF9VSU5UXzMyICovKSB7XG4gICAgICAgIHJldHVybiA0Mjk0OTY3Mjk1IC8qIE1BWF9VSU5UXzMyICovO1xuICAgIH1cbiAgICByZXR1cm4gdiB8IDA7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHBhdGhzIGZyb20gJy4vcGF0aC5qcyc7XG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmNvbnN0IF9zY2hlbWVQYXR0ZXJuID0gL15cXHdbXFx3XFxkKy4tXSokLztcbmNvbnN0IF9zaW5nbGVTbGFzaFN0YXJ0ID0gL15cXC8vO1xuY29uc3QgX2RvdWJsZVNsYXNoU3RhcnQgPSAvXlxcL1xcLy87XG5mdW5jdGlvbiBfdmFsaWRhdGVVcmkocmV0LCBfc3RyaWN0KSB7XG4gICAgLy8gc2NoZW1lLCBtdXN0IGJlIHNldFxuICAgIGlmICghcmV0LnNjaGVtZSAmJiBfc3RyaWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3JldC5hdXRob3JpdHl9XCIsIHBhdGg6IFwiJHtyZXQucGF0aH1cIiwgcXVlcnk6IFwiJHtyZXQucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7cmV0LmZyYWdtZW50fVwifWApO1xuICAgIH1cbiAgICAvLyBzY2hlbWUsIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gICAgLy8gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgaWYgKHJldC5zY2hlbWUgJiYgIV9zY2hlbWVQYXR0ZXJuLnRlc3QocmV0LnNjaGVtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICAvLyBwYXRoLCBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4zXG4gICAgLy8gSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnRcbiAgICAvLyBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXIuICBJZiBhIFVSSVxuICAgIC8vIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW5cbiAgICAvLyB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpLlxuICAgIGlmIChyZXQucGF0aCkge1xuICAgICAgICBpZiAocmV0LmF1dGhvcml0eSkge1xuICAgICAgICAgICAgaWYgKCFfc2luZ2xlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoX2RvdWJsZVNsYXNoU3RhcnQudGVzdChyZXQucGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gZm9yIGEgd2hpbGUgd2UgYWxsb3dlZCB1cmlzICp3aXRob3V0KiBzY2hlbWVzIGFuZCB0aGlzIGlzIHRoZSBtaWdyYXRpb25cbi8vIGZvciB0aGVtLCBlLmcuIGFuIHVyaSB3aXRob3V0IHNjaGVtZSBhbmQgd2l0aG91dCBzdHJpY3QtbW9kZSB3YXJucyBhbmQgZmFsbHNcbi8vIGJhY2sgdG8gdGhlIGZpbGUtc2NoZW1lLiB0aGF0IHNob3VsZCBjYXVzZSB0aGUgbGVhc3QgY2FybmFnZSBhbmQgc3RpbGwgYmUgYVxuLy8gY2xlYXIgd2FybmluZ1xuZnVuY3Rpb24gX3NjaGVtZUZpeChzY2hlbWUsIF9zdHJpY3QpIHtcbiAgICBpZiAoIXNjaGVtZSAmJiAhX3N0cmljdCkge1xuICAgICAgICByZXR1cm4gJ2ZpbGUnO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1lO1xufVxuLy8gaW1wbGVtZW50cyBhIGJpdCBvZiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTVcbmZ1bmN0aW9uIF9yZWZlcmVuY2VSZXNvbHV0aW9uKHNjaGVtZSwgcGF0aCkge1xuICAgIC8vIHRoZSBzbGFzaC1jaGFyYWN0ZXIgaXMgb3VyICdkZWZhdWx0IGJhc2UnIGFzIHdlIGRvbid0XG4gICAgLy8gc3VwcG9ydCBjb25zdHJ1Y3RpbmcgVVJJcyByZWxhdGl2ZSB0byBvdGhlciBVUklzLiBUaGlzXG4gICAgLy8gYWxzbyBtZWFucyB0aGF0IHdlIGFsdGVyIGFuZCBwb3RlbnRpYWxseSBicmVhayBwYXRocy5cbiAgICAvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjEuNFxuICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgIGNhc2UgJ2h0dHBzJzpcbiAgICAgICAgY2FzZSAnaHR0cCc6XG4gICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhbMF0gIT09IF9zbGFzaCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2ggKyBwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuY29uc3QgX2VtcHR5ID0gJyc7XG5jb25zdCBfc2xhc2ggPSAnLyc7XG5jb25zdCBfcmVnZXhwID0gL14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87XG4vKipcbiAqIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxuICogVGhpcyBjbGFzcyBpcyBhIHNpbXBsZSBwYXJzZXIgd2hpY2ggY3JlYXRlcyB0aGUgYmFzaWMgY29tcG9uZW50IHBhcnRzXG4gKiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMpIHdpdGggbWluaW1hbCB2YWxpZGF0aW9uXG4gKiBhbmQgZW5jb2RpbmcuXG4gKlxuICogYGBgdHh0XG4gKiAgICAgICBmb286Ly9leGFtcGxlLmNvbTo4MDQyL292ZXIvdGhlcmU/bmFtZT1mZXJyZXQjbm9zZVxuICogICAgICAgXFxfLyAgIFxcX19fX19fX19fX19fX18vXFxfX19fX19fX18vIFxcX19fX19fX19fLyBcXF9fL1xuICogICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICB8ICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgIHNjaGVtZSAgICAgYXV0aG9yaXR5ICAgICAgIHBhdGggICAgICAgIHF1ZXJ5ICAgZnJhZ21lbnRcbiAqICAgICAgICB8ICAgX19fX19fX19fX19fX19fX19fX19ffF9fXG4gKiAgICAgICAvIFxcIC8gICAgICAgICAgICAgICAgICAgICAgICBcXFxuICogICAgICAgdXJuOmV4YW1wbGU6YW5pbWFsOmZlcnJldDpub3NlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFVSSSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NoZW1lT3JEYXRhLCBhdXRob3JpdHksIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCwgX3N0cmljdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lT3JEYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBzY2hlbWVPckRhdGEuc2NoZW1lIHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gc2NoZW1lT3JEYXRhLmF1dGhvcml0eSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBzY2hlbWVPckRhdGEucGF0aCB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gc2NoZW1lT3JEYXRhLnF1ZXJ5IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBzY2hlbWVPckRhdGEuZnJhZ21lbnQgfHwgX2VtcHR5O1xuICAgICAgICAgICAgLy8gbm8gdmFsaWRhdGlvbiBiZWNhdXNlIGl0J3MgdGhpcyBVUklcbiAgICAgICAgICAgIC8vIHRoYXQgY3JlYXRlcyB1cmkgY29tcG9uZW50cy5cbiAgICAgICAgICAgIC8vIF92YWxpZGF0ZVVyaSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gX3NjaGVtZUZpeChzY2hlbWVPckRhdGEsIF9zdHJpY3QpO1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBhdXRob3JpdHkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gX3JlZmVyZW5jZVJlc29sdXRpb24odGhpcy5zY2hlbWUsIHBhdGggfHwgX2VtcHR5KTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQgfHwgX2VtcHR5O1xuICAgICAgICAgICAgX3ZhbGlkYXRlVXJpKHRoaXMsIF9zdHJpY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc1VyaSh0aGluZykge1xuICAgICAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBVUkkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmF1dGhvcml0eSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5mcmFnbWVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5wYXRoID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnF1ZXJ5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnNjaGVtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5mc1BhdGggPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcud2l0aCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICAvLyAtLS0tIGZpbGVzeXN0ZW0gcGF0aCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXG4gICAgICogV2lsbCBoYW5kbGUgVU5DIHBhdGhzLCBub3JtYWxpemVzIHdpbmRvd3MgZHJpdmUgbGV0dGVycyB0byBsb3dlci1jYXNlLCBhbmQgdXNlcyB0aGVcbiAgICAgKiBwbGF0Zm9ybSBzcGVjaWZpYyBwYXRoIHNlcGFyYXRvci5cbiAgICAgKlxuICAgICAqICogV2lsbCAqbm90KiB2YWxpZGF0ZSB0aGUgcGF0aCBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzIGFuZCBzZW1hbnRpY3MuXG4gICAgICogKiBXaWxsICpub3QqIGxvb2sgYXQgdGhlIHNjaGVtZSBvZiB0aGlzIFVSSS5cbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGFjY2Vzc2luZyBhIGZpbGUgb24gZGlzay5cbiAgICAgKlxuICAgICAqXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiB0byBgVVJJI3BhdGhgIGlzIHRoZSB1c2Ugb2YgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHNlcGFyYXRvciBhbmQgdGhlIGhhbmRsaW5nXG4gICAgICogb2YgVU5DIHBhdGhzLiBTZWUgdGhlIGJlbG93IHNhbXBsZSBvZiBhIGZpbGUtdXJpIHdpdGggYW4gYXV0aG9yaXR5IChVTkMgcGF0aCkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAgICBjb25zdCB1ID0gVVJJLnBhcnNlKCdmaWxlOi8vc2VydmVyL2MkL2ZvbGRlci9maWxlLnR4dCcpXG4gICAgICAgIHUuYXV0aG9yaXR5ID09PSAnc2VydmVyJ1xuICAgICAgICB1LnBhdGggPT09ICcvc2hhcmVzL2MkL2ZpbGUudHh0J1xuICAgICAgICB1LmZzUGF0aCA9PT0gJ1xcXFxzZXJ2ZXJcXGMkXFxmb2xkZXJcXGZpbGUudHh0J1xuICAgIGBgYFxuICAgICAqXG4gICAgICogVXNpbmcgYFVSSSNwYXRoYCB0byByZWFkIGEgZmlsZSAodXNpbmcgZnMtYXBpcykgd291bGQgbm90IGJlIGVub3VnaCBiZWNhdXNlIHBhcnRzIG9mIHRoZSBwYXRoLFxuICAgICAqIG5hbWVseSB0aGUgc2VydmVyIG5hbWUsIHdvdWxkIGJlIG1pc3NpbmcuIFRoZXJlZm9yZSBgVVJJI2ZzUGF0aGAgZXhpc3RzIC0gaXQncyBzdWdhciB0byBlYXNlIHdvcmtpbmdcbiAgICAgKiB3aXRoIFVSSXMgdGhhdCByZXByZXNlbnQgZmlsZXMgb24gZGlzayAoYGZpbGVgIHNjaGVtZSkuXG4gICAgICovXG4gICAgZ2V0IGZzUGF0aCgpIHtcbiAgICAgICAgLy8gaWYgKHRoaXMuc2NoZW1lICE9PSAnZmlsZScpIHtcbiAgICAgICAgLy8gXHRjb25zb2xlLndhcm4oYFtVcmlFcnJvcl0gY2FsbGluZyBmc1BhdGggd2l0aCBzY2hlbWUgJHt0aGlzLnNjaGVtZX1gKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xuICAgIH1cbiAgICAvLyAtLS0tIG1vZGlmeSB0byBuZXcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHdpdGgoY2hhbmdlKSB7XG4gICAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50IH0gPSBjaGFuZ2U7XG4gICAgICAgIGlmIChzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRob3JpdHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcmFnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdGhpcy5zY2hlbWVcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcbiAgICAgICAgICAgICYmIHBhdGggPT09IHRoaXMucGF0aFxuICAgICAgICAgICAgJiYgcXVlcnkgPT09IHRoaXMucXVlcnlcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaShzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50KTtcbiAgICB9XG4gICAgLy8gLS0tLSBwYXJzZSAmIHZhbGlkYXRlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVVJJIGZyb20gYSBzdHJpbmcsIGUuZy4gYGh0dHA6Ly93d3cuZXhhbXBsZS5jb20vc29tZS9wYXRoYCxcbiAgICAgKiBgZmlsZTovLy91c3IvaG9tZWAsIG9yIGBzY2hlbWU6d2l0aC9wYXRoYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBBIHN0cmluZyB3aGljaCByZXByZXNlbnRzIGFuIFVSSSAoc2VlIGBVUkkjdG9TdHJpbmdgKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIF9zdHJpY3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9yZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJpKF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaShtYXRjaFsyXSB8fCBfZW1wdHksIHBlcmNlbnREZWNvZGUobWF0Y2hbNF0gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs1XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzddIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbOV0gfHwgX2VtcHR5KSwgX3N0cmljdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVVJJIGZyb20gYSBmaWxlIHN5c3RlbSBwYXRoLCBlLmcuIGBjOlxcbXlcXGZpbGVzYCxcbiAgICAgKiBgL3Vzci9ob21lYCwgb3IgYFxcXFxzZXJ2ZXJcXHNoYXJlXFxzb21lXFxwYXRoYC5cbiAgICAgKlxuICAgICAqIFRoZSAqZGlmZmVyZW5jZSogYmV0d2VlbiBgVVJJI3BhcnNlYCBhbmQgYFVSSSNmaWxlYCBpcyB0aGF0IHRoZSBsYXR0ZXIgdHJlYXRzIHRoZSBhcmd1bWVudFxuICAgICAqIGFzIHBhdGgsIG5vdCBhcyBzdHJpbmdpZmllZC11cmkuIEUuZy4gYFVSSS5maWxlKHBhdGgpYCBpcyAqKm5vdCB0aGUgc2FtZSBhcyoqXG4gICAgICogYFVSSS5wYXJzZSgnZmlsZTovLycgKyBwYXRoKWAgYmVjYXVzZSB0aGUgcGF0aCBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBhcmVcbiAgICAgKiBpbnRlcnByZXRlZCAoIyBhbmQgPykuIFNlZSB0aGUgZm9sbG93aW5nIHNhbXBsZTpcbiAgICAgKiBgYGB0c1xuICAgIGNvbnN0IGdvb2QgPSBVUkkuZmlsZSgnL2NvZGluZy9jIy9wcm9qZWN0MScpO1xuICAgIGdvb2Quc2NoZW1lID09PSAnZmlsZSc7XG4gICAgZ29vZC5wYXRoID09PSAnL2NvZGluZy9jIy9wcm9qZWN0MSc7XG4gICAgZ29vZC5mcmFnbWVudCA9PT0gJyc7XG4gICAgY29uc3QgYmFkID0gVVJJLnBhcnNlKCdmaWxlOi8vJyArICcvY29kaW5nL2MjL3Byb2plY3QxJyk7XG4gICAgYmFkLnNjaGVtZSA9PT0gJ2ZpbGUnO1xuICAgIGJhZC5wYXRoID09PSAnL2NvZGluZy9jJzsgLy8gcGF0aCBpcyBub3cgYnJva2VuXG4gICAgYmFkLmZyYWdtZW50ID09PSAnL3Byb2plY3QxJztcbiAgICBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIEEgZmlsZSBzeXN0ZW0gcGF0aCAoc2VlIGBVUkkjZnNQYXRoYClcbiAgICAgKi9cbiAgICBzdGF0aWMgZmlsZShwYXRoKSB7XG4gICAgICAgIGxldCBhdXRob3JpdHkgPSBfZW1wdHk7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBmd2Qtc2xhc2hlcyBvbiB3aW5kb3dzLFxuICAgICAgICAvLyBvbiBvdGhlciBzeXN0ZW1zIGJ3ZC1zbGFzaGVzIGFyZSB2YWxpZFxuICAgICAgICAvLyBmaWxlbmFtZSBjaGFyYWN0ZXIsIGVnIC9mXFxvby9iYVxcci50eHRcbiAgICAgICAgaWYgKGlzV2luZG93cykge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBfc2xhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBhdXRob3JpdHkgYXMgdXNlZCBpbiBVTkMgc2hhcmVzXG4gICAgICAgIC8vIG9yIHVzZSB0aGUgcGF0aCBhcyBnaXZlblxuICAgICAgICBpZiAocGF0aFswXSA9PT0gX3NsYXNoICYmIHBhdGhbMV0gPT09IF9zbGFzaCkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGF0aC5pbmRleE9mKF9zbGFzaCwgMik7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGF1dGhvcml0eSA9IHBhdGguc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyLCBpZHgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhpZHgpIHx8IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVyaSgnZmlsZScsIGF1dGhvcml0eSwgcGF0aCwgX2VtcHR5LCBfZW1wdHkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVcmkoY29tcG9uZW50cy5zY2hlbWUsIGNvbXBvbmVudHMuYXV0aG9yaXR5LCBjb21wb25lbnRzLnBhdGgsIGNvbXBvbmVudHMucXVlcnksIGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgICAgICBfdmFsaWRhdGVVcmkocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiBhIFVSSSBwYXRoIHdpdGggcGF0aCBmcmFnbWVudHMgYW5kIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgaW5wdXQgVVJJLlxuICAgICAqIEBwYXJhbSBwYXRoRnJhZ21lbnQgVGhlIHBhdGggZnJhZ21lbnQgdG8gYWRkIHRvIHRoZSBVUkkgcGF0aC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIFVSSS5cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pblBhdGgodXJpLCAuLi5wYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKCF1cmkucGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBjYW5ub3QgY2FsbCBqb2luUGF0aCBvbiBVUkkgd2l0aG91dCBwYXRoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1BhdGg7XG4gICAgICAgIGlmIChpc1dpbmRvd3MgJiYgdXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBuZXdQYXRoID0gVVJJLmZpbGUocGF0aHMud2luMzIuam9pbih1cmlUb0ZzUGF0aCh1cmksIHRydWUpLCAuLi5wYXRoRnJhZ21lbnQpKS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGF0aCA9IHBhdGhzLnBvc2l4LmpvaW4odXJpLnBhdGgsIC4uLnBhdGhGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS53aXRoKHsgcGF0aDogbmV3UGF0aCB9KTtcbiAgICB9XG4gICAgLy8gLS0tLSBwcmludGluZy9leHRlcm5hbGl6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIFVSSS4gSXQncyBndWFyYW50ZWVkIHRoYXQgY2FsbGluZ1xuICAgICAqIGBVUkkucGFyc2VgIHdpdGggdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gVVJJIHdoaWNoIGlzIGVxdWFsXG4gICAgICogdG8gdGhpcyBVUkkuXG4gICAgICpcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGV4dGVybmFsaXphdGlvbiBvciB0cmFuc3BvcnQuXG4gICAgICogKiBUaGUgcmVzdWx0IHdpbGwgYmUgZW5jb2RlZCB1c2luZyB0aGUgcGVyY2VudGFnZSBlbmNvZGluZyBhbmQgZW5jb2RpbmcgaGFwcGVucyBtb3N0bHlcbiAgICAgKiBpZ25vcmUgdGhlIHNjaGVtZS1zcGVjaWZpYyBlbmNvZGluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBza2lwRW5jb2RpbmcgRG8gbm90IGVuY29kZSB0aGUgcmVzdWx0LCBkZWZhdWx0IGlzIGBmYWxzZWBcbiAgICAgKi9cbiAgICB0b1N0cmluZyhza2lwRW5jb2RpbmcgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX2FzRm9ybWF0dGVkKHRoaXMsIHNraXBFbmNvZGluZyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyByZXZpdmUoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVUkkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShkYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdC5fZm9ybWF0dGVkID0gZGF0YS5leHRlcm5hbDtcbiAgICAgICAgICAgIHJlc3VsdC5fZnNQYXRoID0gZGF0YS5fc2VwID09PSBfcGF0aFNlcE1hcmtlciA/IGRhdGEuZnNQYXRoIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfcGF0aFNlcE1hcmtlciA9IGlzV2luZG93cyA/IDEgOiB1bmRlZmluZWQ7XG4vLyBUaGlzIGNsYXNzIGV4aXN0cyBzbyB0aGF0IFVSSSBpcyBjb21wYXRpYmxlIHdpdGggdnNjb2RlLlVyaSAoQVBJKS5cbmNsYXNzIFVyaSBleHRlbmRzIFVSSSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZzUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBmc1BhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZnNQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9mc1BhdGggPSB1cmlUb0ZzUGF0aCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoc2tpcEVuY29kaW5nID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFza2lwRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVkID0gX2FzRm9ybWF0dGVkKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYWNoZSB0aGF0XG4gICAgICAgICAgICByZXR1cm4gX2FzRm9ybWF0dGVkKHRoaXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgJG1pZDogMSAvKiBVcmkgKi9cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FjaGVkIHN0YXRlXG4gICAgICAgIGlmICh0aGlzLl9mc1BhdGgpIHtcbiAgICAgICAgICAgIHJlcy5mc1BhdGggPSB0aGlzLl9mc1BhdGg7XG4gICAgICAgICAgICByZXMuX3NlcCA9IF9wYXRoU2VwTWFya2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHJlcy5leHRlcm5hbCA9IHRoaXMuX2Zvcm1hdHRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cmkgY29tcG9uZW50c1xuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICByZXMucGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHJlcy5zY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHkpIHtcbiAgICAgICAgICAgIHJlcy5hdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgICAgICAgcmVzLnF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudCkge1xuICAgICAgICAgICAgcmVzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8vIHJlc2VydmVkIGNoYXJhY3RlcnM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4yXG5jb25zdCBlbmNvZGVUYWJsZSA9IHtcbiAgICBbNTggLyogQ29sb24gKi9dOiAnJTNBJyxcbiAgICBbNDcgLyogU2xhc2ggKi9dOiAnJTJGJyxcbiAgICBbNjMgLyogUXVlc3Rpb25NYXJrICovXTogJyUzRicsXG4gICAgWzM1IC8qIEhhc2ggKi9dOiAnJTIzJyxcbiAgICBbOTEgLyogT3BlblNxdWFyZUJyYWNrZXQgKi9dOiAnJTVCJyxcbiAgICBbOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovXTogJyU1RCcsXG4gICAgWzY0IC8qIEF0U2lnbiAqL106ICclNDAnLFxuICAgIFszMyAvKiBFeGNsYW1hdGlvbk1hcmsgKi9dOiAnJTIxJyxcbiAgICBbMzYgLyogRG9sbGFyU2lnbiAqL106ICclMjQnLFxuICAgIFszOCAvKiBBbXBlcnNhbmQgKi9dOiAnJTI2JyxcbiAgICBbMzkgLyogU2luZ2xlUXVvdGUgKi9dOiAnJTI3JyxcbiAgICBbNDAgLyogT3BlblBhcmVuICovXTogJyUyOCcsXG4gICAgWzQxIC8qIENsb3NlUGFyZW4gKi9dOiAnJTI5JyxcbiAgICBbNDIgLyogQXN0ZXJpc2sgKi9dOiAnJTJBJyxcbiAgICBbNDMgLyogUGx1cyAqL106ICclMkInLFxuICAgIFs0NCAvKiBDb21tYSAqL106ICclMkMnLFxuICAgIFs1OSAvKiBTZW1pY29sb24gKi9dOiAnJTNCJyxcbiAgICBbNjEgLyogRXF1YWxzICovXTogJyUzRCcsXG4gICAgWzMyIC8qIFNwYWNlICovXTogJyUyMCcsXG59O1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50RmFzdCh1cmlDb21wb25lbnQsIGFsbG93U2xhc2gpIHtcbiAgICBsZXQgcmVzID0gdW5kZWZpbmVkO1xuICAgIGxldCBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCB1cmlDb21wb25lbnQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gdXJpQ29tcG9uZW50LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgLy8gdW5yZXNlcnZlZCBjaGFyYWN0ZXJzOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuM1xuICAgICAgICBpZiAoKGNvZGUgPj0gOTcgLyogYSAqLyAmJiBjb2RlIDw9IDEyMiAvKiB6ICovKVxuICAgICAgICAgICAgfHwgKGNvZGUgPj0gNjUgLyogQSAqLyAmJiBjb2RlIDw9IDkwIC8qIFogKi8pXG4gICAgICAgICAgICB8fCAoY29kZSA+PSA0OCAvKiBEaWdpdDAgKi8gJiYgY29kZSA8PSA1NyAvKiBEaWdpdDkgKi8pXG4gICAgICAgICAgICB8fCBjb2RlID09PSA0NSAvKiBEYXNoICovXG4gICAgICAgICAgICB8fCBjb2RlID09PSA0NiAvKiBQZXJpb2QgKi9cbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDk1IC8qIFVuZGVybGluZSAqL1xuICAgICAgICAgICAgfHwgY29kZSA9PT0gMTI2IC8qIFRpbGRlICovXG4gICAgICAgICAgICB8fCAoYWxsb3dTbGFzaCAmJiBjb2RlID09PSA0NyAvKiBTbGFzaCAqLykpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBkZWxheWluZyBuYXRpdmUgZW5jb2RlXG4gICAgICAgICAgICBpZiAobmF0aXZlRW5jb2RlUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50LnN1YnN0cmluZyhuYXRpdmVFbmNvZGVQb3MsIHBvcykpO1xuICAgICAgICAgICAgICAgIG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugd3JpdGUgaW50byBhIG5ldyBzdHJpbmcgKGJ5IGRlZmF1bHQgd2UgdHJ5IHRvIHJldHVybiB0aGUgcGFyYW0pXG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gdXJpQ29tcG9uZW50LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jb2RpbmcgbmVlZGVkLCB3ZSBuZWVkIHRvIGFsbG9jYXRlIGEgbmV3IHN0cmluZ1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gdXJpQ29tcG9uZW50LnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgd2l0aCBkZWZhdWx0IHRhYmxlIGZpcnN0XG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkID0gZW5jb2RlVGFibGVbY29kZV07XG4gICAgICAgICAgICBpZiAoZXNjYXBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGRlbGF5aW5nIG5hdGl2ZSBlbmNvZGVcbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlRW5jb2RlUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zLCBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBlc2NhcGVkIHZhcmlhbnQgdG8gcmVzdWx0XG4gICAgICAgICAgICAgICAgcmVzICs9IGVzY2FwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYXRpdmVFbmNvZGVQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIG5hdGl2ZSBlbmNvZGUgb25seSB3aGVuIG5lZWRlZFxuICAgICAgICAgICAgICAgIG5hdGl2ZUVuY29kZVBvcyA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlRW5jb2RlUG9zICE9PSAtMSkge1xuICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCA/IHJlcyA6IHVyaUNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudE1pbmltYWwocGF0aCkge1xuICAgIGxldCByZXMgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgcGF0aC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDM1IC8qIEhhc2ggKi8gfHwgY29kZSA9PT0gNjMgLyogUXVlc3Rpb25NYXJrICovKSB7XG4gICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBwYXRoLnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzICs9IGVuY29kZVRhYmxlW2NvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhdGhbcG9zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiBwYXRoO1xufVxuLyoqXG4gKiBDb21wdXRlIGBmc1BhdGhgIGZvciB0aGUgZ2l2ZW4gdXJpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cmlUb0ZzUGF0aCh1cmksIGtlZXBEcml2ZUxldHRlckNhc2luZykge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAodXJpLmF1dGhvcml0eSAmJiB1cmkucGF0aC5sZW5ndGggPiAxICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICAvLyB1bmMgcGF0aDogZmlsZTovL3NoYXJlcy9jJC9mYXIvYm9vXG4gICAgICAgIHZhbHVlID0gYC8vJHt1cmkuYXV0aG9yaXR5fSR7dXJpLnBhdGh9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAodXJpLnBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogU2xhc2ggKi9cbiAgICAgICAgJiYgKHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPj0gNjUgLyogQSAqLyAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDEpIDw9IDkwIC8qIFogKi8gfHwgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA+PSA5NyAvKiBhICovICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPD0gMTIyIC8qIHogKi8pXG4gICAgICAgICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMikgPT09IDU4IC8qIENvbG9uICovKSB7XG4gICAgICAgIGlmICgha2VlcERyaXZlTGV0dGVyQ2FzaW5nKSB7XG4gICAgICAgICAgICAvLyB3aW5kb3dzIGRyaXZlIGxldHRlcjogZmlsZTovLy9jOi9mYXIvYm9vXG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoWzFdLnRvTG93ZXJDYXNlKCkgKyB1cmkucGF0aC5zdWJzdHIoMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXIgcGF0aFxuICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoO1xuICAgIH1cbiAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvL2csICdcXFxcJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBleHRlcm5hbCB2ZXJzaW9uIG9mIGEgdXJpXG4gKi9cbmZ1bmN0aW9uIF9hc0Zvcm1hdHRlZCh1cmksIHNraXBFbmNvZGluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSAhc2tpcEVuY29kaW5nXG4gICAgICAgID8gZW5jb2RlVVJJQ29tcG9uZW50RmFzdFxuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudE1pbmltYWw7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IHVyaTtcbiAgICBpZiAoc2NoZW1lKSB7XG4gICAgICAgIHJlcyArPSBzY2hlbWU7XG4gICAgICAgIHJlcyArPSAnOic7XG4gICAgfVxuICAgIGlmIChhdXRob3JpdHkgfHwgc2NoZW1lID09PSAnZmlsZScpIHtcbiAgICAgICAgcmVzICs9IF9zbGFzaDtcbiAgICAgICAgcmVzICs9IF9zbGFzaDtcbiAgICB9XG4gICAgaWYgKGF1dGhvcml0eSkge1xuICAgICAgICBsZXQgaWR4ID0gYXV0aG9yaXR5LmluZGV4T2YoJ0AnKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIDx1c2VyPkA8YXV0aD5cbiAgICAgICAgICAgIGNvbnN0IHVzZXJpbmZvID0gYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpO1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnN1YnN0cihpZHggKyAxKTtcbiAgICAgICAgICAgIGlkeCA9IHVzZXJpbmZvLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDx1c2VyPjo8cGFzcz5APGF1dGg+XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKDAsIGlkeCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXMgKz0gJzonO1xuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKHVzZXJpbmZvLnN1YnN0cihpZHggKyAxKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzICs9ICdAJztcbiAgICAgICAgfVxuICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWR4ID0gYXV0aG9yaXR5LmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKGF1dGhvcml0eSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gPGF1dGg+Ojxwb3J0PlxuICAgICAgICAgICAgcmVzICs9IGVuY29kZXIoYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpLCBmYWxzZSk7XG4gICAgICAgICAgICByZXMgKz0gYXV0aG9yaXR5LnN1YnN0cihpZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIC8vIGxvd2VyLWNhc2Ugd2luZG93cyBkcml2ZSBsZXR0ZXJzIGluIC9DOi9mZmYgb3IgQzovZmZmXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAzICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogU2xhc2ggKi8gJiYgcGF0aC5jaGFyQ29kZUF0KDIpID09PSA1OCAvKiBDb2xvbiAqLykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgxKTtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDY1IC8qIEEgKi8gJiYgY29kZSA8PSA5MCAvKiBaICovKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IGAvJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMyl9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gNTggLyogQ29sb24gKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSA2NSAvKiBBICovICYmIGNvZGUgPD0gOTAgLyogWiAqLykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMil9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGhcbiAgICAgICAgcmVzICs9IGVuY29kZXIocGF0aCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChxdWVyeSkge1xuICAgICAgICByZXMgKz0gJz8nO1xuICAgICAgICByZXMgKz0gZW5jb2RlcihxdWVyeSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgcmVzICs9ICcjJztcbiAgICAgICAgcmVzICs9ICFza2lwRW5jb2RpbmcgPyBlbmNvZGVVUklDb21wb25lbnRGYXN0KGZyYWdtZW50LCBmYWxzZSkgOiBmcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIC0tLSBkZWNvZGVcbmZ1bmN0aW9uIGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMykgKyBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChzdHIuc3Vic3RyKDMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfckVuY29kZWRBc0hleCA9IC8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO1xuZnVuY3Rpb24gcGVyY2VudERlY29kZShzdHIpIHtcbiAgICBpZiAoIXN0ci5tYXRjaChfckVuY29kZWRBc0hleCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKF9yRW5jb2RlZEFzSGV4LCAobWF0Y2gpID0+IGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKG1hdGNoKSk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbiB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2xpZmVjeWNsZS5qcyc7XG5pbXBvcnQgeyBnbG9iYWxzLCBpc1dlYiB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCAqIGFzIHR5cGVzIGZyb20gJy4uL3R5cGVzLmpzJztcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vc3RyaW5ncy5qcyc7XG5jb25zdCBJTklUSUFMSVpFID0gJyRpbml0aWFsaXplJztcbmxldCB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gbG9nT25jZVdlYldvcmtlcldhcm5pbmcoZXJyKSB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICAvLyBydW5uaW5nIHRlc3RzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkKSB7XG4gICAgICAgIHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgd2ViIHdvcmtlcihzKS4gRmFsbGluZyBiYWNrIHRvIGxvYWRpbmcgd2ViIHdvcmtlciBjb2RlIGluIG1haW4gdGhyZWFkLCB3aGljaCBtaWdodCBjYXVzZSBVSSBmcmVlemVzLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvbW9uYWNvLWVkaXRvciNmYXEnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGVyci5tZXNzYWdlKTtcbn1cbmNsYXNzIFJlcXVlc3RNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2c1dvcmtlciwgcmVxLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy52c1dvcmtlciA9IHZzV29ya2VyO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogUmVxdWVzdCAqLztcbiAgICB9XG59XG5jbGFzcyBSZXBseU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCBzZXEsIHJlcywgZXJyKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBSZXBseSAqLztcbiAgICB9XG59XG5jbGFzcyBTdWJzY3JpYmVFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmFyZyA9IGFyZztcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBTdWJzY3JpYmVFdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBFdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBVbnN1YnNjcmliZUV2ZW50TWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSkge1xuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnR5cGUgPSA0IC8qIFVuc3Vic2NyaWJlRXZlbnQgKi87XG4gICAgfVxufVxuY2xhc3MgU2ltcGxlV29ya2VyUHJvdG9jb2wge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSAtMTtcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuX2xhc3RTZW50UmVxID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcGxpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNldFdvcmtlcklkKHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gd29ya2VySWQ7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykge1xuICAgICAgICBjb25zdCByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXF1ZXN0TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBtZXRob2QsIGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlbihldmVudE5hbWUsIGFyZykge1xuICAgICAgICBsZXQgcmVxID0gbnVsbDtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckFkZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcSA9IFN0cmluZygrK3RoaXMuX2xhc3RTZW50UmVxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMuc2V0KHJlcSwgZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgU3Vic2NyaWJlRXZlbnRNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIGV2ZW50TmFtZSwgYXJnKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25MYXN0TGlzdGVuZXJSZW1vdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMuZGVsZXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSkpO1xuICAgICAgICAgICAgICAgIHJlcSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCAhbWVzc2FnZS52c1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93b3JrZXJJZCAhPT0gLTEgJiYgbWVzc2FnZS52c1dvcmtlciAhPT0gdGhpcy5fd29ya2VySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBfaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIFJlcGx5ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSZXBseU1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBSZXF1ZXN0ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSZXF1ZXN0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFN1YnNjcmliZUV2ZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBFdmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRXZlbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBjYXNlIDQgLyogVW5zdWJzY3JpYmVFdmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlUmVwbHlNZXNzYWdlKHJlcGx5TWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCByZXBseSB0byB1bmtub3duIHNlcScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV07XG4gICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyKSB7XG4gICAgICAgICAgICBsZXQgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcbiAgICAgICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyLiRpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSByZXBseU1lc3NhZ2UuZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gcmVwbHlNZXNzYWdlLmVyci5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGx5LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcGx5LnJlc29sdmUocmVwbHlNZXNzYWdlLnJlcyk7XG4gICAgfVxuICAgIF9oYW5kbGVSZXF1ZXN0TWVzc2FnZShyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVxID0gcmVxdWVzdE1lc3NhZ2UucmVxO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5faGFuZGxlci5oYW5kbGVNZXNzYWdlKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UuYXJncyk7XG4gICAgICAgIHJlc3VsdC50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXBseU1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgciwgdW5kZWZpbmVkKSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIExvYWRpbmcgZXJyb3JzIGhhdmUgYSBkZXRhaWwgcHJvcGVydHkgdGhhdCBwb2ludHMgdG8gdGhlIGFjdHVhbCBlcnJvclxuICAgICAgICAgICAgICAgIGUuZGV0YWlsID0gdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGUuZGV0YWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFJlcGx5TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCB1bmRlZmluZWQsIHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZVN1YnNjcmliZUV2ZW50TWVzc2FnZShtc2cpIHtcbiAgICAgICAgY29uc3QgcmVxID0gbXNnLnJlcTtcbiAgICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlRXZlbnQobXNnLmV2ZW50TmFtZSwgbXNnLmFyZykoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBFdmVudE1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMuc2V0KHJlcSwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIF9oYW5kbGVFdmVudE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLmhhcyhtc2cucmVxKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgZXZlbnQgZm9yIHVua25vd24gcmVxJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLmdldChtc2cucmVxKS5maXJlKG1zZy5ldmVudCk7XG4gICAgfVxuICAgIF9oYW5kbGVVbnN1YnNjcmliZUV2ZW50TWVzc2FnZShtc2cpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nRXZlbnRzLmhhcyhtc2cucmVxKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgdW5zdWJzY3JpYmUgZm9yIHVua25vd24gcmVxJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cy5nZXQobXNnLnJlcSkuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLmRlbGV0ZShtc2cucmVxKTtcbiAgICB9XG4gICAgX3NlbmQobXNnKSB7XG4gICAgICAgIGxldCB0cmFuc2ZlciA9IFtdO1xuICAgICAgICBpZiAobXNnLnR5cGUgPT09IDAgLyogUmVxdWVzdCAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyLnB1c2gobXNnLmFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cudHlwZSA9PT0gMSAvKiBSZXBseSAqLykge1xuICAgICAgICAgICAgaWYgKG1zZy5yZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyLnB1c2gobXNnLnJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFuZGxlci5zZW5kTWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICB9XG59XG4vKipcbiAqIE1haW4gdGhyZWFkIHNpZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVdvcmtlckNsaWVudCBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKHdvcmtlckZhY3RvcnksIG1vZHVsZUlkLCBob3N0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGxldCBsYXp5UHJveHlSZWplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB0aGlzLl9yZWdpc3Rlcih3b3JrZXJGYWN0b3J5LmNyZWF0ZSgndnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlcicsIChtc2cpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gaW4gRmlyZWZveCwgd2ViIHdvcmtlcnMgZmFpbCBsYXppbHkgOihcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxuICAgICAgICAgICAgaWYgKGxhenlQcm94eVJlamVjdCkge1xuICAgICAgICAgICAgICAgIGxhenlQcm94eVJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gbmV3IFNpbXBsZVdvcmtlclByb3RvY29sKHtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBob3N0W21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyBtZXRob2QgJyArIG1ldGhvZCArICcgb24gbWFpbiB0aHJlYWQgaG9zdC4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaG9zdFttZXRob2RdLmFwcGx5KGhvc3QsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVFdmVudDogKGV2ZW50TmFtZSwgYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SXNEeW5hbWljRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGhvc3RbZXZlbnROYW1lXS5jYWxsKGhvc3QsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBkeW5hbWljIGV2ZW50ICR7ZXZlbnROYW1lfSBvbiBtYWluIHRocmVhZCBob3N0LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SXNFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gaG9zdFtldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXZlbnQgJHtldmVudE5hbWV9IG9uIG1haW4gdGhyZWFkIGhvc3QuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBldmVudCBuYW1lICR7ZXZlbnROYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuc2V0V29ya2VySWQodGhpcy5fd29ya2VyLmdldElkKCkpO1xuICAgICAgICAvLyBHYXRoZXIgbG9hZGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgbGV0IGxvYWRlckNvbmZpZ3VyYXRpb24gPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbHMucmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbHMucmVxdWlyZS5nZXRDb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBNb25hY28gQU1EIExvYWRlclxuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IGdsb2JhbHMucmVxdWlyZS5nZXRDb25maWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFscy5yZXF1aXJlanMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSByZXF1aXJlanNcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZ3VyYXRpb24gPSBnbG9iYWxzLnJlcXVpcmVqcy5zLmNvbnRleHRzLl8uY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RNZXRob2RzID0gdHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXMoaG9zdCk7XG4gICAgICAgIC8vIFNlbmQgaW5pdGlhbGl6ZSBtZXNzYWdlXG4gICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkID0gdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UoSU5JVElBTElaRSwgW1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLmdldElkKCksXG4gICAgICAgICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxvYWRlckNvbmZpZ3VyYXRpb24pKSxcbiAgICAgICAgICAgIG1vZHVsZUlkLFxuICAgICAgICAgICAgaG9zdE1ldGhvZHMsXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBDcmVhdGUgcHJveHkgdG8gbG9hZGVkIGNvZGVcbiAgICAgICAgY29uc3QgcHJveHlNZXRob2RSZXF1ZXN0ID0gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJveHlMaXN0ZW4gPSAoZXZlbnROYW1lLCBhcmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b2NvbC5saXN0ZW4oZXZlbnROYW1lLCBhcmcpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sYXp5UHJveHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsYXp5UHJveHlSZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZC50aGVuKChhdmFpbGFibGVNZXRob2RzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVQcm94eU9iamVjdChhdmFpbGFibGVNZXRob2RzLCBwcm94eU1ldGhvZFJlcXVlc3QsIHByb3h5TGlzdGVuKSk7XG4gICAgICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKCdXb3JrZXIgZmFpbGVkIHRvIGxvYWQgJyArIG1vZHVsZUlkLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UHJveHlPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXp5UHJveHk7XG4gICAgfVxuICAgIF9yZXF1ZXN0KG1ldGhvZCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25Nb2R1bGVMb2FkZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UobWV0aG9kLCBhcmdzKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5pbmZvKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9wZXJ0eUlzRXZlbnQobmFtZSkge1xuICAgIC8vIEFzc3VtZSBhIHByb3BlcnR5IGlzIGFuIGV2ZW50IGlmIGl0IGhhcyBhIGZvcm0gb2YgXCJvblNvbWV0aGluZ1wiXG4gICAgcmV0dXJuIG5hbWVbMF0gPT09ICdvJyAmJiBuYW1lWzFdID09PSAnbicgJiYgc3RyaW5ncy5pc1VwcGVyQXNjaWlMZXR0ZXIobmFtZS5jaGFyQ29kZUF0KDIpKTtcbn1cbmZ1bmN0aW9uIHByb3BlcnR5SXNEeW5hbWljRXZlbnQobmFtZSkge1xuICAgIC8vIEFzc3VtZSBhIHByb3BlcnR5IGlzIGEgZHluYW1pYyBldmVudCAoYSBtZXRob2QgdGhhdCByZXR1cm5zIGFuIGV2ZW50KSBpZiBpdCBoYXMgYSBmb3JtIG9mIFwib25EeW5hbWljU29tZXRoaW5nXCJcbiAgICByZXR1cm4gL15vbkR5bmFtaWMvLnRlc3QobmFtZSkgJiYgc3RyaW5ncy5pc1VwcGVyQXNjaWlMZXR0ZXIobmFtZS5jaGFyQ29kZUF0KDkpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5T2JqZWN0KG1ldGhvZE5hbWVzLCBpbnZva2UsIHByb3h5TGlzdGVuKSB7XG4gICAgY29uc3QgY3JlYXRlUHJveHlNZXRob2QgPSAobWV0aG9kKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVByb3h5RHluYW1pY0V2ZW50ID0gKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHByb3h5TGlzdGVuKGV2ZW50TmFtZSwgYXJnKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5SXNEeW5hbWljRXZlbnQobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IGNyZWF0ZVByb3h5RHluYW1pY0V2ZW50KG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFdmVudChtZXRob2ROYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W21ldGhvZE5hbWVdID0gcHJveHlMaXN0ZW4obWV0aG9kTmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IGNyZWF0ZVByb3h5TWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBXb3JrZXIgc2lkZVxuICovXG5leHBvcnQgY2xhc3MgU2ltcGxlV29ya2VyU2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3N0TWVzc2FnZSwgcmVxdWVzdEhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSA9IHJlcXVlc3RIYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG5ldyBTaW1wbGVXb3JrZXJQcm90b2NvbCh7XG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiAobWV0aG9kLCBhcmdzKSA9PiB0aGlzLl9oYW5kbGVNZXNzYWdlKG1ldGhvZCwgYXJncyksXG4gICAgICAgICAgICBoYW5kbGVFdmVudDogKGV2ZW50TmFtZSwgYXJnKSA9PiB0aGlzLl9oYW5kbGVFdmVudChldmVudE5hbWUsIGFyZylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9ubWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuaGFuZGxlTWVzc2FnZShtc2cpO1xuICAgIH1cbiAgICBfaGFuZGxlTWVzc2FnZShtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gSU5JVElBTElaRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RIYW5kbGVyIHx8IHR5cGVvZiB0aGlzLl9yZXF1ZXN0SGFuZGxlclttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVlc3RIYW5kbGVyIG9yIG1ldGhvZDogJyArIG1ldGhvZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3JlcXVlc3RIYW5kbGVyW21ldGhvZF0uYXBwbHkodGhpcy5fcmVxdWVzdEhhbmRsZXIsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVFdmVudChldmVudE5hbWUsIGFyZykge1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcmVxdWVzdEhhbmRsZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJc0R5bmFtaWNFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuX3JlcXVlc3RIYW5kbGVyW2V2ZW50TmFtZV0uY2FsbCh0aGlzLl9yZXF1ZXN0SGFuZGxlciwgYXJnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZHluYW1pYyBldmVudCAke2V2ZW50TmFtZX0gb24gcmVxdWVzdCBoYW5kbGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBldmVudCAke2V2ZW50TmFtZX0gb24gcmVxdWVzdCBoYW5kbGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9YCk7XG4gICAgfVxuICAgIGluaXRpYWxpemUod29ya2VySWQsIGxvYWRlckNvbmZpZywgbW9kdWxlSWQsIGhvc3RNZXRob2RzKSB7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLnNldFdvcmtlcklkKHdvcmtlcklkKTtcbiAgICAgICAgY29uc3QgcHJveHlNZXRob2RSZXF1ZXN0ID0gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLnNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3h5TGlzdGVuID0gKGV2ZW50TmFtZSwgYXJnKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2wubGlzdGVuKGV2ZW50TmFtZSwgYXJnKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaG9zdFByb3h5ID0gY3JlYXRlUHJveHlPYmplY3QoaG9zdE1ldGhvZHMsIHByb3h5TWV0aG9kUmVxdWVzdCwgcHJveHlMaXN0ZW4pO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICAvLyBzdGF0aWMgcmVxdWVzdCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeShob3N0UHJveHkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9yZXF1ZXN0SGFuZGxlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2FkZXJDb25maWcpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSAnYmFzZVVybCcsIGhhbmRsaW5nIGl0IGlzIGJleW9uZCBzY29wZSBmb3Igbm93XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5iYXNlVXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ2Jhc2VVcmwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLnBhdGhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLnBhdGhzLnZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnLnBhdGhzWyd2cyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLnRydXN0ZWRUeXBlc1BvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlLCBpdCBoYXMgYmVlbiBkZXN0cm95ZWQgZHVyaW5nIHNlcmlhbGl6ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ3RydXN0ZWRUeXBlc1BvbGljeSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBpbiBhIHdlYiB3b3JrZXIsIGVuYWJsZSBjYXRjaGluZyBlcnJvcnNcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsb2JhbHMucmVxdWlyZS5jb25maWcobG9hZGVyQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgcmVxdWlyZSB0byBiZSBzdXJlIHRvIGdldCB0aGUgZ2xvYmFsIGNvbmZpZ1xuICAgICAgICAgICAgLy8gRVNNLWNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIC8vIFx0XHRcdGNvbnN0IHJlcSA9IChnbG9iYWxzLnJlcXVpcmUgfHwgcmVxdWlyZSk7XG4gICAgICAgICAgICAvLyBFU00tY29tbWVudC1lbmRcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGdsb2JhbHMucmVxdWlyZTtcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXG4gICAgICAgICAgICByZXEoW21vZHVsZUlkXSwgKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gbW9kdWxlLmNyZWF0ZShob3N0UHJveHkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm8gUmVxdWVzdEhhbmRsZXIhYCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fcmVxdWVzdEhhbmRsZXIpKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsbGVkIG9uIHRoZSB3b3JrZXIgc2lkZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHBvc3RNZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVXb3JrZXJTZXJ2ZXIocG9zdE1lc3NhZ2UsIG51bGwpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyB0b1VpbnQ4IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdWludC5qcyc7XG4vKipcbiAqIEEgZmFzdCBjaGFyYWN0ZXIgY2xhc3NpZmllciB0aGF0IHVzZXMgYSBjb21wYWN0IGFycmF5IGZvciBBU0NJSSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJDbGFzc2lmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRvVWludDgoX2RlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fYXNjaWlNYXAgPSBDaGFyYWN0ZXJDbGFzc2lmaWVyLl9jcmVhdGVBc2NpaU1hcChkZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlQXNjaWlNYXAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFzY2lpTWFwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgYXNjaWlNYXBbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzY2lpTWFwO1xuICAgIH1cbiAgICBzZXQoY2hhckNvZGUsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvVWludDgoX3ZhbHVlKTtcbiAgICAgICAgaWYgKGNoYXJDb2RlID49IDAgJiYgY2hhckNvZGUgPCAyNTYpIHtcbiAgICAgICAgICAgIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChjaGFyQ29kZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMCAmJiBjaGFyQ29kZSA8IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWFwLmdldChjaGFyQ29kZSkgfHwgdGhpcy5fZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSBuZXcgQ2hhcmFjdGVyQ2xhc3NpZmllcigwIC8qIEZhbHNlICovKTtcbiAgICB9XG4gICAgYWRkKGNoYXJDb2RlKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbC5zZXQoY2hhckNvZGUsIDEgLyogVHJ1ZSAqLyk7XG4gICAgfVxuICAgIGhhcyhjaGFyQ29kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2FjdHVhbC5nZXQoY2hhckNvZGUpID09PSAxIC8qIFRydWUgKi8pO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBBIHBvc2l0aW9uIGluIHRoZSBlZGl0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbiB7XG4gICAgY29uc3RydWN0b3IobGluZU51bWJlciwgY29sdW1uKSB7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcG9zaXRpb24gZnJvbSB0aGlzIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0xpbmVOdW1iZXIgbmV3IGxpbmUgbnVtYmVyXG4gICAgICogQHBhcmFtIG5ld0NvbHVtbiBuZXcgY29sdW1uXG4gICAgICovXG4gICAgd2l0aChuZXdMaW5lTnVtYmVyID0gdGhpcy5saW5lTnVtYmVyLCBuZXdDb2x1bW4gPSB0aGlzLmNvbHVtbikge1xuICAgICAgICBpZiAobmV3TGluZU51bWJlciA9PT0gdGhpcy5saW5lTnVtYmVyICYmIG5ld0NvbHVtbiA9PT0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihuZXdMaW5lTnVtYmVyLCBuZXdDb2x1bW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVsdGFMaW5lTnVtYmVyIGxpbmUgbnVtYmVyIGRlbHRhXG4gICAgICogQHBhcmFtIGRlbHRhQ29sdW1uIGNvbHVtbiBkZWx0YVxuICAgICAqL1xuICAgIGRlbHRhKGRlbHRhTGluZU51bWJlciA9IDAsIGRlbHRhQ29sdW1uID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHRoaXMubGluZU51bWJlciArIGRlbHRhTGluZU51bWJlciwgdGhpcy5jb2x1bW4gKyBkZWx0YUNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBlcXVhbHMgb3RoZXIgcG9zaXRpb25cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmVxdWFscyh0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGVxdWFscyBwb3NpdGlvbiBgYmBcbiAgICAgKi9cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCEhYSAmJlxuICAgICAgICAgICAgISFiICYmXG4gICAgICAgICAgICBhLmxpbmVOdW1iZXIgPT09IGIubGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5jb2x1bW4gPT09IGIuY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBvdGhlciBwb3NpdGlvbi5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cbiAgICAgKi9cbiAgICBpc0JlZm9yZShvdGhlcikge1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmUodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGBhYCBpcyBiZWZvcmUgcG9zaXRpb24gYGJgLlxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIGZhbHNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0JlZm9yZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPCBiLmNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBvdGhlciBwb3NpdGlvbi5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxuICAgICAqL1xuICAgIGlzQmVmb3JlT3JFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmVPckVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0JlZm9yZU9yRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDw9IGIuY29sdW1uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcG9zaXRpb25zLCB1c2VmdWwgZm9yIHNvcnRpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFMaW5lTnVtYmVyID0gYS5saW5lTnVtYmVyIHwgMDtcbiAgICAgICAgY29uc3QgYkxpbmVOdW1iZXIgPSBiLmxpbmVOdW1iZXIgfCAwO1xuICAgICAgICBpZiAoYUxpbmVOdW1iZXIgPT09IGJMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBhQ29sdW1uID0gYS5jb2x1bW4gfCAwO1xuICAgICAgICAgICAgY29uc3QgYkNvbHVtbiA9IGIuY29sdW1uIHwgMDtcbiAgICAgICAgICAgIHJldHVybiBhQ29sdW1uIC0gYkNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYUxpbmVOdW1iZXIgLSBiTGluZU51bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhpcyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmVOdW1iZXIsIHRoaXMuY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0byBhIGh1bWFuLXJlYWRhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJygnICsgdGhpcy5saW5lTnVtYmVyICsgJywnICsgdGhpcy5jb2x1bW4gKyAnKSc7XG4gICAgfVxuICAgIC8vIC0tLVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGBQb3NpdGlvbmAgZnJvbSBhbiBgSVBvc2l0aW9uYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlmdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3MubGluZU51bWJlciwgcG9zLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG9iamAgaXMgYW4gYElQb3NpdGlvbmAuXG4gICAgICovXG4gICAgc3RhdGljIGlzSVBvc2l0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gKG9ialxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmoubGluZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5jb2x1bW4gPT09ICdudW1iZXInKSk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24uanMnO1xuLyoqXG4gKiBBIHJhbmdlIGluIHRoZSBlZGl0b3IuIChzdGFydExpbmVOdW1iZXIsc3RhcnRDb2x1bW4pIGlzIDw9IChlbmRMaW5lTnVtYmVyLGVuZENvbHVtbilcbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKChzdGFydExpbmVOdW1iZXIgPiBlbmRMaW5lTnVtYmVyKSB8fCAoc3RhcnRMaW5lTnVtYmVyID09PSBlbmRMaW5lTnVtYmVyICYmIHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmlzRW1wdHkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYHJhbmdlYCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eShyYW5nZSkge1xuICAgICAgICByZXR1cm4gKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiByYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBwb3NpdGlvbmAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBlZGdlcywgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID4gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaWN0Q29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8PSByYW5nZS5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA+PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiByYW5nZSBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcmFuZ2UgaXMgZXF1YWwgdG8gdGhpcyByYW5nZSwgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBjb250YWluc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgc3RhdGljIGNvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPCByYW5nZS5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIHN0cmljdGx5IGluIHRoaXMgcmFuZ2UuIGByYW5nZWAgbXVzdCBzdGFydCBhZnRlciBhbmQgZW5kIGJlZm9yZSB0aGlzIHJhbmdlIGZvciB0aGUgcmVzdWx0IHRvIGJlIHRydWUuXG4gICAgICovXG4gICAgc3RyaWN0Q29udGFpbnNSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2Uuc3RyaWN0Q29udGFpbnNSYW5nZSh0aGlzLCByYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG90aGVyUmFuZ2VgIGlzIHN0cmljdGx5IGluIGByYW5nZWAgKG11c3Qgc3RhcnQgYWZ0ZXIsIGFuZCBlbmQgYmVmb3JlKS4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpY3RDb250YWluc1JhbmdlKHJhbmdlLCBvdGhlclJhbmdlKSB7XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLnN0YXJ0TGluZU51bWJlciAmJiBvdGhlclJhbmdlLnN0YXJ0Q29sdW1uIDw9IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBvdGhlclJhbmdlLmVuZENvbHVtbiA+PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZXVuaW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxuICAgICAqIFRoZSBzbWFsbGVzdCBwb3NpdGlvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvaW50LCBhbmQgdGhlIGxhcmdlc3Qgb25lIGFzIHRoZSBlbmQgcG9pbnQuXG4gICAgICovXG4gICAgcGx1c1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5wbHVzUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICogVGhlIHNtYWxsZXN0IHBvc2l0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9pbnQsIGFuZCB0aGUgbGFyZ2VzdCBvbmUgYXMgdGhlIGVuZCBwb2ludC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGx1c1JhbmdlKGEsIGIpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IHN0YXJ0Q29sdW1uO1xuICAgICAgICBsZXQgZW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IGVuZENvbHVtbjtcbiAgICAgICAgaWYgKGIuc3RhcnRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuc3RhcnRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IE1hdGgubWluKGIuc3RhcnRDb2x1bW4sIGEuc3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA+IGEuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IGIuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuZW5kTGluZU51bWJlciA9PT0gYS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gTWF0aC5tYXgoYi5lbmRDb2x1bW4sIGEuZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxuICAgICAqL1xuICAgIGludGVyc2VjdFJhbmdlcyhyYW5nZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuaW50ZXJzZWN0UmFuZ2VzKHRoaXMsIHJhbmdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICovXG4gICAgc3RhdGljIGludGVyc2VjdFJhbmdlcyhhLCBiKSB7XG4gICAgICAgIGxldCByZXN1bHRTdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcbiAgICAgICAgbGV0IHJlc3VsdEVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCByZXN1bHRFbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcbiAgICAgICAgbGV0IG90aGVyU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBvdGhlclN0YXJ0Q29sdW1uID0gYi5zdGFydENvbHVtbjtcbiAgICAgICAgbGV0IG90aGVyRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IG90aGVyRW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XG4gICAgICAgIGlmIChyZXN1bHRTdGFydExpbmVOdW1iZXIgPCBvdGhlclN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0U3RhcnRMaW5lTnVtYmVyID0gb3RoZXJTdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICByZXN1bHRTdGFydENvbHVtbiA9IG90aGVyU3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID09PSBvdGhlclN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBNYXRoLm1heChyZXN1bHRTdGFydENvbHVtbiwgb3RoZXJTdGFydENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdEVuZExpbmVOdW1iZXIgPiBvdGhlckVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdEVuZExpbmVOdW1iZXIgPSBvdGhlckVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICByZXN1bHRFbmRDb2x1bW4gPSBvdGhlckVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID09PSBvdGhlckVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdEVuZENvbHVtbiA9IE1hdGgubWluKHJlc3VsdEVuZENvbHVtbiwgb3RoZXJFbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyBub3cgZW1wdHlcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA+IHJlc3VsdEVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRTdGFydExpbmVOdW1iZXIgPT09IHJlc3VsdEVuZExpbmVOdW1iZXIgJiYgcmVzdWx0U3RhcnRDb2x1bW4gPiByZXN1bHRFbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmVzdWx0U3RhcnRMaW5lTnVtYmVyLCByZXN1bHRTdGFydENvbHVtbiwgcmVzdWx0RW5kTGluZU51bWJlciwgcmVzdWx0RW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIHJhbmdlIGVxdWFscyBvdGhlci5cbiAgICAgKi9cbiAgICBlcXVhbHNSYW5nZShvdGhlcikge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZXF1YWxzUmFuZ2UodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHJhbmdlIGBhYCBlcXVhbHMgYGJgLlxuICAgICAqL1xuICAgIHN0YXRpYyBlcXVhbHNSYW5nZShhLCBiKSB7XG4gICAgICAgIHJldHVybiAoISFhICYmXG4gICAgICAgICAgICAhIWIgJiZcbiAgICAgICAgICAgIGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5zdGFydENvbHVtbiA9PT0gYi5zdGFydENvbHVtbiAmJlxuICAgICAgICAgICAgYS5lbmRMaW5lTnVtYmVyID09PSBiLmVuZExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZW5kIHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBnZXRFbmRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmdldEVuZFBvc2l0aW9uKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICovXG4gICAgc3RhdGljIGdldEVuZFBvc2l0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBnZXRTdGFydFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3RhcnRQb3NpdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSB1c2VyIHByZXNlbnRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgJywnICsgdGhpcy5zdGFydENvbHVtbiArICcgLT4gJyArIHRoaXMuZW5kTGluZU51bWJlciArICcsJyArIHRoaXMuZW5kQ29sdW1uICsgJ10nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLCBhbmQgdXNpbmcgZW5kTGluZU51bWJlciBhbmQgZW5kQ29sdW1uIGFzIHRoZSBlbmQgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0RW5kUG9zaXRpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLCBhbmQgdXNpbmcgc3RhcnRMaW5lTnVtYmVyIGFuZCBzdGFydENvbHVtbiBhcyB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0U3RhcnRQb3NpdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgY29sbGFwc2VUb1N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuY29sbGFwc2VUb1N0YXJ0KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsYXBzZVRvU3RhcnQocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLy8gLS0tXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQubGluZU51bWJlciwgc3RhcnQuY29sdW1uLCBlbmQubGluZU51bWJlciwgZW5kLmNvbHVtbik7XG4gICAgfVxuICAgIHN0YXRpYyBsaWZ0KHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbiwgcmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgb2JqYCBpcyBhbiBgSVJhbmdlYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJUmFuZ2Uob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5zdGFydExpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kTGluZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5lbmRDb2x1bW4gPT09ICdudW1iZXInKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIHR3byByYW5nZXMgYXJlIHRvdWNoaW5nIGluIGFueSB3YXkuXG4gICAgICovXG4gICAgc3RhdGljIGFyZUludGVyc2VjdGluZ09yVG91Y2hpbmcoYSwgYikge1xuICAgICAgICAvLyBDaGVjayBpZiBgYWAgaXMgYmVmb3JlIGBiYFxuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyIDwgYi5zdGFydExpbmVOdW1iZXIgfHwgKGEuZW5kTGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgYS5lbmRDb2x1bW4gPCBiLnN0YXJ0Q29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGBiYCBpcyBiZWZvcmUgYGFgXG4gICAgICAgIGlmIChiLmVuZExpbmVOdW1iZXIgPCBhLnN0YXJ0TGluZU51bWJlciB8fCAoYi5lbmRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlciAmJiBiLmVuZENvbHVtbiA8IGEuc3RhcnRDb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgcmFuZ2VzIG11c3QgaW50ZXJzZWN0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gcmFuZ2VzIGFyZSBpbnRlcnNlY3RpbmcuIElmIHRoZSByYW5nZXMgYXJlIHRvdWNoaW5nIGl0IHJldHVybnMgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJlSW50ZXJzZWN0aW5nKGEsIGIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDw9IGIuc3RhcnRDb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgYGJgIGlzIGJlZm9yZSBgYWBcbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyIHx8IChiLmVuZExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyICYmIGIuZW5kQ29sdW1uIDw9IGEuc3RhcnRDb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgcmFuZ2VzIG11c3QgaW50ZXJzZWN0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcmFuZ2VzLCB1c2VmdWwgZm9yIHNvcnRpbmcgcmFuZ2VzXG4gICAgICogSXQgd2lsbCBmaXJzdCBjb21wYXJlIHJhbmdlcyBvbiB0aGUgc3RhcnRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgZW5kUG9zaXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVJhbmdlc1VzaW5nU3RhcnRzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgJiYgYikge1xuICAgICAgICAgICAgY29uc3QgYVN0YXJ0TGluZU51bWJlciA9IGEuc3RhcnRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGJTdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlciB8IDA7XG4gICAgICAgICAgICBpZiAoYVN0YXJ0TGluZU51bWJlciA9PT0gYlN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW4gfCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJTdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW4gfCAwO1xuICAgICAgICAgICAgICAgIGlmIChhU3RhcnRDb2x1bW4gPT09IGJTdGFydENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhRW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlciB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJFbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFFbmRMaW5lTnVtYmVyID09PSBiRW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYUVuZENvbHVtbiA9IGEuZW5kQ29sdW1uIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJFbmRDb2x1bW4gPSBiLmVuZENvbHVtbiB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVuZENvbHVtbiAtIGJFbmRDb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFFbmRMaW5lTnVtYmVyIC0gYkVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhU3RhcnRDb2x1bW4gLSBiU3RhcnRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYVN0YXJ0TGluZU51bWJlciAtIGJTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYUV4aXN0cyA9IChhID8gMSA6IDApO1xuICAgICAgICBjb25zdCBiRXhpc3RzID0gKGIgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiBhRXhpc3RzIC0gYkV4aXN0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xuICAgICAqIEl0IHdpbGwgZmlyc3QgY29tcGFyZSByYW5nZXMgb24gdGhlIGVuZFBvc2l0aW9uIGFuZCB0aGVuIG9uIHRoZSBzdGFydFBvc2l0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVSYW5nZXNVc2luZ0VuZHMoYSwgYikge1xuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyID09PSBiLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChhLmVuZENvbHVtbiA9PT0gYi5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zdGFydExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0Q29sdW1uIC0gYi5zdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRMaW5lTnVtYmVyIC0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYS5lbmRDb2x1bW4gLSBiLmVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lbmRMaW5lTnVtYmVyIC0gYi5lbmRMaW5lTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoZSByYW5nZSBzcGFucyBtdWx0aXBsZSBsaW5lcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3BhbnNNdWx0aXBsZUxpbmVzKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XG4vKipcbiAqIEEgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG4gKiBUaGUgc2VsZWN0aW9uIGlzIGEgcmFuZ2UgdGhhdCBoYXMgYW4gb3JpZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb24gZXh0ZW5kcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbikge1xuICAgICAgICBzdXBlcihzZWxlY3Rpb25TdGFydExpbmVOdW1iZXIsIHNlbGVjdGlvblN0YXJ0Q29sdW1uLCBwb3NpdGlvbkxpbmVOdW1iZXIsIHBvc2l0aW9uQ29sdW1uKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPSBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPSBzZWxlY3Rpb25TdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIgPSBwb3NpdGlvbkxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMucG9zaXRpb25Db2x1bW4gPSBwb3NpdGlvbkNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLnBvc2l0aW9uTGluZU51bWJlciArICcsJyArIHRoaXMucG9zaXRpb25Db2x1bW4gKyAnXSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgZXF1YWxzIG90aGVyIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBlcXVhbHNTZWxlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChTZWxlY3Rpb24uc2VsZWN0aW9uc0VxdWFsKHRoaXMsIG90aGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIHR3byBzZWxlY3Rpb25zIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0aW9uc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gYi5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09IGIuc2VsZWN0aW9uU3RhcnRDb2x1bW4gJiZcbiAgICAgICAgICAgIGEucG9zaXRpb25MaW5lTnVtYmVyID09PSBiLnBvc2l0aW9uTGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5wb3NpdGlvbkNvbHVtbiA9PT0gYi5wb3NpdGlvbkNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkaXJlY3Rpb25zIChMVFIgb3IgUlRMKS5cbiAgICAgKi9cbiAgICBnZXREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gdGhpcy5zdGFydExpbmVOdW1iZXIgJiYgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gdGhpcy5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogTFRSICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxIC8qIFJUTCAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxuICAgICAqL1xuICAgIHNldEVuZFBvc2l0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgdGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGF0IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMucG9zaXRpb25MaW5lTnVtYmVyLCB0aGlzLnBvc2l0aW9uQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXJgIGFuZCBgc2VsZWN0aW9uU3RhcnRDb2x1bW5gLlxuICAgICAqL1xuICAgIHNldFN0YXJ0UG9zaXRpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4sIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pO1xuICAgIH1cbiAgICAvLyAtLS0tXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYFNlbGVjdGlvbmAgZnJvbSBvbmUgb3IgdHdvIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQgPSBzdGFydCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBTZWxlY3Rpb25gIGZyb20gYSByYW5nZSwgZ2l2ZW4gYSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SYW5nZShyYW5nZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgLyogTFRSICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlmdFNlbGVjdGlvbihzZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYWAgZXF1YWxzIGBiYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0aW9uc0FyckVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgJiYgIWIgfHwgIWEgJiYgYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uc0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJU2VsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJU2VsZWN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gKG9ialxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnNlbGVjdGlvblN0YXJ0Q29sdW1uID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnBvc2l0aW9uTGluZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkNvbHVtbiA9PT0gJ251bWJlcicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVdpdGhEaXJlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBMVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xuZXhwb3J0IGNsYXNzIFdvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyIGV4dGVuZHMgQ2hhcmFjdGVyQ2xhc3NpZmllciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNlcGFyYXRvcnMpIHtcbiAgICAgICAgc3VwZXIoMCAvKiBSZWd1bGFyICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHdvcmRTZXBhcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNldCh3b3JkU2VwYXJhdG9ycy5jaGFyQ29kZUF0KGkpLCAyIC8qIFdvcmRTZXBhcmF0b3IgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KDMyIC8qIFNwYWNlICovLCAxIC8qIFdoaXRlc3BhY2UgKi8pO1xuICAgICAgICB0aGlzLnNldCg5IC8qIFRhYiAqLywgMSAvKiBXaGl0ZXNwYWNlICovKTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbmNlKGNvbXB1dGVGbikge1xuICAgIGNvbnN0IGNhY2hlID0ge307IC8vIFRPRE9AQWxleCB1bmJvdW5kZWQgY2FjaGVcbiAgICByZXR1cm4gKGlucHV0KSA9PiB7XG4gICAgICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjYWNoZVtpbnB1dF0gPSBjb21wdXRlRm4oaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZVtpbnB1dF07XG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBnZXRNYXBGb3JXb3JkU2VwYXJhdG9ycyA9IG9uY2UoKGlucHV0KSA9PiBuZXcgV29yZENoYXJhY3RlckNsYXNzaWZpZXIoaW5wdXQpKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGNvbnN0IFVTVUFMX1dPUkRfU0VQQVJBVE9SUyA9ICdgfiFAIyQlXiYqKCktPStbe119XFxcXHw7OlxcJ1wiLC48Pi8/Jztcbi8qKlxuICogQ3JlYXRlIGEgd29yZCBkZWZpbml0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBiYXNlZCBvbiBkZWZhdWx0IHdvcmQgc2VwYXJhdG9ycy5cbiAqIE9wdGlvbmFsbHkgcHJvdmlkZSBhbGxvd2VkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gd29yZHMuXG4gKlxuICogVGhlIGRlZmF1bHQgd291bGQgbG9vayBsaWtlIHRoaXM6XG4gKiAvKC0/XFxkKlxcLlxcZFxcdyopfChbXlxcYFxcflxcIVxcQFxcI1xcJFxcJVxcXlxcJlxcKlxcKFxcKVxcLVxcPVxcK1xcW1xce1xcXVxcfVxcXFxcXHxcXDtcXDpcXCdcXFwiXFwsXFwuXFw8XFw+XFwvXFw/XFxzXSspL2dcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV29yZFJlZ0V4cChhbGxvd0luV29yZHMgPSAnJykge1xuICAgIGxldCBzb3VyY2UgPSAnKC0/XFxcXGQqXFxcXC5cXFxcZFxcXFx3Kil8KFteJztcbiAgICBmb3IgKGNvbnN0IHNlcCBvZiBVU1VBTF9XT1JEX1NFUEFSQVRPUlMpIHtcbiAgICAgICAgaWYgKGFsbG93SW5Xb3Jkcy5pbmRleE9mKHNlcCkgPj0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlICs9ICdcXFxcJyArIHNlcDtcbiAgICB9XG4gICAgc291cmNlICs9ICdcXFxcc10rKSc7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCAnZycpO1xufVxuLy8gY2F0Y2hlcyBudW1iZXJzIChpbmNsdWRpbmcgZmxvYXRpbmcgbnVtYmVycykgaW4gdGhlIGZpcnN0IGdyb3VwLCBhbmQgYWxwaGFudW0gaW4gdGhlIHNlY29uZFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfV09SRF9SRUdFWFAgPSBjcmVhdGVXb3JkUmVnRXhwKCk7XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbikge1xuICAgIGxldCByZXN1bHQgPSBERUZBVUxUX1dPUkRfUkVHRVhQO1xuICAgIGlmICh3b3JkRGVmaW5pdGlvbiAmJiAod29yZERlZmluaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgIGlmICghd29yZERlZmluaXRpb24uZ2xvYmFsKSB7XG4gICAgICAgICAgICBsZXQgZmxhZ3MgPSAnZyc7XG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24uaWdub3JlQ2FzZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzICs9ICdpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3b3JkRGVmaW5pdGlvbi5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24udW5pY29kZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAod29yZERlZmluaXRpb24uc291cmNlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB3b3JkRGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgX2RlZmF1bHRDb25maWcgPSB7XG4gICAgbWF4TGVuOiAxMDAwLFxuICAgIHdpbmRvd1NpemU6IDE1LFxuICAgIHRpbWVCdWRnZXQ6IDE1MFxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQsIGNvbmZpZyA9IF9kZWZhdWx0Q29uZmlnKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoID4gY29uZmlnLm1heExlbikge1xuICAgICAgICAvLyBkb24ndCB0aHJvdyBzdHJpbmdzIHRoYXQgbG9uZyBhdCB0aGUgcmVnZXhwXG4gICAgICAgIC8vIGJ1dCB1c2UgYSBzdWItc3RyaW5nIGluIHdoaWNoIGEgd29yZCBtdXN0IG9jY3VyXG4gICAgICAgIGxldCBzdGFydCA9IGNvbHVtbiAtIGNvbmZpZy5tYXhMZW4gLyAyO1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgY29sdW1uICsgY29uZmlnLm1heExlbiAvIDIpO1xuICAgICAgICByZXR1cm4gZ2V0V29yZEF0VGV4dChjb2x1bW4sIHdvcmREZWZpbml0aW9uLCB0ZXh0LCB0ZXh0T2Zmc2V0LCBjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB0MSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcG9zID0gY29sdW1uIC0gMSAtIHRleHRPZmZzZXQ7XG4gICAgbGV0IHByZXZSZWdleEluZGV4ID0gLTE7XG4gICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMTs7IGkrKykge1xuICAgICAgICAvLyBjaGVjayB0aW1lIGJ1ZGdldFxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHQxID49IGNvbmZpZy50aW1lQnVkZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIHJlZ2V4cCBzaG91bGQgc3RhcnQgbWF0Y2hpbmcsIGFsc28ga25vdyB3aGVyZSBpdFxuICAgICAgICAvLyBzaG91bGQgc3RvcCBzbyB0aGF0IHN1YnNlcXVlbnQgc2VhcmNoIGRvbid0IHJlcGVhdCBwcmV2aW91cyBzZWFyY2hlc1xuICAgICAgICBjb25zdCByZWdleEluZGV4ID0gcG9zIC0gY29uZmlnLndpbmRvd1NpemUgKiBpO1xuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSBNYXRoLm1heCgwLCByZWdleEluZGV4KTtcbiAgICAgICAgY29uc3QgdGhpc01hdGNoID0gX2ZpbmRSZWdleE1hdGNoRW5jbG9zaW5nUG9zaXRpb24od29yZERlZmluaXRpb24sIHRleHQsIHBvcywgcHJldlJlZ2V4SW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXNNYXRjaCAmJiBtYXRjaCkge1xuICAgICAgICAgICAgLy8gc3RvcDogd2UgaGF2ZSBzb21ldGhpbmdcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gdGhpc01hdGNoO1xuICAgICAgICAvLyBzdG9wOiBzZWFyY2hlZCBhdCBzdGFydFxuICAgICAgICBpZiAocmVnZXhJbmRleCA8PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2UmVnZXhJbmRleCA9IHJlZ2V4SW5kZXg7XG4gICAgfVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICB3b3JkOiBtYXRjaFswXSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIG1hdGNoLmluZGV4LFxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX2ZpbmRSZWdleE1hdGNoRW5jbG9zaW5nUG9zaXRpb24od29yZERlZmluaXRpb24sIHRleHQsIHBvcywgc3RvcFBvcykge1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAobWF0Y2ggPSB3b3JkRGVmaW5pdGlvbi5leGVjKHRleHQpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgICAgICBpZiAobWF0Y2hJbmRleCA8PSBwb3MgJiYgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID49IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3BQb3MgPiAwICYmIG1hdGNoSW5kZXggPiBzdG9wUG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgTGNzRGlmZiB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2RpZmYvZGlmZi5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuY29uc3QgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIID0gMztcbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSwgcHJldHR5KSB7XG4gICAgY29uc3QgZGlmZkFsZ28gPSBuZXcgTGNzRGlmZihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUpO1xuICAgIHJldHVybiBkaWZmQWxnby5Db21wdXRlRGlmZihwcmV0dHkpO1xufVxuY2xhc3MgTGluZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcykge1xuICAgICAgICBjb25zdCBzdGFydENvbHVtbnMgPSBbXTtcbiAgICAgICAgY29uc3QgZW5kQ29sdW1ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uc1tpXSA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xuICAgICAgICAgICAgZW5kQ29sdW1uc1tpXSA9IGdldExhc3ROb25CbGFua0NvbHVtbihsaW5lc1tpXSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLl9zdGFydENvbHVtbnMgPSBzdGFydENvbHVtbnM7XG4gICAgICAgIHRoaXMuX2VuZENvbHVtbnMgPSBlbmRDb2x1bW5zO1xuICAgIH1cbiAgICBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1lbnRzW2ldID0gdGhpcy5saW5lc1tpXS5zdWJzdHJpbmcodGhpcy5fc3RhcnRDb2x1bW5zW2ldIC0gMSwgdGhpcy5fZW5kQ29sdW1uc1tpXSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gICAgZ2V0U3RyaWN0RWxlbWVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tpbmRleF07XG4gICAgfVxuICAgIGdldFN0YXJ0TGluZU51bWJlcihpKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gICAgZ2V0RW5kTGluZU51bWJlcihpKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gICAgY3JlYXRlQ2hhclNlcXVlbmNlKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBjb25zdCBjaGFyQ29kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8PSBlbmRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fc3RhcnRDb2x1bW5zW2luZGV4XSA6IDEpO1xuICAgICAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fZW5kQ29sdW1uc1tpbmRleF0gOiBsaW5lQ29udGVudC5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0Q29sdW1uOyBjb2wgPCBlbmRDb2x1bW47IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVzW2xlbl0gPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNvbCAtIDEpO1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzW2xlbl0gPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29sdW1uc1tsZW5dID0gY29sO1xuICAgICAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhclNlcXVlbmNlKGNoYXJDb2RlcywgbGluZU51bWJlcnMsIGNvbHVtbnMpO1xuICAgIH1cbn1cbmNsYXNzIENoYXJTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoY2hhckNvZGVzLCBsaW5lTnVtYmVycywgY29sdW1ucykge1xuICAgICAgICB0aGlzLl9jaGFyQ29kZXMgPSBjaGFyQ29kZXM7XG4gICAgICAgIHRoaXMuX2xpbmVOdW1iZXJzID0gbGluZU51bWJlcnM7XG4gICAgICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xuICAgIH1cbiAgICBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJDb2RlcztcbiAgICB9XG4gICAgZ2V0U3RhcnRMaW5lTnVtYmVyKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xuICAgIH1cbiAgICBnZXRTdGFydENvbHVtbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2ldO1xuICAgIH1cbiAgICBnZXRFbmRMaW5lTnVtYmVyKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldO1xuICAgIH1cbiAgICBnZXRFbmRDb2x1bW4oaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tpXSArIDE7XG4gICAgfVxufVxuY2xhc3MgQ2hhckNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxTdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRDb2x1bW4gPSBvcmlnaW5hbEVuZENvbHVtbjtcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRDb2x1bW4gPSBtb2RpZmllZFN0YXJ0Q29sdW1uO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkRW5kQ29sdW1uO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbURpZmZDaGFuZ2UoZGlmZkNoYW5nZSwgb3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlKSB7XG4gICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRDb2x1bW47XG4gICAgICAgIGxldCBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBvcmlnaW5hbEVuZENvbHVtbjtcbiAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICBsZXQgbW9kaWZpZWRTdGFydENvbHVtbjtcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kQ29sdW1uO1xuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbiA9IDA7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW4gPSBvcmlnaW5hbENoYXJTZXF1ZW5jZS5nZXRTdGFydENvbHVtbihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbiA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVuZENvbHVtbihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0Q29sdW1uID0gbW9kaWZpZWRDaGFyU2VxdWVuY2UuZ2V0U3RhcnRDb2x1bW4oZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW4gPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbmRDb2x1bW4oZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhckNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcykge1xuICAgIGlmIChyYXdDaGFuZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiByYXdDaGFuZ2VzO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbcmF3Q2hhbmdlc1swXV07XG4gICAgbGV0IHByZXZDaGFuZ2UgPSByZXN1bHRbMF07XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VyckNoYW5nZSA9IHJhd0NoYW5nZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgLSAocHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgLSAocHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCk7XG4gICAgICAgIC8vIEJvdGggb2YgdGhlIGFib3ZlIHNob3VsZCBiZSBlcXVhbCwgYnV0IHRoZSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgbWF5IHByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHRydWVcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMZW5ndGggPSBNYXRoLm1pbihvcmlnaW5hbE1hdGNoaW5nTGVuZ3RoLCBtb2RpZmllZE1hdGNoaW5nTGVuZ3RoKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nTGVuZ3RoIDwgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgY3VycmVudCBjaGFuZ2UgaW50byB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gKGN1cnJDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGN1cnJDaGFuZ2Uub3JpZ2luYWxMZW5ndGgpIC0gcHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IChjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjdXJyQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSAtIHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjaGFuZ2VcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJDaGFuZ2UpO1xuICAgICAgICAgICAgcHJldkNoYW5nZSA9IGN1cnJDaGFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIExpbmVDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIGNoYXJDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hhckNoYW5nZXMgPSBjaGFyQ2hhbmdlcztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmUmVzdWx0KHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLCBvcmlnaW5hbExpbmVTZXF1ZW5jZSwgbW9kaWZpZWRMaW5lU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IGNoYXJDaGFuZ2VzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KSAtIDE7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpIC0gMTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMCAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIDwgMjAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA8IDIwICYmIGNvbnRpbnVlQ2hhckRpZmYoKSkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBjaGFyYWN0ZXIgY2hhbmdlcyBmb3IgZGlmZiBjaHVua3Mgb2YgYXQgbW9zdCAyMCBsaW5lcy4uLlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyU2VxdWVuY2UgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCwgZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyU2VxdWVuY2UgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCwgZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IHJhd0NoYW5nZXMgPSBjb21wdXRlRGlmZihvcmlnaW5hbENoYXJTZXF1ZW5jZSwgbW9kaWZpZWRDaGFyU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHRydWUpLmNoYW5nZXM7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHJhd0NoYW5nZXMgPSBwb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKHJhd0NoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhckNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hhckNoYW5nZXMucHVzaChDaGFyQ2hhbmdlLmNyZWF0ZUZyb21EaWZmQ2hhbmdlKHJhd0NoYW5nZXNbaV0sIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERpZmZDb21wdXRlciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0cykge1xuICAgICAgICB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzO1xuICAgICAgICB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMgPSBvcHRzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgPSBvcHRzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlO1xuICAgICAgICB0aGlzLnNob3VsZE1ha2VQcmV0dHlEaWZmID0gb3B0cy5zaG91bGRNYWtlUHJldHR5RGlmZjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExpbmVzID0gb3JpZ2luYWxMaW5lcztcbiAgICAgICAgdGhpcy5tb2RpZmllZExpbmVzID0gbW9kaWZpZWRMaW5lcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG5ldyBMaW5lU2VxdWVuY2Uob3JpZ2luYWxMaW5lcyk7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBuZXcgTGluZVNlcXVlbmNlKG1vZGlmaWVkTGluZXMpO1xuICAgICAgICB0aGlzLmNvbnRpbnVlTGluZURpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUpO1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ2hhckRpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUgPT09IDAgPyAwIDogTWF0aC5taW4ob3B0cy5tYXhDb21wdXRhdGlvblRpbWUsIDUwMDApKTsgLy8gbmV2ZXIgcnVuIGFmdGVyIDVzIGZvciBjaGFyYWN0ZXIgY2hhbmdlcy4uLlxuICAgIH1cbiAgICBjb21wdXRlRGlmZigpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMub3JpZ2luYWwubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBvcmlnaW5hbCA9PiBmYXN0IHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGlmaWVkLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogdGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kaWZpZWQubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMubW9kaWZpZWQubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBtb2RpZmllZCA9PiBmYXN0IHBhdGhcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGNvbXB1dGVEaWZmKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVMaW5lRGlmZiwgdGhpcy5zaG91bGRNYWtlUHJldHR5RGlmZik7XG4gICAgICAgIGNvbnN0IHJhd0NoYW5nZXMgPSBkaWZmUmVzdWx0LmNoYW5nZXM7XG4gICAgICAgIGNvbnN0IHF1aXRFYXJseSA9IGRpZmZSZXN1bHQucXVpdEVhcmx5O1xuICAgICAgICAvLyBUaGUgZGlmZiBpcyBhbHdheXMgY29tcHV0ZWQgd2l0aCBpZ25vcmluZyB0cmltIHdoaXRlc3BhY2VcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGdldCB0aGUgcHJldHRpZXN0IGRpZmZcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVDaGFuZ2VzLnB1c2goTGluZUNoYW5nZS5jcmVhdGVGcm9tRGlmZlJlc3VsdCh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCByYXdDaGFuZ2VzW2ldLCB0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLmNvbnRpbnVlQ2hhckRpZmYsIHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzLCB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHksXG4gICAgICAgICAgICAgICAgY2hhbmdlczogbGluZUNoYW5nZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVlZCB0byBwb3N0LXByb2Nlc3MgYW5kIGludHJvZHVjZSBjaGFuZ2VzIHdoZXJlIHRoZSB0cmltIHdoaXRlc3BhY2UgaXMgZGlmZmVyZW50XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhcmUgbG9vcGluZyBzdGFydGluZyBhdCAtMSB0byBhbHNvIGNvdmVyIHRoZSBsaW5lcyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG9yaWdpbmFsTGluZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1vZGlmaWVkTGluZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IC0xIC8qICEhISEgKi8sIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFuZ2UgPSAoaSArIDEgPCBsZW4gPyByYXdDaGFuZ2VzW2kgKyAxXSA6IG51bGwpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gKG5leHRDaGFuZ2UgPyBuZXh0Q2hhbmdlLm9yaWdpbmFsU3RhcnQgOiB0aGlzLm9yaWdpbmFsTGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RvcCA9IChuZXh0Q2hhbmdlID8gbmV4dENoYW5nZS5tb2RpZmllZFN0YXJ0IDogdGhpcy5tb2RpZmllZExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxMaW5lSW5kZXggPCBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRMaW5lSW5kZXggPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSB0aGlzLm9yaWdpbmFsTGluZXNbb3JpZ2luYWxMaW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IHRoaXMubW9kaWZpZWRMaW5lc1ttb2RpZmllZExpbmVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGxpbmVzIGRpZmZlciBvbmx5IGluIHRyaW0gd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihvcmlnaW5hbExpbmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRDb2x1bW4gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG1vZGlmaWVkTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgJiYgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChvcmlnaW5hbFN0YXJ0Q29sdW1uIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gbW9kaWZpZWRMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRTdGFydENvbHVtbiAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW4tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0Q29sdW1uID4gMSB8fCBtb2RpZmllZFN0YXJ0Q29sdW1uID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVJbmRleCArIDEsIDEsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG1vZGlmaWVkTGluZUluZGV4ICsgMSwgMSwgbW9kaWZpZWRTdGFydENvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsRW5kQ29sdW1uID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRFbmRDb2x1bW4gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTWF4Q29sdW1uID0gb3JpZ2luYWxMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZE1heENvbHVtbiA9IG1vZGlmaWVkTGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gJiYgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsRW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRFbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxDaGFyICE9PSBtb2RpZmllZENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEVuZENvbHVtbiA8IG9yaWdpbmFsTWF4Q29sdW1uIHx8IG1vZGlmaWVkRW5kQ29sdW1uIDwgbW9kaWZpZWRNYXhDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lSW5kZXggKyAxLCBvcmlnaW5hbEVuZENvbHVtbiwgb3JpZ2luYWxNYXhDb2x1bW4sIG1vZGlmaWVkTGluZUluZGV4ICsgMSwgbW9kaWZpZWRFbmRDb2x1bW4sIG1vZGlmaWVkTWF4Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVJbmRleCsrO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dENoYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGFjdHVhbCBjaGFuZ2VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5lQ2hhbmdlLmNyZWF0ZUZyb21EaWZmUmVzdWx0KHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIG5leHRDaGFuZ2UsIHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVDaGFyRGlmZiwgdGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZUluZGV4ICs9IG5leHRDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXggKz0gbmV4dENoYW5nZS5tb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVpdEVhcmx5OiBxdWl0RWFybHksXG4gICAgICAgICAgICBjaGFuZ2VzOiByZXN1bHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pKSB7XG4gICAgICAgICAgICAvLyBNZXJnZWQgaW50byBwcmV2aW91c1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFyQ2hhbmdlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICBjaGFyQ2hhbmdlcyA9IFtuZXcgQ2hhckNoYW5nZShvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbildO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkTGluZU51bWJlciwgY2hhckNoYW5nZXMpKTtcbiAgICB9XG4gICAgX21lcmdlVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikge1xuICAgICAgICBjb25zdCBsZW4gPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IHJlc3VsdFtsZW4gLSAxXTtcbiAgICAgICAgaWYgKHByZXZDaGFuZ2Uub3JpZ2luYWxFbmRMaW5lTnVtYmVyID09PSAwIHx8IHByZXZDaGFuZ2UubW9kaWZpZWRFbmRMaW5lTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB3aXRoIGluc2VydHMvZGVsZXRlc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciArIDEgPT09IG9yaWdpbmFsTGluZU51bWJlciAmJiBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEgPT09IG1vZGlmaWVkTGluZU51bWJlcikge1xuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVOdW1iZXI7XG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZU51bWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcy5wdXNoKG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbih0eHQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHR4dCk7XG4gICAgaWYgKHIgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByICsgMTtcbn1cbmZ1bmN0aW9uIGdldExhc3ROb25CbGFua0NvbHVtbih0eHQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmxhc3ROb25XaGl0ZXNwYWNlSW5kZXgodHh0KTtcbiAgICBpZiAociA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHIgKyAyO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG1heGltdW1SdW50aW1lKSB7XG4gICAgaWYgKG1heGltdW1SdW50aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgbWF4aW11bVJ1bnRpbWU7XG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vLi4vYmFzZS9jb21tb24vdXJpLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IFRva2VuaXphdGlvblJlZ2lzdHJ5IGFzIFRva2VuaXphdGlvblJlZ2lzdHJ5SW1wbCB9IGZyb20gJy4vdG9rZW5pemF0aW9uUmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgQ29kaWNvbiB9IGZyb20gJy4uLy4uL2Jhc2UvY29tbW9uL2NvZGljb25zLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbk1ldGFkYXRhIHtcbiAgICBzdGF0aWMgZ2V0TGFuZ3VhZ2VJZChtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gKG1ldGFkYXRhICYgMjU1IC8qIExBTkdVQUdFSURfTUFTSyAqLykgPj4+IDAgLyogTEFOR1VBR0VJRF9PRkZTRVQgKi87XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUb2tlblR5cGUobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChtZXRhZGF0YSAmIDc2OCAvKiBUT0tFTl9UWVBFX01BU0sgKi8pID4+PiA4IC8qIFRPS0VOX1RZUEVfT0ZGU0VUICovO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Rm9udFN0eWxlKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiAobWV0YWRhdGEgJiAxNTM2MCAvKiBGT05UX1NUWUxFX01BU0sgKi8pID4+PiAxMCAvKiBGT05UX1NUWUxFX09GRlNFVCAqLztcbiAgICB9XG4gICAgc3RhdGljIGdldEZvcmVncm91bmQobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChtZXRhZGF0YSAmIDgzNzIyMjQgLyogRk9SRUdST1VORF9NQVNLICovKSA+Pj4gMTQgLyogRk9SRUdST1VORF9PRkZTRVQgKi87XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCYWNrZ3JvdW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiAobWV0YWRhdGEgJiA0Mjg2NTc4Njg4IC8qIEJBQ0tHUk9VTkRfTUFTSyAqLykgPj4+IDIzIC8qIEJBQ0tHUk9VTkRfT0ZGU0VUICovO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xhc3NOYW1lRnJvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZvcmVncm91bmQgPSB0aGlzLmdldEZvcmVncm91bmQobWV0YWRhdGEpO1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gJ210aycgKyBmb3JlZ3JvdW5kO1xuICAgICAgICBjb25zdCBmb250U3R5bGUgPSB0aGlzLmdldEZvbnRTdHlsZShtZXRhZGF0YSk7XG4gICAgICAgIGlmIChmb250U3R5bGUgJiAxIC8qIEl0YWxpYyAqLykge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgbXRraSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDIgLyogQm9sZCAqLykge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgbXRrYic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnRTdHlsZSAmIDQgLyogVW5kZXJsaW5lICovKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBtdGt1JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9udFN0eWxlICYgOCAvKiBTdHJpa2V0aHJvdWdoICovKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBtdGtzJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5saW5lU3R5bGVGcm9tTWV0YWRhdGEobWV0YWRhdGEsIGNvbG9yTWFwKSB7XG4gICAgICAgIGNvbnN0IGZvcmVncm91bmQgPSB0aGlzLmdldEZvcmVncm91bmQobWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBmb250U3R5bGUgPSB0aGlzLmdldEZvbnRTdHlsZShtZXRhZGF0YSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBgY29sb3I6ICR7Y29sb3JNYXBbZm9yZWdyb3VuZF19O2A7XG4gICAgICAgIGlmIChmb250U3R5bGUgJiAxIC8qIEl0YWxpYyAqLykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdmb250LXN0eWxlOiBpdGFsaWM7JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9udFN0eWxlICYgMiAvKiBCb2xkICovKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ2ZvbnQtd2VpZ2h0OiBib2xkOyc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHREZWNvcmF0aW9uID0gJyc7XG4gICAgICAgIGlmIChmb250U3R5bGUgJiA0IC8qIFVuZGVybGluZSAqLykge1xuICAgICAgICAgICAgdGV4dERlY29yYXRpb24gKz0gJyB1bmRlcmxpbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb250U3R5bGUgJiA4IC8qIFN0cmlrZXRocm91Z2ggKi8pIHtcbiAgICAgICAgICAgIHRleHREZWNvcmF0aW9uICs9ICcgbGluZS10aHJvdWdoJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgdGV4dC1kZWNvcmF0aW9uOiR7dGV4dERlY29yYXRpb259O2A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGdldFByZXNlbnRhdGlvbkZyb21NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBmb3JlZ3JvdW5kID0gdGhpcy5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKTtcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gdGhpcy5nZXRGb250U3R5bGUobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9yZWdyb3VuZDogZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGl0YWxpYzogQm9vbGVhbihmb250U3R5bGUgJiAxIC8qIEl0YWxpYyAqLyksXG4gICAgICAgICAgICBib2xkOiBCb29sZWFuKGZvbnRTdHlsZSAmIDIgLyogQm9sZCAqLyksXG4gICAgICAgICAgICB1bmRlcmxpbmU6IEJvb2xlYW4oZm9udFN0eWxlICYgNCAvKiBVbmRlcmxpbmUgKi8pLFxuICAgICAgICAgICAgc3RyaWtldGhyb3VnaDogQm9vbGVhbihmb250U3R5bGUgJiA4IC8qIFN0cmlrZXRocm91Z2ggKi8pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0LCB0eXBlLCBsYW5ndWFnZSkge1xuICAgICAgICB0aGlzLl90b2tlbkJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMub2Zmc2V0ICsgJywgJyArIHRoaXMudHlwZSArICcpJztcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgVG9rZW5pemF0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVuZFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblJlc3VsdEJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVkVG9rZW5pemF0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVuZFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2VuY29kZWRUb2tlbml6YXRpb25SZXN1bHRCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZW5kU3RhdGUgPSBlbmRTdGF0ZTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtS2luZHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIE1ldGhvZCAqLywgQ29kaWNvbi5zeW1ib2xNZXRob2QpO1xuICAgIGJ5S2luZC5zZXQoMSAvKiBGdW5jdGlvbiAqLywgQ29kaWNvbi5zeW1ib2xGdW5jdGlvbik7XG4gICAgYnlLaW5kLnNldCgyIC8qIENvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDMgLyogRmllbGQgKi8sIENvZGljb24uc3ltYm9sRmllbGQpO1xuICAgIGJ5S2luZC5zZXQoNCAvKiBWYXJpYWJsZSAqLywgQ29kaWNvbi5zeW1ib2xWYXJpYWJsZSk7XG4gICAgYnlLaW5kLnNldCg1IC8qIENsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcbiAgICBieUtpbmQuc2V0KDYgLyogU3RydWN0ICovLCBDb2RpY29uLnN5bWJvbFN0cnVjdCk7XG4gICAgYnlLaW5kLnNldCg3IC8qIEludGVyZmFjZSAqLywgQ29kaWNvbi5zeW1ib2xJbnRlcmZhY2UpO1xuICAgIGJ5S2luZC5zZXQoOCAvKiBNb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcbiAgICBieUtpbmQuc2V0KDkgLyogUHJvcGVydHkgKi8sIENvZGljb24uc3ltYm9sUHJvcGVydHkpO1xuICAgIGJ5S2luZC5zZXQoMTAgLyogRXZlbnQgKi8sIENvZGljb24uc3ltYm9sRXZlbnQpO1xuICAgIGJ5S2luZC5zZXQoMTEgLyogT3BlcmF0b3IgKi8sIENvZGljb24uc3ltYm9sT3BlcmF0b3IpO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogVW5pdCAqLywgQ29kaWNvbi5zeW1ib2xVbml0KTtcbiAgICBieUtpbmQuc2V0KDEzIC8qIFZhbHVlICovLCBDb2RpY29uLnN5bWJvbFZhbHVlKTtcbiAgICBieUtpbmQuc2V0KDE1IC8qIEVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XG4gICAgYnlLaW5kLnNldCgxNCAvKiBDb25zdGFudCAqLywgQ29kaWNvbi5zeW1ib2xDb25zdGFudCk7XG4gICAgYnlLaW5kLnNldCgxNSAvKiBFbnVtICovLCBDb2RpY29uLnN5bWJvbEVudW0pO1xuICAgIGJ5S2luZC5zZXQoMTYgLyogRW51bU1lbWJlciAqLywgQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDE3IC8qIEtleXdvcmQgKi8sIENvZGljb24uc3ltYm9sS2V5d29yZCk7XG4gICAgYnlLaW5kLnNldCgyNyAvKiBTbmlwcGV0ICovLCBDb2RpY29uLnN5bWJvbFNuaXBwZXQpO1xuICAgIGJ5S2luZC5zZXQoMTggLyogVGV4dCAqLywgQ29kaWNvbi5zeW1ib2xUZXh0KTtcbiAgICBieUtpbmQuc2V0KDE5IC8qIENvbG9yICovLCBDb2RpY29uLnN5bWJvbENvbG9yKTtcbiAgICBieUtpbmQuc2V0KDIwIC8qIEZpbGUgKi8sIENvZGljb24uc3ltYm9sRmlsZSk7XG4gICAgYnlLaW5kLnNldCgyMSAvKiBSZWZlcmVuY2UgKi8sIENvZGljb24uc3ltYm9sUmVmZXJlbmNlKTtcbiAgICBieUtpbmQuc2V0KDIyIC8qIEN1c3RvbWNvbG9yICovLCBDb2RpY29uLnN5bWJvbEN1c3RvbUNvbG9yKTtcbiAgICBieUtpbmQuc2V0KDIzIC8qIEZvbGRlciAqLywgQ29kaWNvbi5zeW1ib2xGb2xkZXIpO1xuICAgIGJ5S2luZC5zZXQoMjQgLyogVHlwZVBhcmFtZXRlciAqLywgQ29kaWNvbi5zeW1ib2xUeXBlUGFyYW1ldGVyKTtcbiAgICBieUtpbmQuc2V0KDI1IC8qIFVzZXIgKi8sIENvZGljb24uYWNjb3VudCk7XG4gICAgYnlLaW5kLnNldCgyNiAvKiBJc3N1ZSAqLywgQ29kaWNvbi5pc3N1ZXMpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSWNvbihraW5kKSB7XG4gICAgICAgIGxldCBjb2RpY29uID0gYnlLaW5kLmdldChraW5kKTtcbiAgICAgICAgaWYgKCFjb2RpY29uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ05vIGNvZGljb24gZm91bmQgZm9yIENvbXBsZXRpb25JdGVtS2luZCAnICsga2luZCk7XG4gICAgICAgICAgICBjb2RpY29uID0gQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kaWNvbjtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kcy50b0ljb24gPSB0b0ljb247XG4gICAgY29uc3QgZGF0YSA9IG5ldyBNYXAoKTtcbiAgICBkYXRhLnNldCgnbWV0aG9kJywgMCAvKiBNZXRob2QgKi8pO1xuICAgIGRhdGEuc2V0KCdmdW5jdGlvbicsIDEgLyogRnVuY3Rpb24gKi8pO1xuICAgIGRhdGEuc2V0KCdjb25zdHJ1Y3RvcicsIDIgLyogQ29uc3RydWN0b3IgKi8pO1xuICAgIGRhdGEuc2V0KCdmaWVsZCcsIDMgLyogRmllbGQgKi8pO1xuICAgIGRhdGEuc2V0KCd2YXJpYWJsZScsIDQgLyogVmFyaWFibGUgKi8pO1xuICAgIGRhdGEuc2V0KCdjbGFzcycsIDUgLyogQ2xhc3MgKi8pO1xuICAgIGRhdGEuc2V0KCdzdHJ1Y3QnLCA2IC8qIFN0cnVjdCAqLyk7XG4gICAgZGF0YS5zZXQoJ2ludGVyZmFjZScsIDcgLyogSW50ZXJmYWNlICovKTtcbiAgICBkYXRhLnNldCgnbW9kdWxlJywgOCAvKiBNb2R1bGUgKi8pO1xuICAgIGRhdGEuc2V0KCdwcm9wZXJ0eScsIDkgLyogUHJvcGVydHkgKi8pO1xuICAgIGRhdGEuc2V0KCdldmVudCcsIDEwIC8qIEV2ZW50ICovKTtcbiAgICBkYXRhLnNldCgnb3BlcmF0b3InLCAxMSAvKiBPcGVyYXRvciAqLyk7XG4gICAgZGF0YS5zZXQoJ3VuaXQnLCAxMiAvKiBVbml0ICovKTtcbiAgICBkYXRhLnNldCgndmFsdWUnLCAxMyAvKiBWYWx1ZSAqLyk7XG4gICAgZGF0YS5zZXQoJ2NvbnN0YW50JywgMTQgLyogQ29uc3RhbnQgKi8pO1xuICAgIGRhdGEuc2V0KCdlbnVtJywgMTUgLyogRW51bSAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW0tbWVtYmVyJywgMTYgLyogRW51bU1lbWJlciAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW1NZW1iZXInLCAxNiAvKiBFbnVtTWVtYmVyICovKTtcbiAgICBkYXRhLnNldCgna2V5d29yZCcsIDE3IC8qIEtleXdvcmQgKi8pO1xuICAgIGRhdGEuc2V0KCdzbmlwcGV0JywgMjcgLyogU25pcHBldCAqLyk7XG4gICAgZGF0YS5zZXQoJ3RleHQnLCAxOCAvKiBUZXh0ICovKTtcbiAgICBkYXRhLnNldCgnY29sb3InLCAxOSAvKiBDb2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZpbGUnLCAyMCAvKiBGaWxlICovKTtcbiAgICBkYXRhLnNldCgncmVmZXJlbmNlJywgMjEgLyogUmVmZXJlbmNlICovKTtcbiAgICBkYXRhLnNldCgnY3VzdG9tY29sb3InLCAyMiAvKiBDdXN0b21jb2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZvbGRlcicsIDIzIC8qIEZvbGRlciAqLyk7XG4gICAgZGF0YS5zZXQoJ3R5cGUtcGFyYW1ldGVyJywgMjQgLyogVHlwZVBhcmFtZXRlciAqLyk7XG4gICAgZGF0YS5zZXQoJ3R5cGVQYXJhbWV0ZXInLCAyNCAvKiBUeXBlUGFyYW1ldGVyICovKTtcbiAgICBkYXRhLnNldCgnYWNjb3VudCcsIDI1IC8qIFVzZXIgKi8pO1xuICAgIGRhdGEuc2V0KCdpc3N1ZScsIDI2IC8qIElzc3VlICovKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgbGV0IHJlcyA9IGRhdGEuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICd1bmRlZmluZWQnICYmICFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJlcyA9IDkgLyogUHJvcGVydHkgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kcy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKENvbXBsZXRpb25JdGVtS2luZHMgfHwgKENvbXBsZXRpb25JdGVtS2luZHMgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKiBSZXR1cm4gbXVsdGlwbGUgY29tcGxldGlvbiBpdGVtcyB0byBlbmFibGUgY3ljbGluZyB0aHJvdWdoIHRoZW0uXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkV4cGxpY2l0XCJdID0gMV0gPSBcIkV4cGxpY2l0XCI7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDFdID0gXCJJbnZva2VcIjtcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDJdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIkNvbnRlbnRDaGFuZ2VcIl0gPSAzXSA9IFwiQ29udGVudENoYW5nZVwiO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kIHx8IChTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiUmVhZFwiXSA9IDFdID0gXCJSZWFkXCI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiV3JpdGVcIl0gPSAyXSA9IFwiV3JpdGVcIjtcbn0pKERvY3VtZW50SGlnaGxpZ2h0S2luZCB8fCAoRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2F0aW9uTGluayh0aGluZykge1xuICAgIHJldHVybiB0aGluZ1xuICAgICAgICAmJiBVUkkuaXNVcmkodGhpbmcudXJpKVxuICAgICAgICAmJiBSYW5nZS5pc0lSYW5nZSh0aGluZy5yYW5nZSlcbiAgICAgICAgJiYgKFJhbmdlLmlzSVJhbmdlKHRoaW5nLm9yaWdpblNlbGVjdGlvblJhbmdlKSB8fCBSYW5nZS5pc0lSYW5nZSh0aGluZy50YXJnZXRTZWxlY3Rpb25SYW5nZSkpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kcztcbihmdW5jdGlvbiAoU3ltYm9sS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIEZpbGUgKi8sIENvZGljb24uc3ltYm9sRmlsZSk7XG4gICAgYnlLaW5kLnNldCgxIC8qIE1vZHVsZSAqLywgQ29kaWNvbi5zeW1ib2xNb2R1bGUpO1xuICAgIGJ5S2luZC5zZXQoMiAvKiBOYW1lc3BhY2UgKi8sIENvZGljb24uc3ltYm9sTmFtZXNwYWNlKTtcbiAgICBieUtpbmQuc2V0KDMgLyogUGFja2FnZSAqLywgQ29kaWNvbi5zeW1ib2xQYWNrYWdlKTtcbiAgICBieUtpbmQuc2V0KDQgLyogQ2xhc3MgKi8sIENvZGljb24uc3ltYm9sQ2xhc3MpO1xuICAgIGJ5S2luZC5zZXQoNSAvKiBNZXRob2QgKi8sIENvZGljb24uc3ltYm9sTWV0aG9kKTtcbiAgICBieUtpbmQuc2V0KDYgLyogUHJvcGVydHkgKi8sIENvZGljb24uc3ltYm9sUHJvcGVydHkpO1xuICAgIGJ5S2luZC5zZXQoNyAvKiBGaWVsZCAqLywgQ29kaWNvbi5zeW1ib2xGaWVsZCk7XG4gICAgYnlLaW5kLnNldCg4IC8qIENvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDkgLyogRW51bSAqLywgQ29kaWNvbi5zeW1ib2xFbnVtKTtcbiAgICBieUtpbmQuc2V0KDEwIC8qIEludGVyZmFjZSAqLywgQ29kaWNvbi5zeW1ib2xJbnRlcmZhY2UpO1xuICAgIGJ5S2luZC5zZXQoMTEgLyogRnVuY3Rpb24gKi8sIENvZGljb24uc3ltYm9sRnVuY3Rpb24pO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogVmFyaWFibGUgKi8sIENvZGljb24uc3ltYm9sVmFyaWFibGUpO1xuICAgIGJ5S2luZC5zZXQoMTMgLyogQ29uc3RhbnQgKi8sIENvZGljb24uc3ltYm9sQ29uc3RhbnQpO1xuICAgIGJ5S2luZC5zZXQoMTQgLyogU3RyaW5nICovLCBDb2RpY29uLnN5bWJvbFN0cmluZyk7XG4gICAgYnlLaW5kLnNldCgxNSAvKiBOdW1iZXIgKi8sIENvZGljb24uc3ltYm9sTnVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDE2IC8qIEJvb2xlYW4gKi8sIENvZGljb24uc3ltYm9sQm9vbGVhbik7XG4gICAgYnlLaW5kLnNldCgxNyAvKiBBcnJheSAqLywgQ29kaWNvbi5zeW1ib2xBcnJheSk7XG4gICAgYnlLaW5kLnNldCgxOCAvKiBPYmplY3QgKi8sIENvZGljb24uc3ltYm9sT2JqZWN0KTtcbiAgICBieUtpbmQuc2V0KDE5IC8qIEtleSAqLywgQ29kaWNvbi5zeW1ib2xLZXkpO1xuICAgIGJ5S2luZC5zZXQoMjAgLyogTnVsbCAqLywgQ29kaWNvbi5zeW1ib2xOdWxsKTtcbiAgICBieUtpbmQuc2V0KDIxIC8qIEVudW1NZW1iZXIgKi8sIENvZGljb24uc3ltYm9sRW51bU1lbWJlcik7XG4gICAgYnlLaW5kLnNldCgyMiAvKiBTdHJ1Y3QgKi8sIENvZGljb24uc3ltYm9sU3RydWN0KTtcbiAgICBieUtpbmQuc2V0KDIzIC8qIEV2ZW50ICovLCBDb2RpY29uLnN5bWJvbEV2ZW50KTtcbiAgICBieUtpbmQuc2V0KDI0IC8qIE9wZXJhdG9yICovLCBDb2RpY29uLnN5bWJvbE9wZXJhdG9yKTtcbiAgICBieUtpbmQuc2V0KDI1IC8qIFR5cGVQYXJhbWV0ZXIgKi8sIENvZGljb24uc3ltYm9sVHlwZVBhcmFtZXRlcik7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JY29uKGtpbmQpIHtcbiAgICAgICAgbGV0IGljb24gPSBieUtpbmQuZ2V0KGtpbmQpO1xuICAgICAgICBpZiAoIWljb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnTm8gY29kaWNvbiBmb3VuZCBmb3IgU3ltYm9sS2luZCAnICsga2luZCk7XG4gICAgICAgICAgICBpY29uID0gQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWNvbjtcbiAgICB9XG4gICAgU3ltYm9sS2luZHMudG9JY29uID0gdG9JY29uO1xufSkoU3ltYm9sS2luZHMgfHwgKFN5bWJvbEtpbmRzID0ge30pKTtcbmV4cG9ydCBjbGFzcyBGb2xkaW5nUmFuZ2VLaW5kIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBGb2xkaW5nUmFuZ2VLaW5kfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUga2luZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBLaW5kIGZvciBmb2xkaW5nIHJhbmdlIHJlcHJlc2VudGluZyBhIGNvbW1lbnQuIFRoZSB2YWx1ZSBvZiB0aGUga2luZCBpcyAnY29tbWVudCcuXG4gKi9cbkZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCA9IG5ldyBGb2xkaW5nUmFuZ2VLaW5kKCdjb21tZW50Jyk7XG4vKipcbiAqIEtpbmQgZm9yIGZvbGRpbmcgcmFuZ2UgcmVwcmVzZW50aW5nIGEgaW1wb3J0LiBUaGUgdmFsdWUgb2YgdGhlIGtpbmQgaXMgJ2ltcG9ydHMnLlxuICovXG5Gb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSBuZXcgRm9sZGluZ1JhbmdlS2luZCgnaW1wb3J0cycpO1xuLyoqXG4gKiBLaW5kIGZvciBmb2xkaW5nIHJhbmdlIHJlcHJlc2VudGluZyByZWdpb25zIChmb3IgZXhhbXBsZSBtYXJrZWQgYnkgYCNyZWdpb25gLCBgI2VuZHJlZ2lvbmApLlxuICogVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdyZWdpb24nLlxuICovXG5Gb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9IG5ldyBGb2xkaW5nUmFuZ2VLaW5kKCdyZWdpb24nKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB2YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKG9iaikge1xuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLmlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai50aXRsZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiVHlwZVwiXSA9IDFdID0gXCJUeXBlXCI7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiUGFyYW1ldGVyXCJdID0gMl0gPSBcIlBhcmFtZXRlclwiO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgVG9rZW5pemF0aW9uUmVnaXN0cnkgPSBuZXcgVG9rZW5pemF0aW9uUmVnaXN0cnlJbXBsKCk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuLi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xuZXhwb3J0IGNsYXNzIFVpbnQ4TWF0cml4IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJvd3MgKiBjb2xzOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgfVxuICAgIGdldChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtyb3cgKiB0aGlzLmNvbHMgKyBjb2xdO1xuICAgIH1cbiAgICBzZXQocm93LCBjb2wsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RhdGFbcm93ICogdGhpcy5jb2xzICsgY29sXSA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTdGF0ZU1hY2hpbmUge1xuICAgIGNvbnN0cnVjdG9yKGVkZ2VzKSB7XG4gICAgICAgIGxldCBtYXhDaGFyQ29kZSA9IDA7XG4gICAgICAgIGxldCBtYXhTdGF0ZSA9IDAgLyogSW52YWxpZCAqLztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBbZnJvbSwgY2hDb2RlLCB0b10gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaENvZGUgPiBtYXhDaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgIG1heENoYXJDb2RlID0gY2hDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb20gPiBtYXhTdGF0ZSkge1xuICAgICAgICAgICAgICAgIG1heFN0YXRlID0gZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0byA+IG1heFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbWF4U3RhdGUgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhDaGFyQ29kZSsrO1xuICAgICAgICBtYXhTdGF0ZSsrO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBuZXcgVWludDhNYXRyaXgobWF4U3RhdGUsIG1heENoYXJDb2RlLCAwIC8qIEludmFsaWQgKi8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtmcm9tLCBjaENvZGUsIHRvXSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGVzLnNldChmcm9tLCBjaENvZGUsIHRvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuX21heENoYXJDb2RlID0gbWF4Q2hhckNvZGU7XG4gICAgfVxuICAgIG5leHRTdGF0ZShjdXJyZW50U3RhdGUsIGNoQ29kZSkge1xuICAgICAgICBpZiAoY2hDb2RlIDwgMCB8fCBjaENvZGUgPj0gdGhpcy5fbWF4Q2hhckNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEludmFsaWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5nZXQoY3VycmVudFN0YXRlLCBjaENvZGUpO1xuICAgIH1cbn1cbi8vIFN0YXRlIG1hY2hpbmUgZm9yIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gb3IgZmlsZTovL1xubGV0IF9zdGF0ZU1hY2hpbmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xuICAgIGlmIChfc3RhdGVNYWNoaW5lID09PSBudWxsKSB7XG4gICAgICAgIF9zdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKFtcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDQgLyogaCAqLywgMiAvKiBIICovXSxcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCA3MiAvKiBIICovLCAyIC8qIEggKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDEwMiAvKiBmICovLCA2IC8qIEYgKi9dLFxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcwIC8qIEYgKi8sIDYgLyogRiAqL10sXG4gICAgICAgICAgICBbMiAvKiBIICovLCAxMTYgLyogdCAqLywgMyAvKiBIVCAqL10sXG4gICAgICAgICAgICBbMiAvKiBIICovLCA4NCAvKiBUICovLCAzIC8qIEhUICovXSxcbiAgICAgICAgICAgIFszIC8qIEhUICovLCAxMTYgLyogdCAqLywgNCAvKiBIVFQgKi9dLFxuICAgICAgICAgICAgWzMgLyogSFQgKi8sIDg0IC8qIFQgKi8sIDQgLyogSFRUICovXSxcbiAgICAgICAgICAgIFs0IC8qIEhUVCAqLywgMTEyIC8qIHAgKi8sIDUgLyogSFRUUCAqL10sXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDgwIC8qIFAgKi8sIDUgLyogSFRUUCAqL10sXG4gICAgICAgICAgICBbNSAvKiBIVFRQICovLCAxMTUgLyogcyAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbNSAvKiBIVFRQICovLCA4MyAvKiBTICovLCA5IC8qIEJlZm9yZUNvbG9uICovXSxcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFs2IC8qIEYgKi8sIDEwNSAvKiBpICovLCA3IC8qIEZJICovXSxcbiAgICAgICAgICAgIFs2IC8qIEYgKi8sIDczIC8qIEkgKi8sIDcgLyogRkkgKi9dLFxuICAgICAgICAgICAgWzcgLyogRkkgKi8sIDEwOCAvKiBsICovLCA4IC8qIEZJTCAqL10sXG4gICAgICAgICAgICBbNyAvKiBGSSAqLywgNzYgLyogTCAqLywgOCAvKiBGSUwgKi9dLFxuICAgICAgICAgICAgWzggLyogRklMICovLCAxMDEgLyogZSAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbOCAvKiBGSUwgKi8sIDY5IC8qIEUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxuICAgICAgICAgICAgWzkgLyogQmVmb3JlQ29sb24gKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcbiAgICAgICAgICAgIFsxMCAvKiBBZnRlckNvbG9uICovLCA0NyAvKiBTbGFzaCAqLywgMTEgLyogQWxtb3N0VGhlcmUgKi9dLFxuICAgICAgICAgICAgWzExIC8qIEFsbW9zdFRoZXJlICovLCA0NyAvKiBTbGFzaCAqLywgMTIgLyogRW5kICovXSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xufVxubGV0IF9jbGFzc2lmaWVyID0gbnVsbDtcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XG4gICAgaWYgKF9jbGFzc2lmaWVyID09PSBudWxsKSB7XG4gICAgICAgIF9jbGFzc2lmaWVyID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBOb25lICovKTtcbiAgICAgICAgLy8gYWxsb3ctYW55LXVuaWNvZGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMgPSAnIFxcdDw+XFwnXFxcIuOAgeOAgu+9oe+9pO+8jO+8ju+8mu+8m+KAmOOAiOOAjOOAjuOAlO+8iO+8u++9m++9ou+9o++9ne+8ve+8ieOAleOAj+OAjeOAieKAme+9gO+9nuKApic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUyA9ICcuLDsnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENBTk5PVF9FTkRfV0lUSF9DSEFSQUNURVJTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfY2xhc3NpZmllci5zZXQoQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMiAvKiBDYW5ub3RFbmRJbiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9jbGFzc2lmaWVyO1xufVxuZXhwb3J0IGNsYXNzIExpbmtDb21wdXRlciB7XG4gICAgc3RhdGljIF9jcmVhdGVMaW5rKGNsYXNzaWZpZXIsIGxpbmUsIGxpbmVOdW1iZXIsIGxpbmtCZWdpbkluZGV4LCBsaW5rRW5kSW5kZXgpIHtcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IHRvIGVuZCBsaW5rIGluIGNlcnRhaW4gY2hhcmFjdGVycy4uLlxuICAgICAgICBsZXQgbGFzdEluY2x1ZGVkQ2hhckluZGV4ID0gbGlua0VuZEluZGV4IC0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgY2hDb2RlID0gbGluZS5jaGFyQ29kZUF0KGxhc3RJbmNsdWRlZENoYXJJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcbiAgICAgICAgICAgIGlmIChjaENsYXNzICE9PSAyIC8qIENhbm5vdEVuZEluICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5jbHVkZWRDaGFySW5kZXgtLTtcbiAgICAgICAgfSB3aGlsZSAobGFzdEluY2x1ZGVkQ2hhckluZGV4ID4gbGlua0JlZ2luSW5kZXgpO1xuICAgICAgICAvLyBIYW5kbGUgbGlua3MgZW5jbG9zZWQgaW4gcGFyZW5zLCBzcXVhcmUgYnJhY2tldHMgYW5kIGN1cmx5cy5cbiAgICAgICAgaWYgKGxpbmtCZWdpbkluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmVMaW5rID0gbGluZS5jaGFyQ29kZUF0KGxpbmtCZWdpbkluZGV4IC0gMSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2hhckNvZGVJbkxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcbiAgICAgICAgICAgIGlmICgoY2hhckNvZGVCZWZvcmVMaW5rID09PSA0MCAvKiBPcGVuUGFyZW4gKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSA0MSAvKiBDbG9zZVBhcmVuICovKVxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovICYmIGxhc3RDaGFyQ29kZUluTGluayA9PT0gOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovKVxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDEyMyAvKiBPcGVuQ3VybHlCcmFjZSAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDEyNSAvKiBDbG9zZUN1cmx5QnJhY2UgKi8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiApIGlmICggaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiBdIGlmIFsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiB9IGlmIHsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XG4gICAgICAgICAgICAgICAgbGFzdEluY2x1ZGVkQ2hhckluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBsaW5rQmVnaW5JbmRleCArIDEsXG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IGxpbmUuc3Vic3RyaW5nKGxpbmtCZWdpbkluZGV4LCBsYXN0SW5jbHVkZWRDaGFySW5kZXggKyAxKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcHV0ZUxpbmtzKG1vZGVsLCBzdGF0ZU1hY2hpbmUgPSBnZXRTdGF0ZU1hY2hpbmUoKSkge1xuICAgICAgICBjb25zdCBjbGFzc2lmaWVyID0gZ2V0Q2xhc3NpZmllcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpOyBpIDw9IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoaSk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgIGxldCBsaW5rQmVnaW5JbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luQ2hDb2RlID0gMDtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IDEgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBsZXQgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW5TcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGhhc09wZW5DdXJseUJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc2V0U3RhdGVNYWNoaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hDb2RlID0gbGluZS5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaENsYXNzO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MCAvKiBPcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDEgLyogQ2xvc2VQYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGhhc09wZW5QYXJlbnMgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MSAvKiBPcGVuU3F1YXJlQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblNxdWFyZUJyYWNrZXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluU3F1YXJlQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGhhc09wZW5TcXVhcmVCcmFja2V0ID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIzIC8qIE9wZW5DdXJseUJyYWNlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc09wZW5DdXJseUJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyNSAvKiBDbG9zZUN1cmx5QnJhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuQ3VybHlCcmFja2V0ID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBmb2xsb3dpbmcgdGhyZWUgcnVsZXMgbWFrZSBpdCB0aGF0ICcgb3IgXCIgb3IgYCBhcmUgYWxsb3dlZCBpbnNpZGUgbGlua3MgaWYgdGhlIGxpbmsgYmVnYW4gd2l0aCBhIGRpZmZlcmVudCBvbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzkgLyogU2luZ2xlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDM0IC8qIERvdWJsZVF1b3RlICovIHx8IGxpbmtCZWdpbkNoQ29kZSA9PT0gOTYgLyogQmFja1RpY2sgKi8pID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBEb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzkgLyogU2luZ2xlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSA5NiAvKiBCYWNrVGljayAqLykgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk2IC8qIEJhY2tUaWNrICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSAzOSAvKiBTaW5nbGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDM0IC8qIERvdWJsZVF1b3RlICovKSA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDIgLyogQXN0ZXJpc2sgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCpgIHRlcm1pbmF0ZXMgYSBsaW5rIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYCpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDQyIC8qIEFzdGVyaXNrICovKSA/IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI0IC8qIFBpcGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHxgIHRlcm1pbmF0ZXMgYSBsaW5rIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYHxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDEyNCAvKiBQaXBlICovKSA/IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzIgLyogU3BhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCBgIGFsbG93IHNwYWNlIGluIGJldHdlZW4gWyBhbmQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaW5TcXVhcmVCcmFja2V0cyA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChjaENvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ2xhc3MgPT09IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGlua0NvbXB1dGVyLl9jcmVhdGVMaW5rKGNsYXNzaWZpZXIsIGxpbmUsIGksIGxpbmtCZWdpbkluZGV4LCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEyIC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ29kZSA9PT0gOTEgLyogT3BlblNxdWFyZUJyYWNrZXQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZvciB0aGUgYXV0aG9yaXR5IHBhcnQgdG8gY29udGFpbiBpcHY2IGFkZHJlc3NlcyB3aGljaCBjb250YWluIFsgYW5kIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgdGVybWluYXRlcyBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTMgLyogQWNjZXB0ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlTWFjaGluZS5uZXh0U3RhdGUoc3RhdGUsIGNoQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBJbnZhbGlkICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0U3RhdGVNYWNoaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBTdGFydCAqLztcbiAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB3aGVyZSB0aGUgbGluayBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkNoQ29kZSA9IGNoQ29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxMyAvKiBBY2NlcHQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBsaW5rcyBjb250YWlucyBpbiB0aGUgcHJvdmlkZWRcbiAqIGRvY3VtZW50LiAqTm90ZSogdGhhdCB0aGlzIG9wZXJhdGlvbiBpcyBjb21wdXRhdGlvbmFsXG4gKiBleHBlbnNpdmUgYW5kIHNob3VsZCBub3QgcnVuIGluIHRoZSBVSSB0aHJlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGlua3MobW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbC5nZXRMaW5lQ291bnQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVua25vd24gY2FsbGVyIVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBMaW5rQ29tcHV0ZXIuY29tcHV0ZUxpbmtzKG1vZGVsKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGNsYXNzIEJhc2ljSW5wbGFjZVJlcGxhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTZXQgPSBbXG4gICAgICAgICAgICBbJ3RydWUnLCAnZmFsc2UnXSxcbiAgICAgICAgICAgIFsnVHJ1ZScsICdGYWxzZSddLFxuICAgICAgICAgICAgWydQcml2YXRlJywgJ1B1YmxpYycsICdGcmllbmQnLCAnUmVhZE9ubHknLCAnUGFydGlhbCcsICdQcm90ZWN0ZWQnLCAnV3JpdGVPbmx5J10sXG4gICAgICAgICAgICBbJ3B1YmxpYycsICdwcm90ZWN0ZWQnLCAncHJpdmF0ZSddLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBuYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlMSwgdGV4dDEsIHJhbmdlMiwgdGV4dDIsIHVwKSB7XG4gICAgICAgIGlmIChyYW5nZTEgJiYgdGV4dDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQxLCB1cCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlMiAmJiB0ZXh0Mikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kb05hdmlnYXRlVmFsdWVTZXQodGV4dDIsIHVwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQsIHVwKSB7XG4gICAgICAgIGNvbnN0IG51bWJlclJlc3VsdCA9IHRoaXMubnVtYmVyUmVwbGFjZSh0ZXh0LCB1cCk7XG4gICAgICAgIGlmIChudW1iZXJSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFJlcGxhY2UodGV4dCwgdXApO1xuICAgIH1cbiAgICBudW1iZXJSZXBsYWNlKHZhbHVlLCB1cCkge1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgdmFsdWUubGVuZ3RoIC0gKHZhbHVlLmxhc3RJbmRleE9mKCcuJykgKyAxKSk7XG4gICAgICAgIGxldCBuMSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGxldCBuMiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoIWlzTmFOKG4xKSAmJiAhaXNOYU4objIpICYmIG4xID09PSBuMikge1xuICAgICAgICAgICAgaWYgKG4xID09PSAwICYmICF1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCBkbyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vXHRcdFx0fSBlbHNlIGlmKG4xID09PSA5ICYmIHVwKSB7XG4gICAgICAgICAgICAgICAgLy9cdFx0XHRcdHJldHVybiBudWxsOyAvLyBkb24ndCBpbnNlcnQgMTAgaW50byBhIG51bWJlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbjEgPSBNYXRoLmZsb29yKG4xICogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBuMSArPSB1cCA/IHByZWNpc2lvbiA6IC1wcmVjaXNpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhuMSAvIHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRleHRSZXBsYWNlKHZhbHVlLCB1cCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVNldHNSZXBsYWNlKHRoaXMuX2RlZmF1bHRWYWx1ZVNldCwgdmFsdWUsIHVwKTtcbiAgICB9XG4gICAgdmFsdWVTZXRzUmVwbGFjZSh2YWx1ZVNldHMsIHZhbHVlLCB1cCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlU2V0cy5sZW5ndGg7IHJlc3VsdCA9PT0gbnVsbCAmJiBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmFsdWVTZXRSZXBsYWNlKHZhbHVlU2V0c1tpXSwgdmFsdWUsIHVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YWx1ZVNldFJlcGxhY2UodmFsdWVTZXQsIHZhbHVlLCB1cCkge1xuICAgICAgICBsZXQgaWR4ID0gdmFsdWVTZXQuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWR4ICs9IHVwID8gKzEgOiAtMTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gdmFsdWVTZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkeCAlPSB2YWx1ZVNldC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVTZXRbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5CYXNpY0lucGxhY2VSZXBsYWNlLklOU1RBTkNFID0gbmV3IEJhc2ljSW5wbGFjZVJlcGxhY2UoKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgZXF1YWxzIH0gZnJvbSAnLi4vLi4vYmFzZS9jb21tb24vb2JqZWN0cy5qcyc7XG4vKipcbiAqIFZlcnRpY2FsIExhbmUgaW4gdGhlIG92ZXJ2aWV3IHJ1bGVyIG9mIHRoZSBlZGl0b3IuXG4gKi9cbmV4cG9ydCB2YXIgT3ZlcnZpZXdSdWxlckxhbmU7XG4oZnVuY3Rpb24gKE92ZXJ2aWV3UnVsZXJMYW5lKSB7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJGdWxsXCJdID0gN10gPSBcIkZ1bGxcIjtcbn0pKE92ZXJ2aWV3UnVsZXJMYW5lIHx8IChPdmVydmlld1J1bGVyTGFuZSA9IHt9KSk7XG4vKipcbiAqIFBvc2l0aW9uIGluIHRoZSBtaW5pbWFwIHRvIHJlbmRlciB0aGUgZGVjb3JhdGlvbi5cbiAqL1xuZXhwb3J0IHZhciBNaW5pbWFwUG9zaXRpb247XG4oZnVuY3Rpb24gKE1pbmltYXBQb3NpdGlvbikge1xuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJJbmxpbmVcIl0gPSAxXSA9IFwiSW5saW5lXCI7XG4gICAgTWluaW1hcFBvc2l0aW9uW01pbmltYXBQb3NpdGlvbltcIkd1dHRlclwiXSA9IDJdID0gXCJHdXR0ZXJcIjtcbn0pKE1pbmltYXBQb3NpdGlvbiB8fCAoTWluaW1hcFBvc2l0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHM7XG4oZnVuY3Rpb24gKEluamVjdGVkVGV4dEN1cnNvclN0b3BzKSB7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJCb3RoXCJdID0gMF0gPSBcIkJvdGhcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJMZWZ0XCJdID0gMl0gPSBcIkxlZnRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIk5vbmVcIl0gPSAzXSA9IFwiTm9uZVwiO1xufSkoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgfHwgKEluamVjdGVkVGV4dEN1cnNvclN0b3BzID0ge30pKTtcbmV4cG9ydCBjbGFzcyBUZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNyYykge1xuICAgICAgICB0aGlzLl90ZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnNCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50YWJTaXplID0gTWF0aC5tYXgoMSwgc3JjLnRhYlNpemUgfCAwKTtcbiAgICAgICAgdGhpcy5pbmRlbnRTaXplID0gc3JjLnRhYlNpemUgfCAwO1xuICAgICAgICB0aGlzLmluc2VydFNwYWNlcyA9IEJvb2xlYW4oc3JjLmluc2VydFNwYWNlcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVPTCA9IHNyYy5kZWZhdWx0RU9MIHwgMDtcbiAgICAgICAgdGhpcy50cmltQXV0b1doaXRlc3BhY2UgPSBCb29sZWFuKHNyYy50cmltQXV0b1doaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucyA9IHNyYy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFiU2l6ZSA9PT0gb3RoZXIudGFiU2l6ZVxuICAgICAgICAgICAgJiYgdGhpcy5pbmRlbnRTaXplID09PSBvdGhlci5pbmRlbnRTaXplXG4gICAgICAgICAgICAmJiB0aGlzLmluc2VydFNwYWNlcyA9PT0gb3RoZXIuaW5zZXJ0U3BhY2VzXG4gICAgICAgICAgICAmJiB0aGlzLmRlZmF1bHRFT0wgPT09IG90aGVyLmRlZmF1bHRFT0xcbiAgICAgICAgICAgICYmIHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlID09PSBvdGhlci50cmltQXV0b1doaXRlc3BhY2VcbiAgICAgICAgICAgICYmIGVxdWFscyh0aGlzLmJyYWNrZXRQYWlyQ29sb3JpemF0aW9uT3B0aW9ucywgb3RoZXIuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5nZUV2ZW50KG5ld09wdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhYlNpemU6IHRoaXMudGFiU2l6ZSAhPT0gbmV3T3B0cy50YWJTaXplLFxuICAgICAgICAgICAgaW5kZW50U2l6ZTogdGhpcy5pbmRlbnRTaXplICE9PSBuZXdPcHRzLmluZGVudFNpemUsXG4gICAgICAgICAgICBpbnNlcnRTcGFjZXM6IHRoaXMuaW5zZXJ0U3BhY2VzICE9PSBuZXdPcHRzLmluc2VydFNwYWNlcyxcbiAgICAgICAgICAgIHRyaW1BdXRvV2hpdGVzcGFjZTogdGhpcy50cmltQXV0b1doaXRlc3BhY2UgIT09IG5ld09wdHMudHJpbUF1dG9XaGl0ZXNwYWNlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGaW5kTWF0Y2gge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuX2ZpbmRNYXRjaEJyYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkQW5ub3RhdGVkRWRpdE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaWRlbnRpZmllciwgcmFuZ2UsIHRleHQsIGZvcmNlTW92ZU1hcmtlcnMsIGlzQXV0b1doaXRlc3BhY2VFZGl0LCBfaXNUcmFja2VkKSB7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5mb3JjZU1vdmVNYXJrZXJzID0gZm9yY2VNb3ZlTWFya2VycztcbiAgICAgICAgdGhpcy5pc0F1dG9XaGl0ZXNwYWNlRWRpdCA9IGlzQXV0b1doaXRlc3BhY2VFZGl0O1xuICAgICAgICB0aGlzLl9pc1RyYWNrZWQgPSBfaXNUcmFja2VkO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihyZWdleCwgd29yZFNlcGFyYXRvcnMsIHNpbXBsZVNlYXJjaCkge1xuICAgICAgICB0aGlzLnJlZ2V4ID0gcmVnZXg7XG4gICAgICAgIHRoaXMud29yZFNlcGFyYXRvcnMgPSB3b3JkU2VwYXJhdG9ycztcbiAgICAgICAgdGhpcy5zaW1wbGVTZWFyY2ggPSBzaW1wbGVTZWFyY2g7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcGx5RWRpdHNSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJldmVyc2VFZGl0cywgY2hhbmdlcywgdHJpbUF1dG9XaGl0ZXNwYWNlTGluZU51bWJlcnMpIHtcbiAgICAgICAgdGhpcy5yZXZlcnNlRWRpdHMgPSByZXZlcnNlRWRpdHM7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlTGluZU51bWJlcnMgPSB0cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycztcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU3luY2hyb25pemVNb2RlbChtb2RlbCkge1xuICAgIHJldHVybiAoIW1vZGVsLmlzVG9vTGFyZ2VGb3JTeW5jaW5nKCkgJiYgIW1vZGVsLmlzRm9yU2ltcGxlV2lkZ2V0KTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgc3BsaXRMaW5lcyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyIH0gZnJvbSAnLi9wcmVmaXhTdW1Db21wdXRlci5qcyc7XG5leHBvcnQgY2xhc3MgTWlycm9yVGV4dE1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIGxpbmVzLCBlb2wsIHZlcnNpb25JZCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuX2VvbCA9IGVvbDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gdmVyc2lvbklkO1xuICAgICAgICB0aGlzLl9saW5lU3RhcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fbGluZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uSWQ7XG4gICAgfVxuICAgIGdldFRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IHRoaXMuX2xpbmVzLmpvaW4odGhpcy5fZW9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVGV4dFZhbHVlO1xuICAgIH1cbiAgICBvbkV2ZW50cyhlKSB7XG4gICAgICAgIGlmIChlLmVvbCAmJiBlLmVvbCAhPT0gdGhpcy5fZW9sKSB7XG4gICAgICAgICAgICB0aGlzLl9lb2wgPSBlLmVvbDtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBteSBsaW5lc1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZS5jaGFuZ2VzO1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2NlcHREZWxldGVSYW5nZShjaGFuZ2UucmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5fYWNjZXB0SW5zZXJ0VGV4dChuZXcgUG9zaXRpb24oY2hhbmdlLnJhbmdlLnN0YXJ0TGluZU51bWJlciwgY2hhbmdlLnJhbmdlLnN0YXJ0Q29sdW1uKSwgY2hhbmdlLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZlcnNpb25JZCA9IGUudmVyc2lvbklkO1xuICAgICAgICB0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBfZW5zdXJlTGluZVN0YXJ0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBlb2xMZW5ndGggPSB0aGlzLl9lb2wubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGluZXNMZW5ndGggPSB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBsaW5lU3RhcnRWYWx1ZXMgPSBuZXcgVWludDMyQXJyYXkobGluZXNMZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0VmFsdWVzW2ldID0gdGhpcy5fbGluZXNbaV0ubGVuZ3RoICsgZW9sTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG5ldyBQcmVmaXhTdW1Db21wdXRlcihsaW5lU3RhcnRWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbCBjaGFuZ2VzIHRvIGEgbGluZSdzIHRleHQgZ28gdGhyb3VnaCB0aGlzIG1ldGhvZFxuICAgICAqL1xuICAgIF9zZXRMaW5lVGV4dChsaW5lSW5kZXgsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xpbmVzW2xpbmVJbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLnNldFZhbHVlKGxpbmVJbmRleCwgdGhpcy5fbGluZXNbbGluZUluZGV4XS5sZW5ndGggKyB0aGlzLl9lb2wubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWNjZXB0RGVsZXRlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRlbGV0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSB0ZXh0IG9uIHRoZSBhZmZlY3RlZCBsaW5lXG4gICAgICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKVxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlIHJlbWFpbmluZyB0ZXh0IG9uIGxhc3QgbGluZSBhbmQgYXBwZW5kIGl0IHRvIHJlbWFpbmluZyB0ZXh0IG9uIGZpcnN0IGxpbmVcbiAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcbiAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2UuZW5kTGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5lbmRDb2x1bW4gLSAxKSk7XG4gICAgICAgIC8vIERlbGV0ZSBtaWRkbGUgbGluZXNcbiAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2UuZW5kTGluZU51bWJlciAtIHJhbmdlLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cy5yZW1vdmVWYWx1ZXMocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWNjZXB0SW5zZXJ0VGV4dChwb3NpdGlvbiwgaW5zZXJ0VGV4dCkge1xuICAgICAgICBpZiAoaW5zZXJ0VGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gaW5zZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zZXJ0TGluZXMgPSBzcGxpdExpbmVzKGluc2VydFRleHQpO1xuICAgICAgICBpZiAoaW5zZXJ0TGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRpbmcgdGV4dCBvbiBvbmUgbGluZVxuICAgICAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocG9zaXRpb24ubGluZU51bWJlciAtIDEsIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uIC0gMSlcbiAgICAgICAgICAgICAgICArIGluc2VydExpbmVzWzBdXG4gICAgICAgICAgICAgICAgKyB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbiAtIDEpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgb3ZlcmZsb3dpbmcgdGV4dCBmcm9tIGZpcnN0IGxpbmUgdG8gdGhlIGVuZCBvZiB0ZXh0IHRvIGluc2VydFxuICAgICAgICBpbnNlcnRMaW5lc1tpbnNlcnRMaW5lcy5sZW5ndGggLSAxXSArPSB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbiAtIDEpO1xuICAgICAgICAvLyBEZWxldGUgb3ZlcmZsb3dpbmcgdGV4dCBmcm9tIGZpcnN0IGxpbmUgYW5kIGluc2VydCB0ZXh0IG9uIGZpcnN0IGxpbmVcbiAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocG9zaXRpb24ubGluZU51bWJlciAtIDEsIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uIC0gMSlcbiAgICAgICAgICAgICsgaW5zZXJ0TGluZXNbMF0pO1xuICAgICAgICAvLyBJbnNlcnQgbmV3IGxpbmVzICYgc3RvcmUgbGVuZ3Roc1xuICAgICAgICBjb25zdCBuZXdMZW5ndGhzID0gbmV3IFVpbnQzMkFycmF5KGluc2VydExpbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluc2VydExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5zcGxpY2UocG9zaXRpb24ubGluZU51bWJlciArIGkgLSAxLCAwLCBpbnNlcnRMaW5lc1tpXSk7XG4gICAgICAgICAgICBuZXdMZW5ndGhzW2kgLSAxXSA9IGluc2VydExpbmVzW2ldLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLmluc2VydFZhbHVlcyhwb3NpdGlvbi5saW5lTnVtYmVyLCBuZXdMZW5ndGhzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgYXJyYXlJbnNlcnQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgdG9VaW50MzIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91aW50LmpzJztcbmV4cG9ydCBjbGFzcyBQcmVmaXhTdW1Db21wdXRlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4ID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IC0xO1xuICAgIH1cbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydFZhbHVlcykge1xuICAgICAgICBpbnNlcnRJbmRleCA9IHRvVWludDMyKGluc2VydEluZGV4KTtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xuICAgICAgICBjb25zdCBpbnNlcnRWYWx1ZXNMZW4gPSBpbnNlcnRWYWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoaW5zZXJ0VmFsdWVzTGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkob2xkVmFsdWVzLmxlbmd0aCArIGluc2VydFZhbHVlc0xlbik7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgaW5zZXJ0SW5kZXgpLCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheShpbnNlcnRJbmRleCksIGluc2VydEluZGV4ICsgaW5zZXJ0VmFsdWVzTGVuKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KGluc2VydFZhbHVlcywgaW5zZXJ0SW5kZXgpO1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBpbnNlcnRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bS5zZXQob2xkUHJlZml4U3VtLnN1YmFycmF5KDAsIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gdG9VaW50MzIoaW5kZXgpO1xuICAgICAgICB2YWx1ZSA9IHRvVWludDMyKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzW2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1vdmVWYWx1ZXMoc3RhcnRJbmRleCwgY291bnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRvVWludDMyKHN0YXJ0SW5kZXgpO1xuICAgICAgICBjb3VudCA9IHRvVWludDMyKGNvdW50KTtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSBvbGRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4Q291bnQgPSBvbGRWYWx1ZXMubGVuZ3RoIC0gc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGNvdW50ID49IG1heENvdW50KSB7XG4gICAgICAgICAgICBjb3VudCA9IG1heENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggLSBjb3VudCk7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgc3RhcnRJbmRleCksIDApO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KHN0YXJ0SW5kZXggKyBjb3VudCksIHN0YXJ0SW5kZXgpO1xuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCAtIDEgPCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IHN0YXJ0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldFRvdGFsU3VtKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJlZml4U3VtKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGZpcnN0IGBpbmRleCArIDFgIG1hbnkgaXRlbXMuXG4gICAgICogQHJldHVybnMgYFNVTSgwIDw9IGogPD0gaW5kZXgsIHZhbHVlc1tqXSlgLlxuICAgICAqL1xuICAgIGdldFByZWZpeFN1bShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHRvVWludDMyKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByZWZpeFN1bShpbmRleCk7XG4gICAgfVxuICAgIF9nZXRQcmVmaXhTdW0oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDw9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDE7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVswXSA9IHRoaXMudmFsdWVzWzBdO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVtpXSA9IHRoaXMucHJlZml4U3VtW2kgLSAxXSArIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IE1hdGgubWF4KHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhTdW1baW5kZXhdO1xuICAgIH1cbiAgICBnZXRJbmRleE9mKHN1bSkge1xuICAgICAgICBzdW0gPSBNYXRoLmZsb29yKHN1bSk7XG4gICAgICAgIC8vIENvbXB1dGUgYWxsIHN1bXMgKHRvIGdldCBhIGZ1bGx5IHZhbGlkIHByZWZpeFN1bSlcbiAgICAgICAgdGhpcy5nZXRUb3RhbFN1bSgpO1xuICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgbGV0IGhpZ2ggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgbWlkID0gMDtcbiAgICAgICAgbGV0IG1pZFN0b3AgPSAwO1xuICAgICAgICBsZXQgbWlkU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgLyAyKSB8IDA7XG4gICAgICAgICAgICBtaWRTdG9wID0gdGhpcy5wcmVmaXhTdW1bbWlkXTtcbiAgICAgICAgICAgIG1pZFN0YXJ0ID0gbWlkU3RvcCAtIHRoaXMudmFsdWVzW21pZF07XG4gICAgICAgICAgICBpZiAoc3VtIDwgbWlkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1bSA+PSBtaWRTdG9wKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChtaWQsIHN1bSAtIG1pZFN0YXJ0KTtcbiAgICB9XG59XG4vKipcbiAqIHtAbGluayBnZXRJbmRleE9mfSBoYXMgYW4gYW1vcnRpemVkIHJ1bnRpbWUgY29tcGxleGl0eSBvZiBPKDEpLlxuICpcbiAqICh7QGxpbmsgUHJlZml4U3VtQ29tcHV0ZXIuZ2V0SW5kZXhPZn0gaXMganVzdCAgTyhsb2cgbikpXG4qL1xuZXhwb3J0IGNsYXNzIENvbnN0YW50VGltZVByZWZpeFN1bUNvbXB1dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbGlkRW5kSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcHJlZml4U3VtID0gW107XG4gICAgICAgIHRoaXMuX2luZGV4QnlTdW0gPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgU1VNKDAgPD0gaiA8IHZhbHVlcy5sZW5ndGgsIHZhbHVlc1tqXSlcbiAgICAgKi9cbiAgICBnZXRUb3RhbFN1bSgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4QnlTdW0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGZpcnN0IGBjb3VudGAgbWFueSBpdGVtcy5cbiAgICAgKiBAcmV0dXJucyBgU1VNKDAgPD0gaiA8IGNvdW50LCB2YWx1ZXNbal0pYC5cbiAgICAgKi9cbiAgICBnZXRQcmVmaXhTdW0oY291bnQpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4U3VtW2NvdW50IC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGByZXN1bHRgLCBzdWNoIHRoYXQgYGdldFByZWZpeFN1bShyZXN1bHQuaW5kZXgpICsgcmVzdWx0LnJlbWFpbmRlciA9IHN1bWBcbiAgICAgKi9cbiAgICBnZXRJbmRleE9mKHN1bSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZCgpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9pbmRleEJ5U3VtW3N1bV07XG4gICAgICAgIGNvbnN0IHZpZXdMaW5lc0Fib3ZlID0gaWR4ID4gMCA/IHRoaXMuX3ByZWZpeFN1bVtpZHggLSAxXSA6IDA7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChpZHgsIHN1bSAtIHZpZXdMaW5lc0Fib3ZlKTtcbiAgICB9XG4gICAgcmVtb3ZlVmFsdWVzKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGUoc3RhcnQpO1xuICAgIH1cbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydEFycikge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheUluc2VydCh0aGlzLl92YWx1ZXMsIGluc2VydEluZGV4LCBpbnNlcnRBcnIpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKGluc2VydEluZGV4KTtcbiAgICB9XG4gICAgX2ludmFsaWRhdGUoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWxpZEVuZEluZGV4ID0gTWF0aC5taW4odGhpcy5fdmFsaWRFbmRJbmRleCwgaW5kZXggLSAxKTtcbiAgICB9XG4gICAgX2Vuc3VyZVZhbGlkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl92YWxpZEVuZEluZGV4ICsgMSwgbGVuID0gdGhpcy5fdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHN1bUFib3ZlID0gaSA+IDAgPyB0aGlzLl9wcmVmaXhTdW1baSAtIDFdIDogMDtcbiAgICAgICAgICAgIHRoaXMuX3ByZWZpeFN1bVtpXSA9IHN1bUFib3ZlICsgdmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleEJ5U3VtW3N1bUFib3ZlICsgal0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRyaW0gdGhpbmdzXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bS5sZW5ndGggPSB0aGlzLl92YWx1ZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9pbmRleEJ5U3VtLmxlbmd0aCA9IHRoaXMuX3ByZWZpeFN1bVt0aGlzLl9wcmVmaXhTdW0ubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIG1hcmsgYXMgdmFsaWRcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbGlkRW5kSW5kZXggPSB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gbm8gY2hhbmdlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKGluZGV4KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJlZml4U3VtSW5kZXhPZlJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoaW5kZXgsIHJlbWFpbmRlcikge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xuICAgICAgICB0aGlzLl9wcmVmaXhTdW1JbmRleE9mUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yZW1haW5kZXIgPSByZW1haW5kZXI7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0TWFwRm9yV29yZFNlcGFyYXRvcnMgfSBmcm9tICcuLi9jb3JlL3dvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgRmluZE1hdGNoLCBTZWFyY2hEYXRhIH0gZnJvbSAnLi4vbW9kZWwuanMnO1xuY29uc3QgTElNSVRfRklORF9DT1VOVCA9IDk5OTtcbmV4cG9ydCBjbGFzcyBTZWFyY2hQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKHNlYXJjaFN0cmluZywgaXNSZWdleCwgbWF0Y2hDYXNlLCB3b3JkU2VwYXJhdG9ycykge1xuICAgICAgICB0aGlzLnNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZztcbiAgICAgICAgdGhpcy5pc1JlZ2V4ID0gaXNSZWdleDtcbiAgICAgICAgdGhpcy5tYXRjaENhc2UgPSBtYXRjaENhc2U7XG4gICAgICAgIHRoaXMud29yZFNlcGFyYXRvcnMgPSB3b3JkU2VwYXJhdG9ycztcbiAgICB9XG4gICAgcGFyc2VTZWFyY2hSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5zZWFyY2hTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgUmVnRXhwIG91dCBvZiB0aGUgcGFyYW1zXG4gICAgICAgIGxldCBtdWx0aWxpbmU7XG4gICAgICAgIGlmICh0aGlzLmlzUmVnZXgpIHtcbiAgICAgICAgICAgIG11bHRpbGluZSA9IGlzTXVsdGlsaW5lUmVnZXhTb3VyY2UodGhpcy5zZWFyY2hTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXVsdGlsaW5lID0gKHRoaXMuc2VhcmNoU3RyaW5nLmluZGV4T2YoJ1xcbicpID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWdleCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZWdleCA9IHN0cmluZ3MuY3JlYXRlUmVnRXhwKHRoaXMuc2VhcmNoU3RyaW5nLCB0aGlzLmlzUmVnZXgsIHtcbiAgICAgICAgICAgICAgICBtYXRjaENhc2U6IHRoaXMubWF0Y2hDYXNlLFxuICAgICAgICAgICAgICAgIHdob2xlV29yZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVuaWNvZGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVnZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW5Vc2VTaW1wbGVTZWFyY2ggPSAoIXRoaXMuaXNSZWdleCAmJiAhbXVsdGlsaW5lKTtcbiAgICAgICAgaWYgKGNhblVzZVNpbXBsZVNlYXJjaCAmJiB0aGlzLnNlYXJjaFN0cmluZy50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLnNlYXJjaFN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAvLyBjYXNpbmcgbWlnaHQgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIGNhblVzZVNpbXBsZVNlYXJjaCA9IHRoaXMubWF0Y2hDYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoRGF0YShyZWdleCwgdGhpcy53b3JkU2VwYXJhdG9ycyA/IGdldE1hcEZvcldvcmRTZXBhcmF0b3JzKHRoaXMud29yZFNlcGFyYXRvcnMpIDogbnVsbCwgY2FuVXNlU2ltcGxlU2VhcmNoID8gdGhpcy5zZWFyY2hTdHJpbmcgOiBudWxsKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNdWx0aWxpbmVSZWdleFNvdXJjZShzZWFyY2hTdHJpbmcpIHtcbiAgICBpZiAoIXNlYXJjaFN0cmluZyB8fCBzZWFyY2hTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNlYXJjaFN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzZWFyY2hTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSA9PT0gOTIgLyogQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIHRvIG5leHQgY2hhclxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGVuZHMgd2l0aCBhIFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hDb2RlID0gc2VhcmNoU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAobmV4dENoQ29kZSA9PT0gMTEwIC8qIG4gKi8gfHwgbmV4dENoQ29kZSA9PT0gMTE0IC8qIHIgKi8gfHwgbmV4dENoQ29kZSA9PT0gODcgLyogVyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaW5kTWF0Y2gocmFuZ2UsIHJhd01hdGNoZXMsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgaWYgKCFjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gbmV3IEZpbmRNYXRjaChyYW5nZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmF3TWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXRjaGVzW2ldID0gcmF3TWF0Y2hlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaW5kTWF0Y2gocmFuZ2UsIG1hdGNoZXMpO1xufVxuY2xhc3MgTGluZUZlZWRDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxpbmVGZWVkc09mZnNldHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVGZWVkc09mZnNldHNMZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgdGV4dExlbiA9IHRleHQubGVuZ3RoOyBpIDwgdGV4dExlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBMaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGxpbmVGZWVkc09mZnNldHNbbGluZUZlZWRzT2Zmc2V0c0xlbisrXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGluZUZlZWRzT2Zmc2V0cyA9IGxpbmVGZWVkc09mZnNldHM7XG4gICAgfVxuICAgIGZpbmRMaW5lRmVlZENvdW50QmVmb3JlT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBjb25zdCBsaW5lRmVlZHNPZmZzZXRzID0gdGhpcy5fbGluZUZlZWRzT2Zmc2V0cztcbiAgICAgICAgbGV0IG1pbiA9IDA7XG4gICAgICAgIGxldCBtYXggPSBsaW5lRmVlZHNPZmZzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChtYXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBubyBsaW5lIGZlZWRzXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDw9IGxpbmVGZWVkc09mZnNldHNbMF0pIHtcbiAgICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBsaW5lIGZlZWRcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IG1pbiArICgobWF4IC0gbWluKSAvIDIgPj4gMCk7XG4gICAgICAgICAgICBpZiAobGluZUZlZWRzT2Zmc2V0c1ttaWRdID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZUZlZWRzT2Zmc2V0c1ttaWQgKyAxXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluZ28hXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiArIDE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRleHRNb2RlbFNlYXJjaCB7XG4gICAgc3RhdGljIGZpbmRNYXRjaGVzKG1vZGVsLCBzZWFyY2hQYXJhbXMsIHNlYXJjaFJhbmdlLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCBzZWFyY2hEYXRhID0gc2VhcmNoUGFyYW1zLnBhcnNlU2VhcmNoUmVxdWVzdCgpO1xuICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoRGF0YS5yZWdleC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRNYXRjaGVzTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE1hdGNoZXNMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hSYW5nZSwgc2VhcmNoRGF0YSwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aWxpbmUgc2VhcmNoIGFsd2F5cyBleGVjdXRlcyBvbiB0aGUgbGluZXMgY29uY2F0ZW5hdGVkIHdpdGggXFxuLlxuICAgICAqIFdlIG11c3QgdGhlcmVmb3JlIGNvbXBlbnNhdGUgZm9yIHRoZSBjb3VudCBvZiBcXG4gaW4gY2FzZSB0aGUgbW9kZWwgaXMgQ1JMRlxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZShtb2RlbCwgZGVsdGFPZmZzZXQsIHRleHQsIGxmQ291bnRlciwgbWF0Y2hJbmRleCwgbWF0Y2gwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZnNldDtcbiAgICAgICAgbGV0IGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaCA9IDA7XG4gICAgICAgIGlmIChsZkNvdW50ZXIpIHtcbiAgICAgICAgICAgIGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaCA9IGxmQ291bnRlci5maW5kTGluZUZlZWRDb3VudEJlZm9yZU9mZnNldChtYXRjaEluZGV4KTtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZGVsdGFPZmZzZXQgKyBtYXRjaEluZGV4ICsgbGluZUZlZWRDb3VudEJlZm9yZU1hdGNoIC8qIGFkZCBhcyBtYW55IFxcciBhcyB0aGVyZSB3ZXJlIFxcbiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZGVsdGFPZmZzZXQgKyBtYXRjaEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRPZmZzZXQ7XG4gICAgICAgIGlmIChsZkNvdW50ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVGZWVkQ291bnRCZWZvcmVFbmRPZk1hdGNoID0gbGZDb3VudGVyLmZpbmRMaW5lRmVlZENvdW50QmVmb3JlT2Zmc2V0KG1hdGNoSW5kZXggKyBtYXRjaDAubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVGZWVkQ291bnRJbk1hdGNoID0gbGluZUZlZWRDb3VudEJlZm9yZUVuZE9mTWF0Y2ggLSBsaW5lRmVlZENvdW50QmVmb3JlTWF0Y2g7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIG1hdGNoMC5sZW5ndGggKyBsaW5lRmVlZENvdW50SW5NYXRjaCAvKiBhZGQgYXMgbWFueSBcXHIgYXMgdGhlcmUgd2VyZSBcXG4gKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIG1hdGNoMC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IG1vZGVsLmdldFBvc2l0aW9uQXQoZW5kT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydFBvc2l0aW9uLmxpbmVOdW1iZXIsIHN0YXJ0UG9zaXRpb24uY29sdW1uLCBlbmRQb3NpdGlvbi5saW5lTnVtYmVyLCBlbmRQb3NpdGlvbi5jb2x1bW4pO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE1hdGNoZXNNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFJhbmdlLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChzZWFyY2hSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpO1xuICAgICAgICAvLyBXZSBhbHdheXMgZXhlY3V0ZSBtdWx0aWxpbmUgc2VhcmNoIG92ZXIgdGhlIGxpbmVzIGpvaW5lZCB3aXRoIFxcblxuICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IHRoYXQgXFxuIHdpbGwgbWF0Y2ggdGhlIEVPTCBmb3IgYm90aCBDUkxGIGFuZCBMRiBtb2RlbHNcbiAgICAgICAgLy8gV2UgY29tcGVuc2F0ZSBmb3Igb2Zmc2V0IGVycm9ycyBpbiBgX2dldE11bHRpbGluZU1hdGNoUmFuZ2VgXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2Uoc2VhcmNoUmFuZ2UsIDEgLyogTEYgKi8pO1xuICAgICAgICBjb25zdCBsZkNvdW50ZXIgPSAobW9kZWwuZ2V0RU9MKCkgPT09ICdcXHJcXG4nID8gbmV3IExpbmVGZWVkQ291bnRlcih0ZXh0KSA6IG51bGwpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgIHdoaWxlICgobSA9IHNlYXJjaGVyLm5leHQodGV4dCkpKSB7XG4gICAgICAgICAgICByZXN1bHRbY291bnRlcisrXSA9IGNyZWF0ZUZpbmRNYXRjaCh0aGlzLl9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlKG1vZGVsLCBkZWx0YU9mZnNldCwgdGV4dCwgbGZDb3VudGVyLCBtLmluZGV4LCBtWzBdKSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIF9kb0ZpbmRNYXRjaGVzTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoUmFuZ2UsIHNlYXJjaERhdGEsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0TGVuID0gMDtcbiAgICAgICAgLy8gRWFybHkgY2FzZSBmb3IgYSBzZWFyY2ggcmFuZ2UgdGhhdCBzdGFydHMgJiBzdG9wcyBvbiB0aGUgc2FtZSBsaW5lIG51bWJlclxuICAgICAgICBpZiAoc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSBzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKS5zdWJzdHJpbmcoc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCBzZWFyY2hSYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHRleHQsIHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciwgc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb2xsZWN0IHJlc3VsdHMgZnJvbSBmaXJzdCBsaW5lXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIpLnN1YnN0cmluZyhzZWFyY2hSYW5nZS5zdGFydENvbHVtbiAtIDEpO1xuICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCB0ZXh0LCBzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIsIHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgLy8gQ29sbGVjdCByZXN1bHRzIGZyb20gbWlkZGxlIGxpbmVzXG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSBzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIgKyAxOyBsaW5lTnVtYmVyIDwgc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlciAmJiByZXN1bHRMZW4gPCBsaW1pdFJlc3VsdENvdW50OyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIG1vZGVsLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpLCBsaW5lTnVtYmVyLCAwLCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbGxlY3QgcmVzdWx0cyBmcm9tIGxhc3QgbGluZVxuICAgICAgICBpZiAocmVzdWx0TGVuIDwgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIpLnN1YnN0cmluZygwLCBzZWFyY2hSYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgIHJlc3VsdExlbiA9IHRoaXMuX2ZpbmRNYXRjaGVzSW5MaW5lKHNlYXJjaERhdGEsIHRleHQsIHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIsIDAsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIF9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCB0ZXh0LCBsaW5lTnVtYmVyLCBkZWx0YU9mZnNldCwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgIGNvbnN0IHdvcmRTZXBhcmF0b3JzID0gc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycztcbiAgICAgICAgaWYgKCFjYXB0dXJlTWF0Y2hlcyAmJiBzZWFyY2hEYXRhLnNpbXBsZVNlYXJjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoU3RyaW5nID0gc2VhcmNoRGF0YS5zaW1wbGVTZWFyY2g7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hTdHJpbmdMZW4gPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGxhc3RNYXRjaEluZGV4ID0gLXNlYXJjaFN0cmluZ0xlbjtcbiAgICAgICAgICAgIHdoaWxlICgobGFzdE1hdGNoSW5kZXggPSB0ZXh0LmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBsYXN0TWF0Y2hJbmRleCArIHNlYXJjaFN0cmluZ0xlbikpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghd29yZFNlcGFyYXRvcnMgfHwgaXNWYWxpZE1hdGNoKHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBsYXN0TWF0Y2hJbmRleCwgc2VhcmNoU3RyaW5nTGVuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IEZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbGFzdE1hdGNoSW5kZXggKyAxICsgZGVsdGFPZmZzZXQsIGxpbmVOdW1iZXIsIGxhc3RNYXRjaEluZGV4ICsgMSArIHNlYXJjaFN0cmluZ0xlbiArIGRlbHRhT2Zmc2V0KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBuZXcgU2VhcmNoZXIoc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycywgc2VhcmNoRGF0YS5yZWdleCk7XG4gICAgICAgIGxldCBtO1xuICAgICAgICAvLyBSZXNldCByZWdleCB0byBzZWFyY2ggZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtID0gc2VhcmNoZXIubmV4dCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEgKyBkZWx0YU9mZnNldCwgbGluZU51bWJlciwgbS5pbmRleCArIDEgKyBtWzBdLmxlbmd0aCArIGRlbHRhT2Zmc2V0KSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZW4gPj0gbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobSk7XG4gICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kTmV4dE1hdGNoKG1vZGVsLCBzZWFyY2hQYXJhbXMsIHNlYXJjaFN0YXJ0LCBjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBzZWFyY2hEYXRhID0gc2VhcmNoUGFyYW1zLnBhcnNlU2VhcmNoUmVxdWVzdCgpO1xuICAgICAgICBpZiAoIXNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpO1xuICAgICAgICBpZiAoc2VhcmNoRGF0YS5yZWdleC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmROZXh0TWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmROZXh0TWF0Y2hMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICB9XG4gICAgc3RhdGljIF9kb0ZpbmROZXh0TWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoVGV4dFN0YXJ0ID0gbmV3IFBvc2l0aW9uKHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIsIDEpO1xuICAgICAgICBjb25zdCBkZWx0YU9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHNlYXJjaFRleHRTdGFydCk7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICAvLyBXZSBhbHdheXMgZXhlY3V0ZSBtdWx0aWxpbmUgc2VhcmNoIG92ZXIgdGhlIGxpbmVzIGpvaW5lZCB3aXRoIFxcblxuICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IHRoYXQgXFxuIHdpbGwgbWF0Y2ggdGhlIEVPTCBmb3IgYm90aCBDUkxGIGFuZCBMRiBtb2RlbHNcbiAgICAgICAgLy8gV2UgY29tcGVuc2F0ZSBmb3Igb2Zmc2V0IGVycm9ycyBpbiBgX2dldE11bHRpbGluZU1hdGNoUmFuZ2VgXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3IFJhbmdlKHNlYXJjaFRleHRTdGFydC5saW5lTnVtYmVyLCBzZWFyY2hUZXh0U3RhcnQuY29sdW1uLCBsaW5lQ291bnQsIG1vZGVsLmdldExpbmVNYXhDb2x1bW4obGluZUNvdW50KSksIDEgLyogTEYgKi8pO1xuICAgICAgICBjb25zdCBsZkNvdW50ZXIgPSAobW9kZWwuZ2V0RU9MKCkgPT09ICdcXHJcXG4nID8gbmV3IExpbmVGZWVkQ291bnRlcih0ZXh0KSA6IG51bGwpO1xuICAgICAgICBzZWFyY2hlci5yZXNldChzZWFyY2hTdGFydC5jb2x1bW4gLSAxKTtcbiAgICAgICAgbGV0IG0gPSBzZWFyY2hlci5uZXh0KHRleHQpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbmRNYXRjaCh0aGlzLl9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlKG1vZGVsLCBkZWx0YU9mZnNldCwgdGV4dCwgbGZDb3VudGVyLCBtLmluZGV4LCBtWzBdKSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2hTdGFydC5saW5lTnVtYmVyICE9PSAxIHx8IHNlYXJjaFN0YXJ0LmNvbHVtbiAhPT0gMSkge1xuICAgICAgICAgICAgLy8gVHJ5IGFnYWluIGZyb20gdGhlIHRvcFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE5leHRNYXRjaE11bHRpbGluZShtb2RlbCwgbmV3IFBvc2l0aW9uKDEsIDEpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZE5leHRNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZU51bWJlciA9IHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXI7XG4gICAgICAgIC8vIExvb2sgaW4gZmlyc3QgbGluZVxuICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX2ZpbmRGaXJzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBzdGFydExpbmVOdW1iZXIsIHNlYXJjaFN0YXJ0LmNvbHVtbiwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVJbmRleCA9IChzdGFydExpbmVOdW1iZXIgKyBpIC0gMSkgJSBsaW5lQ291bnQ7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZEZpcnN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVJbmRleCArIDEsIDEsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBfZmluZEZpcnN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVOdW1iZXIsIGZyb21Db2x1bW4sIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNldCByZWdleCB0byBzZWFyY2ggZnJvbSBjb2x1bW5cbiAgICAgICAgc2VhcmNoZXIucmVzZXQoZnJvbUNvbHVtbiAtIDEpO1xuICAgICAgICBjb25zdCBtID0gc2VhcmNoZXIubmV4dCh0ZXh0KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxLCBsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSArIG1bMF0ubGVuZ3RoKSwgbSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZFByZXZpb3VzTWF0Y2gobW9kZWwsIHNlYXJjaFBhcmFtcywgc2VhcmNoU3RhcnQsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBuZXcgU2VhcmNoZXIoc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycywgc2VhcmNoRGF0YS5yZWdleCk7XG4gICAgICAgIGlmIChzZWFyY2hEYXRhLnJlZ2V4Lm11bHRpbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZFByZXZpb3VzTWF0Y2hNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRQcmV2aW91c01hdGNoTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kUHJldmlvdXNNYXRjaE11bHRpbGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZG9GaW5kTWF0Y2hlc011bHRpbGluZShtb2RlbCwgbmV3IFJhbmdlKDEsIDEsIHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIsIHNlYXJjaFN0YXJ0LmNvbHVtbiksIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcywgMTAgKiBMSU1JVF9GSU5EX0NPVU5UKTtcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgaWYgKHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIgIT09IGxpbmVDb3VudCB8fCBzZWFyY2hTdGFydC5jb2x1bW4gIT09IG1vZGVsLmdldExpbmVNYXhDb2x1bW4obGluZUNvdW50KSkge1xuICAgICAgICAgICAgLy8gVHJ5IGFnYWluIHdpdGggYWxsIGNvbnRlbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb0ZpbmRQcmV2aW91c01hdGNoTXVsdGlsaW5lKG1vZGVsLCBuZXcgUG9zaXRpb24obGluZUNvdW50LCBtb2RlbC5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpLCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2RvRmluZFByZXZpb3VzTWF0Y2hMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBjb25zdCBzdGFydExpbmVOdW1iZXIgPSBzZWFyY2hTdGFydC5saW5lTnVtYmVyO1xuICAgICAgICAvLyBMb29rIGluIGZpcnN0IGxpbmVcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKDAsIHNlYXJjaFN0YXJ0LmNvbHVtbiAtIDEpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZExhc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgc3RhcnRMaW5lTnVtYmVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUluZGV4ID0gKGxpbmVDb3VudCArIHN0YXJ0TGluZU51bWJlciAtIGkgLSAxKSAlIGxpbmVDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9maW5kTGFzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBsaW5lSW5kZXggKyAxLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgX2ZpbmRMYXN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVOdW1iZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGxldCBiZXN0UmVzdWx0ID0gbnVsbDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hlci5uZXh0KHRleHQpKSkge1xuICAgICAgICAgICAgYmVzdFJlc3VsdCA9IGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGgpLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RSZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVmdElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcbiAgICBpZiAobWF0Y2hTdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIE1hdGNoIHN0YXJ0cyBhdCBzdGFydCBvZiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJCZWZvcmUgPSB0ZXh0LmNoYXJDb2RlQXQobWF0Y2hTdGFydEluZGV4IC0gMSk7XG4gICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChjaGFyQmVmb3JlKSAhPT0gMCAvKiBSZWd1bGFyICovKSB7XG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2hhckJlZm9yZSA9PT0gMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckJlZm9yZSA9PT0gMTAgLyogTGluZUZlZWQgKi8pIHtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIG1hdGNoIGlzIGxpbmUgYnJlYWsgb3IgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoTGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaXJzdENoYXJJbk1hdGNoID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCk7XG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQoZmlyc3RDaGFySW5NYXRjaCkgIT09IDAgLyogUmVndWxhciAqLykge1xuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGNoYXJhY3RlciBpbnNpZGUgdGhlIG1hdGNoIGlzIGEgd29yZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJpZ2h0SXNXb3JkQm91bmRheSh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbWF0Y2hTdGFydEluZGV4LCBtYXRjaExlbmd0aCkge1xuICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggKyBtYXRjaExlbmd0aCA9PT0gdGV4dExlbmd0aCkge1xuICAgICAgICAvLyBNYXRjaCBlbmRzIGF0IGVuZCBvZiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJBZnRlciA9IHRleHQuY2hhckNvZGVBdChtYXRjaFN0YXJ0SW5kZXggKyBtYXRjaExlbmd0aCk7XG4gICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChjaGFyQWZ0ZXIpICE9PSAwIC8qIFJlZ3VsYXIgKi8pIHtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBhZnRlciB0aGUgbWF0Y2ggaXMgYSB3b3JkIHNlcGFyYXRvclxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNoYXJBZnRlciA9PT0gMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckFmdGVyID09PSAxMCAvKiBMaW5lRmVlZCAqLykge1xuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBtYXRjaCBpcyBsaW5lIGJyZWFrIG9yIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaExlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGFzdENoYXJJbk1hdGNoID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCArIG1hdGNoTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQobGFzdENoYXJJbk1hdGNoKSAhPT0gMCAvKiBSZWd1bGFyICovKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoIGlzIGEgd29yZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWF0Y2god29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcbiAgICByZXR1cm4gKGxlZnRJc1dvcmRCb3VuZGF5KHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKVxuICAgICAgICAmJiByaWdodElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpKTtcbn1cbmV4cG9ydCBjbGFzcyBTZWFyY2hlciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNlcGFyYXRvcnMsIHNlYXJjaFJlZ2V4KSB7XG4gICAgICAgIHRoaXMuX3dvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XG4gICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4ID0gc2VhcmNoUmVnZXg7XG4gICAgICAgIHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmVzZXQobGFzdEluZGV4KSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9wcmV2TWF0Y2hMZW5ndGggPSAwO1xuICAgIH1cbiAgICBuZXh0KHRleHQpIHtcbiAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggKyB0aGlzLl9wcmV2TWF0Y2hMZW5ndGggPT09IHRleHRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0gPSB0aGlzLl9zZWFyY2hSZWdleC5leGVjKHRleHQpO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRjaFN0YXJ0SW5kZXggPSBtLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hMZW5ndGggPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggPT09IHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggJiYgbWF0Y2hMZW5ndGggPT09IHRoaXMuX3ByZXZNYXRjaExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VhcmNoIHJlc3VsdCBpcyBhbiBlbXB0eSBzdHJpbmcgYW5kIHdvbid0IGFkdmFuY2UgYHJlZ2V4Lmxhc3RJbmRleGAsIHNvIGByZWdleC5leGVjYCB3aWxsIHN0dWNrIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gdGhhdCBieSBhZHZhbmNpbmcgYnkgdHdvIGlmIHN1cnJvZ2F0ZSBwYWlyIGZvdW5kIGFuZCBieSBvbmUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmdldE5leHRDb2RlUG9pbnQodGV4dCwgdGV4dExlbmd0aCwgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4KSA+IDB4RkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hSZWdleC5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcmVnZXggbWF0Y2hlcyB0aGUgc2FtZSByYW5nZSB0d2ljZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoU3RhcnRJbmRleCA9IG1hdGNoU3RhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXRjaExlbmd0aCA9IG1hdGNoTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93b3JkU2VwYXJhdG9ycyB8fCBpc1ZhbGlkTWF0Y2godGhpcy5fd29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XG5pbXBvcnQgeyBLZXlDaG9yZCB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2tleUNvZGVzLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4uL2NvcmUvc2VsZWN0aW9uLmpzJztcbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzLmpzJztcbmltcG9ydCAqIGFzIHN0YW5kYWxvbmVFbnVtcyBmcm9tICcuLi9zdGFuZGFsb25lL3N0YW5kYWxvbmVFbnVtcy5qcyc7XG5leHBvcnQgY2xhc3MgS2V5TW9kIHtcbiAgICBzdGF0aWMgY2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KSB7XG4gICAgICAgIHJldHVybiBLZXlDaG9yZChmaXJzdFBhcnQsIHNlY29uZFBhcnQpO1xuICAgIH1cbn1cbktleU1vZC5DdHJsQ21kID0gMjA0OCAvKiBDdHJsQ21kICovO1xuS2V5TW9kLlNoaWZ0ID0gMTAyNCAvKiBTaGlmdCAqLztcbktleU1vZC5BbHQgPSA1MTIgLyogQWx0ICovO1xuS2V5TW9kLldpbkN0cmwgPSAyNTYgLyogV2luQ3RybCAqLztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb25hY29CYXNlQVBJKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVkaXRvcjogdW5kZWZpbmVkLFxuICAgICAgICBsYW5ndWFnZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U6IENhbmNlbGxhdGlvblRva2VuU291cmNlLFxuICAgICAgICBFbWl0dGVyOiBFbWl0dGVyLFxuICAgICAgICBLZXlDb2RlOiBzdGFuZGFsb25lRW51bXMuS2V5Q29kZSxcbiAgICAgICAgS2V5TW9kOiBLZXlNb2QsXG4gICAgICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICAgICAgUmFuZ2U6IFJhbmdlLFxuICAgICAgICBTZWxlY3Rpb246IFNlbGVjdGlvbixcbiAgICAgICAgU2VsZWN0aW9uRGlyZWN0aW9uOiBzdGFuZGFsb25lRW51bXMuU2VsZWN0aW9uRGlyZWN0aW9uLFxuICAgICAgICBNYXJrZXJTZXZlcml0eTogc3RhbmRhbG9uZUVudW1zLk1hcmtlclNldmVyaXR5LFxuICAgICAgICBNYXJrZXJUYWc6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJUYWcsXG4gICAgICAgIFVyaTogVVJJLFxuICAgICAgICBUb2tlbjogVG9rZW5cbiAgICB9O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IHN0cmluZ0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9jb3JlL3JhbmdlLmpzJztcbmltcG9ydCB7IERpZmZDb21wdXRlciB9IGZyb20gJy4uL2RpZmYvZGlmZkNvbXB1dGVyLmpzJztcbmltcG9ydCB7IE1pcnJvclRleHRNb2RlbCBhcyBCYXNlTWlycm9yTW9kZWwgfSBmcm9tICcuLi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMnO1xuaW1wb3J0IHsgZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbiwgZ2V0V29yZEF0VGV4dCB9IGZyb20gJy4uL2NvcmUvd29yZEhlbHBlci5qcyc7XG5pbXBvcnQgeyBjb21wdXRlTGlua3MgfSBmcm9tICcuLi9sYW5ndWFnZXMvbGlua0NvbXB1dGVyLmpzJztcbmltcG9ydCB7IEJhc2ljSW5wbGFjZVJlcGxhY2UgfSBmcm9tICcuLi9sYW5ndWFnZXMvc3VwcG9ydHMvaW5wbGFjZVJlcGxhY2VTdXBwb3J0LmpzJztcbmltcG9ydCB7IGNyZWF0ZU1vbmFjb0Jhc2VBUEkgfSBmcm9tICcuL2VkaXRvckJhc2VBcGkuanMnO1xuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdHlwZXMuanMnO1xuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzJztcbmltcG9ydCB7IFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlciB9IGZyb20gJy4vdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXJyb3JNb2RlbCBleHRlbmRzIEJhc2VNaXJyb3JNb2RlbCB7XG4gICAgZ2V0IHVyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICB9XG4gICAgZ2V0IGVvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VvbDtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcbiAgICB9XG4gICAgZ2V0TGluZXNDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCk7XG4gICAgfVxuICAgIGdldExpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xuICAgIH1cbiAgICBnZXRXb3JkQXRQb3NpdGlvbihwb3NpdGlvbiwgd29yZERlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgd29yZEF0VGV4dCA9IGdldFdvcmRBdFRleHQocG9zaXRpb24uY29sdW1uLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLCAwKTtcbiAgICAgICAgaWYgKHdvcmRBdFRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UocG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5zdGFydENvbHVtbiwgcG9zaXRpb24ubGluZU51bWJlciwgd29yZEF0VGV4dC5lbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3b3Jkcyh3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICBjb25zdCB3b3JkZW5pemUgPSB0aGlzLl93b3JkZW5pemUuYmluZCh0aGlzKTtcbiAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgbGluZVRleHQgPSAnJztcbiAgICAgICAgbGV0IHdvcmRSYW5nZXNJZHggPSAwO1xuICAgICAgICBsZXQgd29yZFJhbmdlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JkUmFuZ2VzSWR4IDwgd29yZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZVRleHQuc3Vic3RyaW5nKHdvcmRSYW5nZXNbd29yZFJhbmdlc0lkeF0uc3RhcnQsIHdvcmRSYW5nZXNbd29yZFJhbmdlc0lkeF0uZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXIgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IGxpbmVzW2xpbmVOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXMgPSB3b3JkZW5pemUobGluZVRleHQsIHdvcmREZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzSWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TGluZVdvcmRzKGxpbmVOdW1iZXIsIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV07XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHRoaXMuX3dvcmRlbml6ZShjb250ZW50LCB3b3JkRGVmaW5pdGlvbik7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzKSB7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3b3JkOiBjb250ZW50LnN1YnN0cmluZyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogcmFuZ2UuZW5kICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH1cbiAgICBfd29yZGVuaXplKGNvbnRlbnQsIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7IC8vIHJlc2V0IGxhc3RJbmRleCBqdXN0IHRvIGJlIHN1cmVcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gd29yZERlZmluaXRpb24uZXhlYyhjb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGl0IGRpZCBtYXRjaCB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0YXJ0OiBtYXRjaC5pbmRleCwgZW5kOiBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRWYWx1ZUluUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEsIHJhbmdlLmVuZENvbHVtbiAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVFbmRpbmcgPSB0aGlzLl9lb2w7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgY29uc3QgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XG4gICAgICAgIGNvbnN0IHJlc3VsdExpbmVzID0gW107XG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2godGhpcy5fbGluZXNbc3RhcnRMaW5lSW5kZXhdLnN1YnN0cmluZyhyYW5nZS5zdGFydENvbHVtbiAtIDEpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZUluZGV4ICsgMTsgaSA8IGVuZExpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2VuZExpbmVJbmRleF0uc3Vic3RyaW5nKDAsIHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzLmpvaW4obGluZUVuZGluZyk7XG4gICAgfVxuICAgIG9mZnNldEF0KHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmVTdGFydHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVTdGFydHMuZ2V0UHJlZml4U3VtKHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAyKSArIChwb3NpdGlvbi5jb2x1bW4gLSAxKTtcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9lbnN1cmVMaW5lU3RhcnRzKCk7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuX2xpbmVTdGFydHMuZ2V0SW5kZXhPZihvZmZzZXQpO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gdGhpcy5fbGluZXNbb3V0LmluZGV4XS5sZW5ndGg7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSByZXR1cm4gYSB2YWxpZCBwb3NpdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZU51bWJlcjogMSArIG91dC5pbmRleCxcbiAgICAgICAgICAgIGNvbHVtbjogMSArIE1hdGgubWluKG91dC5yZW1haW5kZXIsIGxpbmVMZW5ndGgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIF92YWxpZGF0ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2UuZW5kQ29sdW1uIH0pO1xuICAgICAgICBpZiAoc3RhcnQubGluZU51bWJlciAhPT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyXG4gICAgICAgICAgICB8fCBzdGFydC5jb2x1bW4gIT09IHJhbmdlLnN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB8fCBlbmQubGluZU51bWJlciAhPT0gcmFuZ2UuZW5kTGluZU51bWJlclxuICAgICAgICAgICAgfHwgZW5kLmNvbHVtbiAhPT0gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnQubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogZW5kLmNvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIF92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghUG9zaXRpb24uaXNJUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGxpbmVOdW1iZXIsIGNvbHVtbiB9ID0gcG9zaXRpb247XG4gICAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IDE7XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZU51bWJlciA+IHRoaXMuX2xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXhDaGFyYWN0ZXIgPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbiA+IG1heENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IG1heENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmVOdW1iZXIsIGNvbHVtbiB9O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEVkaXRvclNpbXBsZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3IoaG9zdCwgZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuX21vZGVscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5ID0gZm9yZWlnbk1vZHVsZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSBudWxsO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBfZ2V0TW9kZWwodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHNbdXJpXTtcbiAgICB9XG4gICAgX2dldE1vZGVscygpIHtcbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscykuZm9yRWFjaCgoa2V5KSA9PiBhbGwucHVzaCh0aGlzLl9tb2RlbHNba2V5XSkpO1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICBhY2NlcHROZXdNb2RlbChkYXRhKSB7XG4gICAgICAgIHRoaXMuX21vZGVsc1tkYXRhLnVybF0gPSBuZXcgTWlycm9yTW9kZWwoVVJJLnBhcnNlKGRhdGEudXJsKSwgZGF0YS5saW5lcywgZGF0YS5FT0wsIGRhdGEudmVyc2lvbklkKTtcbiAgICB9XG4gICAgYWNjZXB0TW9kZWxDaGFuZ2VkKHN0clVSTCwgZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21vZGVsc1tzdHJVUkxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9tb2RlbHNbc3RyVVJMXTtcbiAgICAgICAgbW9kZWwub25FdmVudHMoZSk7XG4gICAgfVxuICAgIGFjY2VwdFJlbW92ZWRNb2RlbChzdHJVUkwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbHNbc3RyVVJMXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RlbHNbc3RyVVJMXTtcbiAgICB9XG4gICAgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRzKHVybCwgb3B0aW9ucywgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwodXJsKTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZXM6IFtdLCBoYXNNb3JlOiBmYWxzZSwgYW1iaWd1b3VzQ2hhcmFjdGVyQ291bnQ6IDAsIGludmlzaWJsZUNoYXJhY3RlckNvdW50OiAwLCBub25CYXNpY0FzY2lpQ2hhcmFjdGVyQ291bnQ6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVbmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRzKG1vZGVsLCBvcHRpb25zLCByYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyAtLS0tIEJFR0lOIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb21wdXRlRGlmZihvcmlnaW5hbFVybCwgbW9kaWZpZWRVcmwsIGlnbm9yZVRyaW1XaGl0ZXNwYWNlLCBtYXhDb21wdXRhdGlvblRpbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5fZ2V0TW9kZWwob3JpZ2luYWxVcmwpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWQgPSB0aGlzLl9nZXRNb2RlbChtb2RpZmllZFVybCk7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsIHx8ICFtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lcyA9IG9yaWdpbmFsLmdldExpbmVzQ29udGVudCgpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkLmdldExpbmVzQ29udGVudCgpO1xuICAgICAgICAgICAgY29uc3QgZGlmZkNvbXB1dGVyID0gbmV3IERpZmZDb21wdXRlcihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2U6IGlnbm9yZVRyaW1XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgIHNob3VsZE1ha2VQcmV0dHlEaWZmOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1heENvbXB1dGF0aW9uVGltZTogbWF4Q29tcHV0YXRpb25UaW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBkaWZmQ29tcHV0ZXIuY29tcHV0ZURpZmYoKTtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWNhbCA9IChkaWZmUmVzdWx0LmNoYW5nZXMubGVuZ3RoID4gMCA/IGZhbHNlIDogdGhpcy5fbW9kZWxzQXJlSWRlbnRpY2FsKG9yaWdpbmFsLCBtb2RpZmllZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGRpZmZSZXN1bHQucXVpdEVhcmx5LFxuICAgICAgICAgICAgICAgIGlkZW50aWNhbDogaWRlbnRpY2FsLFxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGRpZmZSZXN1bHQuY2hhbmdlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tb2RlbHNBcmVJZGVudGljYWwob3JpZ2luYWwsIG1vZGlmaWVkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZUNvdW50ID0gb3JpZ2luYWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZUNvdW50ID0gbW9kaWZpZWQuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVDb3VudCAhPT0gbW9kaWZpZWRMaW5lQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBsaW5lID0gMTsgbGluZSA8PSBvcmlnaW5hbExpbmVDb3VudDsgbGluZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5nZXRMaW5lQ29udGVudChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkLmdldExpbmVDb250ZW50KGxpbmUpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb21wdXRlTW9yZU1pbmltYWxFZGl0cyhtb2RlbFVybCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgbGV0IGxhc3RFb2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlZGl0cyA9IGVkaXRzLnNsaWNlKDApLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5yYW5nZSAmJiBiLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSYW5nZS5jb21wYXJlUmFuZ2VzVXNpbmdTdGFydHMoYS5yYW5nZSwgYi5yYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVvbCBvbmx5IGNoYW5nZXMgc2hvdWxkIGdvIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBjb25zdCBhUm5nID0gYS5yYW5nZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJSbmcgPSBiLnJhbmdlID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFSbmcgLSBiUm5nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCB7IHJhbmdlLCB0ZXh0LCBlb2wgfSBvZiBlZGl0cykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW9sID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RW9sID0gZW9sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUmFuZ2UuaXNFbXB0eShyYW5nZSkgJiYgIXRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxufFxcbnxcXHIvZywgbW9kZWwuZW9sKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGRpZmYgd29uJ3QgdGFrZSB0b28gbG9uZ1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1heCh0ZXh0Lmxlbmd0aCwgb3JpZ2luYWwubGVuZ3RoKSA+IEVkaXRvclNpbXBsZVdvcmtlci5fZGlmZkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgcmFuZ2UsIHRleHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZWRpdC50ZXh0XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHN0cmluZ0RpZmYob3JpZ2luYWwsIHRleHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0T2Zmc2V0ID0gbW9kZWwub2Zmc2V0QXQoUmFuZ2UubGlmdChyYW5nZSkuZ2V0U3RhcnRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBtb2RlbC5wb3NpdGlvbkF0KGVkaXRPZmZzZXQgKyBjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnN1YnN0cihjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0TGluZU51bWJlcjogc3RhcnQubGluZU51bWJlciwgc3RhcnRDb2x1bW46IHN0YXJ0LmNvbHVtbiwgZW5kTGluZU51bWJlcjogZW5kLmxpbmVOdW1iZXIsIGVuZENvbHVtbjogZW5kLmNvbHVtbiB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3RWRpdC5yYW5nZSkgIT09IG5ld0VkaXQudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3RWRpdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RFb2wgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBlb2w6IGxhc3RFb2wsIHRleHQ6ICcnLCByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IDAsIHN0YXJ0Q29sdW1uOiAwLCBlbmRMaW5lTnVtYmVyOiAwLCBlbmRDb2x1bW46IDAgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyAtLS0tIEVORCBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbXB1dGVMaW5rcyhtb2RlbFVybCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUxpbmtzKG1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRleHR1YWxTdWdnZXN0KG1vZGVsVXJscywgbGVhZGluZ1dvcmQsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3cgPSBuZXcgU3RvcFdhdGNoKHRydWUpO1xuICAgICAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgdXJsIG9mIG1vZGVsVXJscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwodXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB3b3JkIG9mIG1vZGVsLndvcmRzKHdvcmREZWZSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3b3JkID09PSBsZWFkaW5nV29yZCB8fCAhaXNOYU4oTnVtYmVyKHdvcmQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5hZGQod29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuLnNpemUgPiBFZGl0b3JTaW1wbGVXb3JrZXIuX3N1Z2dlc3Rpb25zTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgd29yZHM6IEFycmF5LmZyb20oc2VlbiksIGR1cmF0aW9uOiBzdy5lbGFwc2VkKCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0gRU5EIHN1Z2dlc3QgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyNyZWdpb24gLS0gd29yZCByYW5nZXMgLS1cbiAgICBjb21wdXRlV29yZFJhbmdlcyhtb2RlbFVybCwgcmFuZ2UsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3b3JkRGVmUmVnRXhwID0gbmV3IFJlZ0V4cCh3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgPSByYW5nZS5zdGFydExpbmVOdW1iZXI7IGxpbmUgPCByYW5nZS5lbmRMaW5lTnVtYmVyOyBsaW5lKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkcyA9IG1vZGVsLmdldExpbmVXb3JkcyhsaW5lLCB3b3JkRGVmUmVnRXhwKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIod29yZC53b3JkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IHJlc3VsdFt3b3JkLndvcmRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3dvcmQud29yZF0gPSBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiB3b3JkLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbHVtbjogd29yZC5lbmRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIG5hdmlnYXRlVmFsdWVTZXQobW9kZWxVcmwsIHJhbmdlLCB1cCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiByYW5nZS5lbmRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZENvbHVtbiArIDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uVGV4dCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkUmFuZ2UgPSBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9LCB3b3JkRGVmUmVnRXhwKTtcbiAgICAgICAgICAgIGlmICghd29yZFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3b3JkID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHdvcmRSYW5nZSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBCYXNpY0lucGxhY2VSZXBsYWNlLklOU1RBTkNFLm5hdmlnYXRlVmFsdWVTZXQocmFuZ2UsIHNlbGVjdGlvblRleHQsIHdvcmRSYW5nZSwgd29yZCwgdXApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGxvYWRGb3JlaWduTW9kdWxlKG1vZHVsZUlkLCBjcmVhdGVEYXRhLCBmb3JlaWduSG9zdE1ldGhvZHMpIHtcbiAgICAgICAgY29uc3QgcHJveHlNZXRob2RSZXF1ZXN0ID0gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3QuZmhyKG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZvcmVpZ25Ib3N0ID0gdHlwZXMuY3JlYXRlUHJveHlPYmplY3QoZm9yZWlnbkhvc3RNZXRob2RzLCBwcm94eU1ldGhvZFJlcXVlc3QpO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBob3N0OiBmb3JlaWduSG9zdCxcbiAgICAgICAgICAgIGdldE1pcnJvck1vZGVsczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRNb2RlbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmVpZ25Nb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gdGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkoY3R4LCBjcmVhdGVEYXRhKTtcbiAgICAgICAgICAgIC8vIHN0YXRpYyBmb3JlaW5nIG1vZHVsZVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9mb3JlaWduTW9kdWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRVNNLWNvbW1lbnQtYmVnaW5cbiAgICAgICAgLy8gXHRcdHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gXHRcdFx0cmVxdWlyZShbbW9kdWxlSWRdLCAoZm9yZWlnbk1vZHVsZTogeyBjcmVhdGU6IElGb3JlaWduTW9kdWxlRmFjdG9yeSB9KSA9PiB7XG4gICAgICAgIC8vIFx0XHRcdFx0dGhpcy5fZm9yZWlnbk1vZHVsZSA9IGZvcmVpZ25Nb2R1bGUuY3JlYXRlKGN0eCwgY3JlYXRlRGF0YSk7XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBcdFx0XHRcdHJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fZm9yZWlnbk1vZHVsZSkpO1xuICAgICAgICAvLyBcbiAgICAgICAgLy8gXHRcdFx0fSwgcmVqZWN0KTtcbiAgICAgICAgLy8gXHRcdH0pO1xuICAgICAgICAvLyBFU00tY29tbWVudC1lbmRcbiAgICAgICAgLy8gRVNNLXVuY29tbWVudC1iZWdpblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBVbmV4cGVjdGVkIHVzYWdlYCkpO1xuICAgICAgICAvLyBFU00tdW5jb21tZW50LWVuZFxuICAgIH1cbiAgICAvLyBmb3JlaWduIG1ldGhvZCByZXF1ZXN0XG4gICAgZm1yKG1ldGhvZCwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2ZvcmVpZ25Nb2R1bGUgfHwgdHlwZW9mIHRoaXMuX2ZvcmVpZ25Nb2R1bGVbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1ZXN0SGFuZGxlciBvciBtZXRob2Q6ICcgKyBtZXRob2QpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0uYXBwbHkodGhpcy5fZm9yZWlnbk1vZHVsZSwgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyAtLS0tIEVORCBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAtLS0tIEJFR0lOIG1pbmltYWwgZWRpdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5FZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCA9IDEwMDAwMDtcbi8vIC0tLS0gQkVHSU4gc3VnZ2VzdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuRWRpdG9yU2ltcGxlV29ya2VyLl9zdWdnZXN0aW9uc0xpbWl0ID0gMTAwMDA7XG4vKipcbiAqIENhbGxlZCBvbiB0aGUgd29ya2VyIHNpZGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGhvc3QpIHtcbiAgICByZXR1cm4gbmV3IEVkaXRvclNpbXBsZVdvcmtlcihob3N0LCBudWxsKTtcbn1cbmlmICh0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyXG4gICAgZ2xvYmFscy5tb25hY28gPSBjcmVhdGVNb25hY29CYXNlQVBJKCk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBTZWFyY2hlciB9IGZyb20gJy4uL21vZGVsL3RleHRNb2RlbFNlYXJjaC5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi90eXBlcy5qcyc7XG5pbXBvcnQgeyBERUZBVUxUX1dPUkRfUkVHRVhQLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vY29yZS93b3JkSGVscGVyLmpzJztcbmV4cG9ydCBjbGFzcyBVbmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIge1xuICAgIHN0YXRpYyBjb21wdXRlVW5pY29kZUhpZ2hsaWdodHMobW9kZWwsIG9wdGlvbnMsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IHJhbmdlID8gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDogMTtcbiAgICAgICAgY29uc3QgZW5kTGluZSA9IHJhbmdlID8gcmFuZ2UuZW5kTGluZU51bWJlciA6IG1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBjb25zdCBjb2RlUG9pbnRIaWdobGlnaHRlciA9IG5ldyBDb2RlUG9pbnRIaWdobGlnaHRlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLmdldENhbmRpZGF0ZUNvZGVQb2ludHMoKTtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBpZiAoY2FuZGlkYXRlcyA9PT0gJ2FsbE5vbkJhc2ljQXNjaWknKSB7XG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoJ1teXFxcXHRcXFxcblxcXFxyXFxcXHgyMC1cXFxceDdFXScsICdnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYCR7YnVpbGRSZWdFeHBDaGFyQ2xhc3NFeHByKEFycmF5LmZyb20oY2FuZGlkYXRlcykpfWAsICdnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBuZXcgU2VhcmNoZXIobnVsbCwgcmVnZXgpO1xuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgbGV0IGhhc01vcmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIGxldCBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudCA9IDA7XG4gICAgICAgIGxldCBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCA9IDA7XG4gICAgICAgIGxldCBub25CYXNpY0FzY2lpQ2hhcmFjdGVyQ291bnQgPSAwO1xuICAgICAgICBmb3JMb29wOiBmb3IgKGxldCBsaW5lTnVtYmVyID0gc3RhcnRMaW5lLCBsaW5lQ291bnQgPSBlbmRMaW5lOyBsaW5lTnVtYmVyIDw9IGxpbmVDb3VudDsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IG1vZGVsLmdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIFJlc2V0IHJlZ2V4IHRvIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIG0gPSBzZWFyY2hlci5uZXh0KGxpbmVDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHJhbmdlIHRvIGVudGlyZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZUJlZm9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4ICsgMSA8IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlID0gbGluZUNvbnRlbnQuY2hhckNvZGVBdChlbmRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQmVmb3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyID0gbGluZUNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29yZCA9IGdldFdvcmRBdFRleHQoc3RhcnRJbmRleCArIDEsIERFRkFVTFRfV09SRF9SRUdFWFAsIGxpbmVDb250ZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0UmVhc29uID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuc2hvdWxkSGlnaGxpZ2h0Tm9uQmFzaWNBU0NJSShzdHIsIHdvcmQgPyB3b3JkLndvcmQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodFJlYXNvbiAhPT0gMCAvKiBOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAzIC8qIEFtYmlndW91cyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0NoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoaWdobGlnaHRSZWFzb24gPT09IDIgLyogSW52aXNpYmxlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52aXNpYmxlQ2hhcmFjdGVyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhpZ2hsaWdodFJlYXNvbiA9PT0gMSAvKiBOb25CYXNpY0FTQ0lJICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uQmFzaWNBc2NpaUNoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihoaWdobGlnaHRSZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTUFYX1JFU1VMVF9MRU5HVEggPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gTUFYX1JFU1VMVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBmb3JMb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIHN0YXJ0SW5kZXggKyAxLCBsaW5lTnVtYmVyLCBlbmRJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZXMsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgYW1iaWd1b3VzQ2hhcmFjdGVyQ291bnQsXG4gICAgICAgICAgICBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCxcbiAgICAgICAgICAgIG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRSZWFzb24oY2hhciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnRIaWdobGlnaHRlciA9IG5ldyBDb2RlUG9pbnRIaWdobGlnaHRlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuc2hvdWxkSGlnaGxpZ2h0Tm9uQmFzaWNBU0NJSShjaGFyLCBudWxsKTtcbiAgICAgICAgc3dpdGNoIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAyIC8qIEludmlzaWJsZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiAxIC8qIEludmlzaWJsZSAqLyB9O1xuICAgICAgICAgICAgY2FzZSAzIC8qIEFtYmlndW91cyAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeUNvbmZ1c2FibGUgPSBjb2RlUG9pbnRIaWdobGlnaHRlci5hbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldFByaW1hcnlDb25mdXNhYmxlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90QW1iaWd1b3VzSW5Mb2NhbGVzID0gc3RyaW5ncy5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldExvY2FsZXMoKS5maWx0ZXIoKGwpID0+ICFzdHJpbmdzLkFtYmlndW91c0NoYXJhY3RlcnMuZ2V0SW5zdGFuY2UobmV3IFNldChbLi4ub3B0aW9ucy5hbGxvd2VkTG9jYWxlcywgbF0pKS5pc0FtYmlndW91cyhjb2RlUG9pbnQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiAwIC8qIEFtYmlndW91cyAqLywgY29uZnVzYWJsZVdpdGg6IFN0cmluZy5mcm9tQ29kZVBvaW50KHByaW1hcnlDb25mdXNhYmxlKSwgbm90QW1iaWd1b3VzSW5Mb2NhbGVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEgLyogTm9uQmFzaWNBU0NJSSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBraW5kOiAyIC8qIE5vbkJhc2ljQXNjaWkgKi8gfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUmVnRXhwQ2hhckNsYXNzRXhwcihjb2RlUG9pbnRzLCBmbGFncykge1xuICAgIGNvbnN0IHNyYyA9IGBbJHtzdHJpbmdzLmVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoY29kZVBvaW50cy5tYXAoKGkpID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KGkpKS5qb2luKCcnKSl9XWA7XG4gICAgcmV0dXJuIHNyYztcbn1cbmNsYXNzIENvZGVQb2ludEhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYWxsb3dlZENvZGVQb2ludHMgPSBuZXcgU2V0KG9wdGlvbnMuYWxsb3dlZENvZGVQb2ludHMpO1xuICAgICAgICB0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMgPSBzdHJpbmdzLkFtYmlndW91c0NoYXJhY3RlcnMuZ2V0SW5zdGFuY2UobmV3IFNldChvcHRpb25zLmFsbG93ZWRMb2NhbGVzKSk7XG4gICAgfVxuICAgIGdldENhbmRpZGF0ZUNvZGVQb2ludHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9uQmFzaWNBU0NJSSkge1xuICAgICAgICAgICAgcmV0dXJuICdhbGxOb25CYXNpY0FzY2lpJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjcCBvZiBzdHJpbmdzLkludmlzaWJsZUNoYXJhY3RlcnMuY29kZVBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkSW52aXNpYmxlQ2hhcmFjdGVyKFN0cmluZy5mcm9tQ29kZVBvaW50KGNwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChjcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW1iaWd1b3VzQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjcCBvZiB0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMuZ2V0Q29uZnVzYWJsZUNvZGVQb2ludHMoKSkge1xuICAgICAgICAgICAgICAgIHNldC5hZGQoY3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY3Agb2YgdGhpcy5hbGxvd2VkQ29kZVBvaW50cykge1xuICAgICAgICAgICAgc2V0LmRlbGV0ZShjcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc2hvdWxkSGlnaGxpZ2h0Tm9uQmFzaWNBU0NJSShjaGFyYWN0ZXIsIHdvcmRDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dlZENvZGVQb2ludHMuaGFzKGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub25CYXNpY0FTQ0lJKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBOb25CYXNpY0FTQ0lJICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNCYXNpY0FTQ0lJQ2hhcmFjdGVycyA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdvcmRDb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGFyIG9mIHdvcmRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Jhc2ljQVNDSUkgPSBzdHJpbmdzLmlzQmFzaWNBU0NJSShjaGFyKTtcbiAgICAgICAgICAgICAgICBoYXNCYXNpY0FTQ0lJQ2hhcmFjdGVycyA9IGhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzIHx8IGlzQmFzaWNBU0NJSTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmFzaWNBU0NJSSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzLmlzQW1iaWd1b3VzKGNvZGVQb2ludCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5pc0ludmlzaWJsZUNoYXJhY3Rlcihjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc05vbkNvbmZ1c2FibGVOb25CYXNpY0FzY2lpQ2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvKiBEb24ndCBhbGxvdyBtaXhpbmcgd2VpcmQgbG9va2luZyBjaGFyYWN0ZXJzIHdpdGggQVNDSUkgKi8gIWhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzICYmXG4gICAgICAgICAgICAvKiBJcyB0aGVyZSBhbiBvYnZpb3VzbHkgd2VpcmQgbG9va2luZyBjaGFyYWN0ZXI/ICovIGhhc05vbkNvbmZ1c2FibGVOb25CYXNpY0FzY2lpQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgLy8gVE9ETyBjaGVjayBmb3IgZW1vamlzXG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihjaGFyYWN0ZXIpICYmIHN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5pc0ludmlzaWJsZUNoYXJhY3Rlcihjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogSW52aXNpYmxlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW1iaWd1b3VzQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW1iaWd1b3VzQ2hhcmFjdGVycy5pc0FtYmlndW91cyhjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogQW1iaWd1b3VzICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBbGxvd2VkSW52aXNpYmxlQ2hhcmFjdGVyKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPT09ICcgJyB8fCBjaGFyYWN0ZXIgPT09ICdcXG4nIHx8IGNoYXJhY3RlciA9PT0gJ1xcdCc7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFRISVMgSVMgQSBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQgRElSRUNUTFkuXG5leHBvcnQgdmFyIEFjY2Vzc2liaWxpdHlTdXBwb3J0O1xuKGZ1bmN0aW9uIChBY2Nlc3NpYmlsaXR5U3VwcG9ydCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHRoZSBicm93c2VyIGNhc2Ugd2hlcmUgaXQgaXMgbm90IGtub3duIGlmIGEgc2NyZWVuIHJlYWRlciBpcyBhdHRhY2hlZCBvciBuby5cbiAgICAgKi9cbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRGlzYWJsZWRcIl0gPSAxXSA9IFwiRGlzYWJsZWRcIjtcbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIkVuYWJsZWRcIl0gPSAyXSA9IFwiRW5hYmxlZFwiO1xufSkoQWNjZXNzaWJpbGl0eVN1cHBvcnQgfHwgKEFjY2Vzc2liaWxpdHlTdXBwb3J0ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZTtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSkge1xuICAgIC8qKlxuICAgICAqIEFkanVzdCB3aGl0ZXNwYWNlL2luZGVudGF0aW9uIG9mIG11bHRpbGluZSBpbnNlcnQgdGV4dHMgdG9cbiAgICAgKiBtYXRjaCB0aGUgY3VycmVudCBsaW5lIGluZGVudGF0aW9uLlxuICAgICAqL1xuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIktlZXBXaGl0ZXNwYWNlXCJdID0gMV0gPSBcIktlZXBXaGl0ZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogYGluc2VydFRleHRgIGlzIGEgc25pcHBldC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJJbnNlcnRBc1NuaXBwZXRcIl0gPSA0XSA9IFwiSW5zZXJ0QXNTbmlwcGV0XCI7XG59KShDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlIHx8IChDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiTWV0aG9kXCJdID0gMF0gPSBcIk1ldGhvZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb25zdHJ1Y3RvclwiXSA9IDJdID0gXCJDb25zdHJ1Y3RvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGaWVsZFwiXSA9IDNdID0gXCJGaWVsZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJWYXJpYWJsZVwiXSA9IDRdID0gXCJWYXJpYWJsZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDbGFzc1wiXSA9IDVdID0gXCJDbGFzc1wiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJTdHJ1Y3RcIl0gPSA2XSA9IFwiU3RydWN0XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkludGVyZmFjZVwiXSA9IDddID0gXCJJbnRlcmZhY2VcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiTW9kdWxlXCJdID0gOF0gPSBcIk1vZHVsZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJQcm9wZXJ0eVwiXSA9IDldID0gXCJQcm9wZXJ0eVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFdmVudFwiXSA9IDEwXSA9IFwiRXZlbnRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiT3BlcmF0b3JcIl0gPSAxMV0gPSBcIk9wZXJhdG9yXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVuaXRcIl0gPSAxMl0gPSBcIlVuaXRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFsdWVcIl0gPSAxM10gPSBcIlZhbHVlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbnN0YW50XCJdID0gMTRdID0gXCJDb25zdGFudFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFbnVtXCJdID0gMTVdID0gXCJFbnVtXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkVudW1NZW1iZXJcIl0gPSAxNl0gPSBcIkVudW1NZW1iZXJcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiS2V5d29yZFwiXSA9IDE3XSA9IFwiS2V5d29yZFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJUZXh0XCJdID0gMThdID0gXCJUZXh0XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbG9yXCJdID0gMTldID0gXCJDb2xvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGaWxlXCJdID0gMjBdID0gXCJGaWxlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlJlZmVyZW5jZVwiXSA9IDIxXSA9IFwiUmVmZXJlbmNlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkN1c3RvbWNvbG9yXCJdID0gMjJdID0gXCJDdXN0b21jb2xvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGb2xkZXJcIl0gPSAyM10gPSBcIkZvbGRlclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJUeXBlUGFyYW1ldGVyXCJdID0gMjRdID0gXCJUeXBlUGFyYW1ldGVyXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVzZXJcIl0gPSAyNV0gPSBcIlVzZXJcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiSXNzdWVcIl0gPSAyNl0gPSBcIklzc3VlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlNuaXBwZXRcIl0gPSAyN10gPSBcIlNuaXBwZXRcIjtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgQ29tcGxldGlvbkl0ZW1UYWdbQ29tcGxldGlvbkl0ZW1UYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIEhvdyBhIHN1Z2dlc3QgcHJvdmlkZXIgd2FzIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAwXSA9IFwiSW52b2tlXCI7XG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kW0NvbXBsZXRpb25UcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAxXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCJdID0gMl0gPSBcIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnNcIjtcbn0pKENvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgY29udGVudCB3aWRnZXRzLlxuICovXG5leHBvcnQgdmFyIENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcbiAgICAvKipcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgZXhhY3RseSBhdCBhIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiRVhBQ1RcIl0gPSAwXSA9IFwiRVhBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYWJvdmUgYSBwb3NpdGlvblxuICAgICAqL1xuICAgIENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIkFCT1ZFXCJdID0gMV0gPSBcIkFCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGJlbG93IGEgcG9zaXRpb25cbiAgICAgKi9cbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCRUxPV1wiXSA9IDJdID0gXCJCRUxPV1wiO1xufSkoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSB8fCAoQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgcmVhc29uIHRoZSBjdXJzb3IgaGFzIGNoYW5nZWQgaXRzIHBvc2l0aW9uLlxuICovXG5leHBvcnQgdmFyIEN1cnNvckNoYW5nZVJlYXNvbjtcbihmdW5jdGlvbiAoQ3Vyc29yQ2hhbmdlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVW5rbm93biBvciBub3Qgc2V0LlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJOb3RTZXRcIl0gPSAwXSA9IFwiTm90U2V0XCI7XG4gICAgLyoqXG4gICAgICogQSBgbW9kZWwuc2V0VmFsdWUoKWAgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiQ29udGVudEZsdXNoXCJdID0gMV0gPSBcIkNvbnRlbnRGbHVzaFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgbW9kZWxgIGhhcyBiZWVuIGNoYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGN1cnNvciBhbmQgdGhlIGN1cnNvciByZWNvdmVycyBpdHMgcG9zaXRpb24gZnJvbSBhc3NvY2lhdGVkIG1hcmtlcnMuXG4gICAgICovXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlY292ZXJGcm9tTWFya2Vyc1wiXSA9IDJdID0gXCJSZWNvdmVyRnJvbU1hcmtlcnNcIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYW4gZXhwbGljaXQgdXNlciBnZXN0dXJlLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJFeHBsaWNpdFwiXSA9IDNdID0gXCJFeHBsaWNpdFwiO1xuICAgIC8qKlxuICAgICAqIFRoZXJlIHdhcyBhIFBhc3RlLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJQYXN0ZVwiXSA9IDRdID0gXCJQYXN0ZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZXJlIHdhcyBhbiBVbmRvLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJVbmRvXCJdID0gNV0gPSBcIlVuZG9cIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYSBSZWRvLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJSZWRvXCJdID0gNl0gPSBcIlJlZG9cIjtcbn0pKEN1cnNvckNoYW5nZVJlYXNvbiB8fCAoQ3Vyc29yQ2hhbmdlUmVhc29uID0ge30pKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgZW5kIG9mIGxpbmUgdG8gdXNlIHdoZW4gaW5zdGFudGlhdGluZyBtb2RlbHMuXG4gKi9cbmV4cG9ydCB2YXIgRGVmYXVsdEVuZE9mTGluZTtcbihmdW5jdGlvbiAoRGVmYXVsdEVuZE9mTGluZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBEZWZhdWx0RW5kT2ZMaW5lW0RlZmF1bHRFbmRPZkxpbmVbXCJMRlwiXSA9IDFdID0gXCJMRlwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIERlZmF1bHRFbmRPZkxpbmVbRGVmYXVsdEVuZE9mTGluZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xufSkoRGVmYXVsdEVuZE9mTGluZSB8fCAoRGVmYXVsdEVuZE9mTGluZSA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJSZWFkXCJdID0gMV0gPSBcIlJlYWRcIjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJXcml0ZVwiXSA9IDJdID0gXCJXcml0ZVwiO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGF1dG8gaW5kZW50YXRpb24gaW4gdGhlIGVkaXRvclxuICovXG5leHBvcnQgdmFyIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneTtcbihmdW5jdGlvbiAoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5KSB7XG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJLZWVwXCJdID0gMV0gPSBcIktlZXBcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQnJhY2tldHNcIl0gPSAyXSA9IFwiQnJhY2tldHNcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQWR2YW5jZWRcIl0gPSAzXSA9IFwiQWR2YW5jZWRcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiRnVsbFwiXSA9IDRdID0gXCJGdWxsXCI7XG59KShFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgfHwgKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSA9IHt9KSk7XG5leHBvcnQgdmFyIEVkaXRvck9wdGlvbjtcbihmdW5jdGlvbiAoRWRpdG9yT3B0aW9uKSB7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2VwdFN1Z2dlc3Rpb25PbkNvbW1pdENoYXJhY3RlclwiXSA9IDBdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIl0gPSAxXSA9IFwiYWNjZXB0U3VnZ2VzdGlvbk9uRW50ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVN1cHBvcnRcIl0gPSAyXSA9IFwiYWNjZXNzaWJpbGl0eVN1cHBvcnRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVBhZ2VTaXplXCJdID0gM10gPSBcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhcmlhTGFiZWxcIl0gPSA0XSA9IFwiYXJpYUxhYmVsXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nQnJhY2tldHNcIl0gPSA1XSA9IFwiYXV0b0Nsb3NpbmdCcmFja2V0c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiXSA9IDZdID0gXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ092ZXJ0eXBlXCJdID0gN10gPSBcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b0Nsb3NpbmdRdW90ZXNcIl0gPSA4XSA9IFwiYXV0b0Nsb3NpbmdRdW90ZXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b0luZGVudFwiXSA9IDldID0gXCJhdXRvSW5kZW50XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9tYXRpY0xheW91dFwiXSA9IDEwXSA9IFwiYXV0b21hdGljTGF5b3V0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9TdXJyb3VuZFwiXSA9IDExXSA9IFwiYXV0b1N1cnJvdW5kXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImJyYWNrZXRQYWlyQ29sb3JpemF0aW9uXCJdID0gMTJdID0gXCJicmFja2V0UGFpckNvbG9yaXphdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJndWlkZXNcIl0gPSAxM10gPSBcImd1aWRlc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2RlTGVuc1wiXSA9IDE0XSA9IFwiY29kZUxlbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250RmFtaWx5XCJdID0gMTVdID0gXCJjb2RlTGVuc0ZvbnRGYW1pbHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250U2l6ZVwiXSA9IDE2XSA9IFwiY29kZUxlbnNGb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2xvckRlY29yYXRvcnNcIl0gPSAxN10gPSBcImNvbG9yRGVjb3JhdG9yc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2x1bW5TZWxlY3Rpb25cIl0gPSAxOF0gPSBcImNvbHVtblNlbGVjdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb21tZW50c1wiXSA9IDE5XSA9IFwiY29tbWVudHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29udGV4dG1lbnVcIl0gPSAyMF0gPSBcImNvbnRleHRtZW51XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvcHlXaXRoU3ludGF4SGlnaGxpZ2h0aW5nXCJdID0gMjFdID0gXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JCbGlua2luZ1wiXSA9IDIyXSA9IFwiY3Vyc29yQmxpbmtpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yU21vb3RoQ2FyZXRBbmltYXRpb25cIl0gPSAyM10gPSBcImN1cnNvclNtb290aENhcmV0QW5pbWF0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN0eWxlXCJdID0gMjRdID0gXCJjdXJzb3JTdHlsZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCJdID0gMjVdID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclN1cnJvdW5kaW5nTGluZXNTdHlsZVwiXSA9IDI2XSA9IFwiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1N0eWxlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvcldpZHRoXCJdID0gMjddID0gXCJjdXJzb3JXaWR0aFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCJdID0gMjhdID0gXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRpc2FibGVNb25vc3BhY2VPcHRpbWl6YXRpb25zXCJdID0gMjldID0gXCJkaXNhYmxlTW9ub3NwYWNlT3B0aW1pemF0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkb21SZWFkT25seVwiXSA9IDMwXSA9IFwiZG9tUmVhZE9ubHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZHJhZ0FuZERyb3BcIl0gPSAzMV0gPSBcImRyYWdBbmREcm9wXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImVtcHR5U2VsZWN0aW9uQ2xpcGJvYXJkXCJdID0gMzJdID0gXCJlbXB0eVNlbGVjdGlvbkNsaXBib2FyZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJleHRyYUVkaXRvckNsYXNzTmFtZVwiXSA9IDMzXSA9IFwiZXh0cmFFZGl0b3JDbGFzc05hbWVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gMzRdID0gXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmluZFwiXSA9IDM1XSA9IFwiZmluZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmaXhlZE92ZXJmbG93V2lkZ2V0c1wiXSA9IDM2XSA9IFwiZml4ZWRPdmVyZmxvd1dpZGdldHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1wiXSA9IDM3XSA9IFwiZm9sZGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nU3RyYXRlZ3lcIl0gPSAzOF0gPSBcImZvbGRpbmdTdHJhdGVneVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nSGlnaGxpZ2h0XCJdID0gMzldID0gXCJmb2xkaW5nSGlnaGxpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdJbXBvcnRzQnlEZWZhdWx0XCJdID0gNDBdID0gXCJmb2xkaW5nSW1wb3J0c0J5RGVmYXVsdFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nTWF4aW11bVJlZ2lvbnNcIl0gPSA0MV0gPSBcImZvbGRpbmdNYXhpbXVtUmVnaW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bmZvbGRPbkNsaWNrQWZ0ZXJFbmRPZkxpbmVcIl0gPSA0Ml0gPSBcInVuZm9sZE9uQ2xpY2tBZnRlckVuZE9mTGluZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250RmFtaWx5XCJdID0gNDNdID0gXCJmb250RmFtaWx5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRJbmZvXCJdID0gNDRdID0gXCJmb250SW5mb1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250TGlnYXR1cmVzXCJdID0gNDVdID0gXCJmb250TGlnYXR1cmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRTaXplXCJdID0gNDZdID0gXCJmb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250V2VpZ2h0XCJdID0gNDddID0gXCJmb250V2VpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvcm1hdE9uUGFzdGVcIl0gPSA0OF0gPSBcImZvcm1hdE9uUGFzdGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9ybWF0T25UeXBlXCJdID0gNDldID0gXCJmb3JtYXRPblR5cGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ2x5cGhNYXJnaW5cIl0gPSA1MF0gPSBcImdseXBoTWFyZ2luXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImdvdG9Mb2NhdGlvblwiXSA9IDUxXSA9IFwiZ290b0xvY2F0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImhpZGVDdXJzb3JJbk92ZXJ2aWV3UnVsZXJcIl0gPSA1Ml0gPSBcImhpZGVDdXJzb3JJbk92ZXJ2aWV3UnVsZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaG92ZXJcIl0gPSA1M10gPSBcImhvdmVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImluRGlmZkVkaXRvclwiXSA9IDU0XSA9IFwiaW5EaWZmRWRpdG9yXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImlubGluZVN1Z2dlc3RcIl0gPSA1NV0gPSBcImlubGluZVN1Z2dlc3RcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGV0dGVyU3BhY2luZ1wiXSA9IDU2XSA9IFwibGV0dGVyU3BhY2luZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaWdodGJ1bGJcIl0gPSA1N10gPSBcImxpZ2h0YnVsYlwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lRGVjb3JhdGlvbnNXaWR0aFwiXSA9IDU4XSA9IFwibGluZURlY29yYXRpb25zV2lkdGhcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZUhlaWdodFwiXSA9IDU5XSA9IFwibGluZUhlaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5lTnVtYmVyc1wiXSA9IDYwXSA9IFwibGluZU51bWJlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZU51bWJlcnNNaW5DaGFyc1wiXSA9IDYxXSA9IFwibGluZU51bWJlcnNNaW5DaGFyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5rZWRFZGl0aW5nXCJdID0gNjJdID0gXCJsaW5rZWRFZGl0aW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmtzXCJdID0gNjNdID0gXCJsaW5rc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtYXRjaEJyYWNrZXRzXCJdID0gNjRdID0gXCJtYXRjaEJyYWNrZXRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1pbmltYXBcIl0gPSA2NV0gPSBcIm1pbmltYXBcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VTdHlsZVwiXSA9IDY2XSA9IFwibW91c2VTdHlsZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsU2Nyb2xsU2Vuc2l0aXZpdHlcIl0gPSA2N10gPSBcIm1vdXNlV2hlZWxTY3JvbGxTZW5zaXRpdml0eVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsWm9vbVwiXSA9IDY4XSA9IFwibW91c2VXaGVlbFpvb21cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JNZXJnZU92ZXJsYXBwaW5nXCJdID0gNjldID0gXCJtdWx0aUN1cnNvck1lcmdlT3ZlcmxhcHBpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JNb2RpZmllclwiXSA9IDcwXSA9IFwibXVsdGlDdXJzb3JNb2RpZmllclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvclBhc3RlXCJdID0gNzFdID0gXCJtdWx0aUN1cnNvclBhc3RlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCJdID0gNzJdID0gXCJvY2N1cnJlbmNlc0hpZ2hsaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJvdmVydmlld1J1bGVyQm9yZGVyXCJdID0gNzNdID0gXCJvdmVydmlld1J1bGVyQm9yZGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJMYW5lc1wiXSA9IDc0XSA9IFwib3ZlcnZpZXdSdWxlckxhbmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhZGRpbmdcIl0gPSA3NV0gPSBcInBhZGRpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGFyYW1ldGVySGludHNcIl0gPSA3Nl0gPSBcInBhcmFtZXRlckhpbnRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBlZWtXaWRnZXREZWZhdWx0Rm9jdXNcIl0gPSA3N10gPSBcInBlZWtXaWRnZXREZWZhdWx0Rm9jdXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGVmaW5pdGlvbkxpbmtPcGVuc0luUGVla1wiXSA9IDc4XSA9IFwiZGVmaW5pdGlvbkxpbmtPcGVuc0luUGVla1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJxdWlja1N1Z2dlc3Rpb25zXCJdID0gNzldID0gXCJxdWlja1N1Z2dlc3Rpb25zXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInF1aWNrU3VnZ2VzdGlvbnNEZWxheVwiXSA9IDgwXSA9IFwicXVpY2tTdWdnZXN0aW9uc0RlbGF5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlYWRPbmx5XCJdID0gODFdID0gXCJyZWFkT25seVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5hbWVPblR5cGVcIl0gPSA4Ml0gPSBcInJlbmFtZU9uVHlwZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJDb250cm9sQ2hhcmFjdGVyc1wiXSA9IDgzXSA9IFwicmVuZGVyQ29udHJvbENoYXJhY3RlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyRmluYWxOZXdsaW5lXCJdID0gODRdID0gXCJyZW5kZXJGaW5hbE5ld2xpbmVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyTGluZUhpZ2hsaWdodFwiXSA9IDg1XSA9IFwicmVuZGVyTGluZUhpZ2hsaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJMaW5lSGlnaGxpZ2h0T25seVdoZW5Gb2N1c1wiXSA9IDg2XSA9IFwicmVuZGVyTGluZUhpZ2hsaWdodE9ubHlXaGVuRm9jdXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyVmFsaWRhdGlvbkRlY29yYXRpb25zXCJdID0gODddID0gXCJyZW5kZXJWYWxpZGF0aW9uRGVjb3JhdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyV2hpdGVzcGFjZVwiXSA9IDg4XSA9IFwicmVuZGVyV2hpdGVzcGFjZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCJdID0gODldID0gXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJvdW5kZWRTZWxlY3Rpb25cIl0gPSA5MF0gPSBcInJvdW5kZWRTZWxlY3Rpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicnVsZXJzXCJdID0gOTFdID0gXCJydWxlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsYmFyXCJdID0gOTJdID0gXCJzY3JvbGxiYXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsQmV5b25kTGFzdENvbHVtblwiXSA9IDkzXSA9IFwic2Nyb2xsQmV5b25kTGFzdENvbHVtblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxCZXlvbmRMYXN0TGluZVwiXSA9IDk0XSA9IFwic2Nyb2xsQmV5b25kTGFzdExpbmVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsUHJlZG9taW5hbnRBeGlzXCJdID0gOTVdID0gXCJzY3JvbGxQcmVkb21pbmFudEF4aXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0aW9uQ2xpcGJvYXJkXCJdID0gOTZdID0gXCJzZWxlY3Rpb25DbGlwYm9hcmRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0aW9uSGlnaGxpZ2h0XCJdID0gOTddID0gXCJzZWxlY3Rpb25IaWdobGlnaHRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0T25MaW5lTnVtYmVyc1wiXSA9IDk4XSA9IFwic2VsZWN0T25MaW5lTnVtYmVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93Rm9sZGluZ0NvbnRyb2xzXCJdID0gOTldID0gXCJzaG93Rm9sZGluZ0NvbnRyb2xzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dVbnVzZWRcIl0gPSAxMDBdID0gXCJzaG93VW51c2VkXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNuaXBwZXRTdWdnZXN0aW9uc1wiXSA9IDEwMV0gPSBcInNuaXBwZXRTdWdnZXN0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbWFydFNlbGVjdFwiXSA9IDEwMl0gPSBcInNtYXJ0U2VsZWN0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNtb290aFNjcm9sbGluZ1wiXSA9IDEwM10gPSBcInNtb290aFNjcm9sbGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdGlja3lUYWJTdG9wc1wiXSA9IDEwNF0gPSBcInN0aWNreVRhYlN0b3BzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIl0gPSAxMDVdID0gXCJzdG9wUmVuZGVyaW5nTGluZUFmdGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RcIl0gPSAxMDZdID0gXCJzdWdnZXN0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RGb250U2l6ZVwiXSA9IDEwN10gPSBcInN1Z2dlc3RGb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0TGluZUhlaWdodFwiXSA9IDEwOF0gPSBcInN1Z2dlc3RMaW5lSGVpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RPblRyaWdnZXJDaGFyYWN0ZXJzXCJdID0gMTA5XSA9IFwic3VnZ2VzdE9uVHJpZ2dlckNoYXJhY3RlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdFNlbGVjdGlvblwiXSA9IDExMF0gPSBcInN1Z2dlc3RTZWxlY3Rpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiQ29tcGxldGlvblwiXSA9IDExMV0gPSBcInRhYkNvbXBsZXRpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiSW5kZXhcIl0gPSAxMTJdID0gXCJ0YWJJbmRleFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bmljb2RlSGlnaGxpZ2h0aW5nXCJdID0gMTEzXSA9IFwidW5pY29kZUhpZ2hsaWdodGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1bnVzdWFsTGluZVRlcm1pbmF0b3JzXCJdID0gMTE0XSA9IFwidW51c3VhbExpbmVUZXJtaW5hdG9yc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1c2VTaGFkb3dET01cIl0gPSAxMTVdID0gXCJ1c2VTaGFkb3dET01cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widXNlVGFiU3RvcHNcIl0gPSAxMTZdID0gXCJ1c2VUYWJTdG9wc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkU2VwYXJhdG9yc1wiXSA9IDExN10gPSBcIndvcmRTZXBhcmF0b3JzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwXCJdID0gMTE4XSA9IFwid29yZFdyYXBcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0FmdGVyQ2hhcmFjdGVyc1wiXSA9IDExOV0gPSBcIndvcmRXcmFwQnJlYWtBZnRlckNoYXJhY3RlcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBCcmVha0JlZm9yZUNoYXJhY3RlcnNcIl0gPSAxMjBdID0gXCJ3b3JkV3JhcEJyZWFrQmVmb3JlQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcENvbHVtblwiXSA9IDEyMV0gPSBcIndvcmRXcmFwQ29sdW1uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwT3ZlcnJpZGUxXCJdID0gMTIyXSA9IFwid29yZFdyYXBPdmVycmlkZTFcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBPdmVycmlkZTJcIl0gPSAxMjNdID0gXCJ3b3JkV3JhcE92ZXJyaWRlMlwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZGVudFwiXSA9IDEyNF0gPSBcIndyYXBwaW5nSW5kZW50XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nU3RyYXRlZ3lcIl0gPSAxMjVdID0gXCJ3cmFwcGluZ1N0cmF0ZWd5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dEZXByZWNhdGVkXCJdID0gMTI2XSA9IFwic2hvd0RlcHJlY2F0ZWRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5sYXlIaW50c1wiXSA9IDEyN10gPSBcImlubGF5SGludHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZWRpdG9yQ2xhc3NOYW1lXCJdID0gMTI4XSA9IFwiZWRpdG9yQ2xhc3NOYW1lXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBpeGVsUmF0aW9cIl0gPSAxMjldID0gXCJwaXhlbFJhdGlvXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInRhYkZvY3VzTW9kZVwiXSA9IDEzMF0gPSBcInRhYkZvY3VzTW9kZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsYXlvdXRJbmZvXCJdID0gMTMxXSA9IFwibGF5b3V0SW5mb1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZm9cIl0gPSAxMzJdID0gXCJ3cmFwcGluZ0luZm9cIjtcbn0pKEVkaXRvck9wdGlvbiB8fCAoRWRpdG9yT3B0aW9uID0ge30pKTtcbi8qKlxuICogRW5kIG9mIGxpbmUgY2hhcmFjdGVyIHByZWZlcmVuY2UuXG4gKi9cbmV4cG9ydCB2YXIgRW5kT2ZMaW5lUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoRW5kT2ZMaW5lUHJlZmVyZW5jZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyIGlkZW50aWZpZWQgaW4gdGhlIHRleHQgYnVmZmVyLlxuICAgICAqL1xuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIlRleHREZWZpbmVkXCJdID0gMF0gPSBcIlRleHREZWZpbmVkXCI7XG4gICAgLyoqXG4gICAgICogVXNlIGxpbmUgZmVlZCAoXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIkxGXCJdID0gMV0gPSBcIkxGXCI7XG4gICAgLyoqXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiQ1JMRlwiXSA9IDJdID0gXCJDUkxGXCI7XG59KShFbmRPZkxpbmVQcmVmZXJlbmNlIHx8IChFbmRPZkxpbmVQcmVmZXJlbmNlID0ge30pKTtcbi8qKlxuICogRW5kIG9mIGxpbmUgY2hhcmFjdGVyIHByZWZlcmVuY2UuXG4gKi9cbmV4cG9ydCB2YXIgRW5kT2ZMaW5lU2VxdWVuY2U7XG4oZnVuY3Rpb24gKEVuZE9mTGluZVNlcXVlbmNlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIGxpbmUgZmVlZCAoXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIEVuZE9mTGluZVNlcXVlbmNlW0VuZE9mTGluZVNlcXVlbmNlW1wiTEZcIl0gPSAwXSA9IFwiTEZcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWQgKFxcclxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBFbmRPZkxpbmVTZXF1ZW5jZVtFbmRPZkxpbmVTZXF1ZW5jZVtcIkNSTEZcIl0gPSAxXSA9IFwiQ1JMRlwiO1xufSkoRW5kT2ZMaW5lU2VxdWVuY2UgfHwgKEVuZE9mTGluZVNlcXVlbmNlID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHdoYXQgdG8gZG8gd2l0aCB0aGUgaW5kZW50YXRpb24gd2hlbiBwcmVzc2luZyBFbnRlci5cbiAqL1xuZXhwb3J0IHZhciBJbmRlbnRBY3Rpb247XG4oZnVuY3Rpb24gKEluZGVudEFjdGlvbikge1xuICAgIC8qKlxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgY29weSB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uLlxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGluZGVudCBvbmNlIChyZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uKS5cbiAgICAgKi9cbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50XCJdID0gMV0gPSBcIkluZGVudFwiO1xuICAgIC8qKlxuICAgICAqIEluc2VydCB0d28gbmV3IGxpbmVzOlxuICAgICAqICAtIHRoZSBmaXJzdCBvbmUgaW5kZW50ZWQgd2hpY2ggd2lsbCBob2xkIHRoZSBjdXJzb3JcbiAgICAgKiAgLSB0aGUgc2Vjb25kIG9uZSBhdCB0aGUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbFxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJJbmRlbnRPdXRkZW50XCJdID0gMl0gPSBcIkluZGVudE91dGRlbnRcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIG91dGRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXG4gICAgICovXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIk91dGRlbnRcIl0gPSAzXSA9IFwiT3V0ZGVudFwiO1xufSkoSW5kZW50QWN0aW9uIHx8IChJbmRlbnRBY3Rpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBJbmplY3RlZFRleHRDdXJzb3JTdG9wcztcbihmdW5jdGlvbiAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMpIHtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkJvdGhcIl0gPSAwXSA9IFwiQm90aFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkxlZnRcIl0gPSAyXSA9IFwiTGVmdFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiTm9uZVwiXSA9IDNdID0gXCJOb25lXCI7XG59KShJbmplY3RlZFRleHRDdXJzb3JTdG9wcyB8fCAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiVHlwZVwiXSA9IDFdID0gXCJUeXBlXCI7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiUGFyYW1ldGVyXCJdID0gMl0gPSBcIlBhcmFtZXRlclwiO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG4vKipcbiAqIEhvdyBhbiB7QGxpbmsgSW5saW5lQ29tcGxldGlvbnNQcm92aWRlciBpbmxpbmUgY29tcGxldGlvbiBwcm92aWRlcn0gd2FzIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHdoaWxlIGVkaXRpbmcuXG4gICAgICogSXQgaXMgc3VmZmljaWVudCB0byByZXR1cm4gYSBzaW5nbGUgY29tcGxldGlvbiBpdGVtIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMF0gPSBcIkF1dG9tYXRpY1wiO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGEgdXNlciBnZXN0dXJlLlxuICAgICAqIFJldHVybiBtdWx0aXBsZSBjb21wbGV0aW9uIGl0ZW1zIHRvIGVuYWJsZSBjeWNsaW5nIHRocm91Z2ggdGhlbS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiRXhwbGljaXRcIl0gPSAxXSA9IFwiRXhwbGljaXRcIjtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogVmlydHVhbCBLZXkgQ29kZXMsIHRoZSB2YWx1ZSBkb2VzIG5vdCBob2xkIGFueSBpbmhlcmVudCBtZWFuaW5nLlxuICogSW5zcGlyZWQgc29tZXdoYXQgZnJvbSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDM3NTczMSh2PXZzLjg1KS5hc3B4XG4gKiBCdXQgdGhlc2UgYXJlIFwibW9yZSBnZW5lcmFsXCIsIGFzIHRoZXkgc2hvdWxkIHdvcmsgYWNyb3NzIGJyb3dzZXJzICYgT1Ngcy5cbiAqL1xuZXhwb3J0IHZhciBLZXlDb2RlO1xuKGZ1bmN0aW9uIChLZXlDb2RlKSB7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGVwZW5kc09uS2JMYXlvdXRcIl0gPSAtMV0gPSBcIkRlcGVuZHNPbktiTGF5b3V0XCI7XG4gICAgLyoqXG4gICAgICogUGxhY2VkIGZpcnN0IHRvIGNvdmVyIHRoZSAwIHZhbHVlIG9mIHRoZSBlbnVtLlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJhY2tzcGFjZVwiXSA9IDFdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJUYWJcIl0gPSAyXSA9IFwiVGFiXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRW50ZXJcIl0gPSAzXSA9IFwiRW50ZXJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJTaGlmdFwiXSA9IDRdID0gXCJTaGlmdFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkN0cmxcIl0gPSA1XSA9IFwiQ3RybFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFsdFwiXSA9IDZdID0gXCJBbHRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQYXVzZUJyZWFrXCJdID0gN10gPSBcIlBhdXNlQnJlYWtcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDYXBzTG9ja1wiXSA9IDhdID0gXCJDYXBzTG9ja1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVzY2FwZVwiXSA9IDldID0gXCJFc2NhcGVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJTcGFjZVwiXSA9IDEwXSA9IFwiU3BhY2VcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQYWdlVXBcIl0gPSAxMV0gPSBcIlBhZ2VVcFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBhZ2VEb3duXCJdID0gMTJdID0gXCJQYWdlRG93blwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVuZFwiXSA9IDEzXSA9IFwiRW5kXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSG9tZVwiXSA9IDE0XSA9IFwiSG9tZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxlZnRBcnJvd1wiXSA9IDE1XSA9IFwiTGVmdEFycm93XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVXBBcnJvd1wiXSA9IDE2XSA9IFwiVXBBcnJvd1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlJpZ2h0QXJyb3dcIl0gPSAxN10gPSBcIlJpZ2h0QXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEb3duQXJyb3dcIl0gPSAxOF0gPSBcIkRvd25BcnJvd1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkluc2VydFwiXSA9IDE5XSA9IFwiSW5zZXJ0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGVsZXRlXCJdID0gMjBdID0gXCJEZWxldGVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDBcIl0gPSAyMV0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0MVwiXSA9IDIyXSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQyXCJdID0gMjNdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDNcIl0gPSAyNF0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0NFwiXSA9IDI1XSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ1XCJdID0gMjZdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDZcIl0gPSAyN10gPSBcIkRpZ2l0NlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0N1wiXSA9IDI4XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ4XCJdID0gMjldID0gXCJEaWdpdDhcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDlcIl0gPSAzMF0gPSBcIkRpZ2l0OVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUFcIl0gPSAzMV0gPSBcIktleUFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlCXCJdID0gMzJdID0gXCJLZXlCXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5Q1wiXSA9IDMzXSA9IFwiS2V5Q1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleURcIl0gPSAzNF0gPSBcIktleURcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlFXCJdID0gMzVdID0gXCJLZXlFXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RlwiXSA9IDM2XSA9IFwiS2V5RlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUdcIl0gPSAzN10gPSBcIktleUdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlIXCJdID0gMzhdID0gXCJLZXlIXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SVwiXSA9IDM5XSA9IFwiS2V5SVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUpcIl0gPSA0MF0gPSBcIktleUpcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlLXCJdID0gNDFdID0gXCJLZXlLXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TFwiXSA9IDQyXSA9IFwiS2V5TFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleU1cIl0gPSA0M10gPSBcIktleU1cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlOXCJdID0gNDRdID0gXCJLZXlOXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5T1wiXSA9IDQ1XSA9IFwiS2V5T1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVBcIl0gPSA0Nl0gPSBcIktleVBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlRXCJdID0gNDddID0gXCJLZXlRXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UlwiXSA9IDQ4XSA9IFwiS2V5UlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVNcIl0gPSA0OV0gPSBcIktleVNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlUXCJdID0gNTBdID0gXCJLZXlUXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VVwiXSA9IDUxXSA9IFwiS2V5VVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVZcIl0gPSA1Ml0gPSBcIktleVZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlXXCJdID0gNTNdID0gXCJLZXlXXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WFwiXSA9IDU0XSA9IFwiS2V5WFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVlcIl0gPSA1NV0gPSBcIktleVlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlaXCJdID0gNTZdID0gXCJLZXlaXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWV0YVwiXSA9IDU3XSA9IFwiTWV0YVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNvbnRleHRNZW51XCJdID0gNThdID0gXCJDb250ZXh0TWVudVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxXCJdID0gNTldID0gXCJGMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyXCJdID0gNjBdID0gXCJGMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYzXCJdID0gNjFdID0gXCJGM1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY0XCJdID0gNjJdID0gXCJGNFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY1XCJdID0gNjNdID0gXCJGNVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY2XCJdID0gNjRdID0gXCJGNlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY3XCJdID0gNjVdID0gXCJGN1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY4XCJdID0gNjZdID0gXCJGOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY5XCJdID0gNjddID0gXCJGOVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMFwiXSA9IDY4XSA9IFwiRjEwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjExXCJdID0gNjldID0gXCJGMTFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTJcIl0gPSA3MF0gPSBcIkYxMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxM1wiXSA9IDcxXSA9IFwiRjEzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE0XCJdID0gNzJdID0gXCJGMTRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTVcIl0gPSA3M10gPSBcIkYxNVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNlwiXSA9IDc0XSA9IFwiRjE2XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE3XCJdID0gNzVdID0gXCJGMTdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMThcIl0gPSA3Nl0gPSBcIkYxOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxOVwiXSA9IDc3XSA9IFwiRjE5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtTG9ja1wiXSA9IDc4XSA9IFwiTnVtTG9ja1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNjcm9sbExvY2tcIl0gPSA3OV0gPSBcIlNjcm9sbExvY2tcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnOzonIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNlbWljb2xvblwiXSA9IDgwXSA9IFwiU2VtaWNvbG9uXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcrJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJz0rJyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFcXVhbFwiXSA9IDgxXSA9IFwiRXF1YWxcIjtcbiAgICAvKipcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJywnIGtleVxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLDwnIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNvbW1hXCJdID0gODJdID0gXCJDb21tYVwiO1xuICAgIC8qKlxuICAgICAqIEZvciBhbnkgY291bnRyeS9yZWdpb24sIHRoZSAnLScga2V5XG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICctXycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWludXNcIl0gPSA4M10gPSBcIk1pbnVzXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICcuJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy4+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQZXJpb2RcIl0gPSA4NF0gPSBcIlBlcmlvZFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcvPycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2xhc2hcIl0gPSA4NV0gPSBcIlNsYXNoXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ2B+JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrcXVvdGVcIl0gPSA4Nl0gPSBcIkJhY2txdW90ZVwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdbeycga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJhY2tldExlZnRcIl0gPSA4N10gPSBcIkJyYWNrZXRMZWZ0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1xcfCcga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQmFja3NsYXNoXCJdID0gODhdID0gXCJCYWNrc2xhc2hcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXX0nIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyYWNrZXRSaWdodFwiXSA9IDg5XSA9IFwiQnJhY2tldFJpZ2h0XCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJydcIicga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUXVvdGVcIl0gPSA5MF0gPSBcIlF1b3RlXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJPRU1fOFwiXSA9IDkxXSA9IFwiT0VNXzhcIjtcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgdGhlIGFuZ2xlIGJyYWNrZXQga2V5IG9yIHRoZSBiYWNrc2xhc2gga2V5IG9uIHRoZSBSVCAxMDIta2V5IGtleWJvYXJkLlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkludGxCYWNrc2xhc2hcIl0gPSA5Ml0gPSBcIkludGxCYWNrc2xhc2hcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQwXCJdID0gOTNdID0gXCJOdW1wYWQwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkMVwiXSA9IDk0XSA9IFwiTnVtcGFkMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDJcIl0gPSA5NV0gPSBcIk51bXBhZDJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQzXCJdID0gOTZdID0gXCJOdW1wYWQzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkNFwiXSA9IDk3XSA9IFwiTnVtcGFkNFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDVcIl0gPSA5OF0gPSBcIk51bXBhZDVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ2XCJdID0gOTldID0gXCJOdW1wYWQ2XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkN1wiXSA9IDEwMF0gPSBcIk51bXBhZDdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ4XCJdID0gMTAxXSA9IFwiTnVtcGFkOFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDlcIl0gPSAxMDJdID0gXCJOdW1wYWQ5XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkTXVsdGlwbHlcIl0gPSAxMDNdID0gXCJOdW1wYWRNdWx0aXBseVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZEFkZFwiXSA9IDEwNF0gPSBcIk51bXBhZEFkZFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9TRVBBUkFUT1JcIl0gPSAxMDVdID0gXCJOVU1QQURfU0VQQVJBVE9SXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkU3VidHJhY3RcIl0gPSAxMDZdID0gXCJOdW1wYWRTdWJ0cmFjdFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZERlY2ltYWxcIl0gPSAxMDddID0gXCJOdW1wYWREZWNpbWFsXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkRGl2aWRlXCJdID0gMTA4XSA9IFwiTnVtcGFkRGl2aWRlXCI7XG4gICAgLyoqXG4gICAgICogQ292ZXIgYWxsIGtleSBjb2RlcyB3aGVuIElNRSBpcyBwcm9jZXNzaW5nIGlucHV0LlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9JTl9DT01QT1NJVElPTlwiXSA9IDEwOV0gPSBcIktFWV9JTl9DT01QT1NJVElPTlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFCTlRfQzFcIl0gPSAxMTBdID0gXCJBQk5UX0MxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQUJOVF9DMlwiXSA9IDExMV0gPSBcIkFCTlRfQzJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBdWRpb1ZvbHVtZU11dGVcIl0gPSAxMTJdID0gXCJBdWRpb1ZvbHVtZU11dGVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBdWRpb1ZvbHVtZVVwXCJdID0gMTEzXSA9IFwiQXVkaW9Wb2x1bWVVcFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkF1ZGlvVm9sdW1lRG93blwiXSA9IDExNF0gPSBcIkF1ZGlvVm9sdW1lRG93blwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyb3dzZXJTZWFyY2hcIl0gPSAxMTVdID0gXCJCcm93c2VyU2VhcmNoXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckhvbWVcIl0gPSAxMTZdID0gXCJCcm93c2VySG9tZVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyb3dzZXJCYWNrXCJdID0gMTE3XSA9IFwiQnJvd3NlckJhY2tcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcm93c2VyRm9yd2FyZFwiXSA9IDExOF0gPSBcIkJyb3dzZXJGb3J3YXJkXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTWVkaWFUcmFja05leHRcIl0gPSAxMTldID0gXCJNZWRpYVRyYWNrTmV4dFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1lZGlhVHJhY2tQcmV2aW91c1wiXSA9IDEyMF0gPSBcIk1lZGlhVHJhY2tQcmV2aW91c1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1lZGlhU3RvcFwiXSA9IDEyMV0gPSBcIk1lZGlhU3RvcFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1lZGlhUGxheVBhdXNlXCJdID0gMTIyXSA9IFwiTWVkaWFQbGF5UGF1c2VcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMYXVuY2hNZWRpYVBsYXllclwiXSA9IDEyM10gPSBcIkxhdW5jaE1lZGlhUGxheWVyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTGF1bmNoTWFpbFwiXSA9IDEyNF0gPSBcIkxhdW5jaE1haWxcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMYXVuY2hBcHAyXCJdID0gMTI1XSA9IFwiTGF1bmNoQXBwMlwiO1xuICAgIC8qKlxuICAgICAqIFZLX0NMRUFSLCAweDBDLCBDTEVBUiBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDbGVhclwiXSA9IDEyNl0gPSBcIkNsZWFyXCI7XG4gICAgLyoqXG4gICAgICogUGxhY2VkIGxhc3QgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZW51bS5cbiAgICAgKiBQbGVhc2UgZG8gbm90IGRlcGVuZCBvbiB0aGlzIHZhbHVlIVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1BWF9WQUxVRVwiXSA9IDEyN10gPSBcIk1BWF9WQUxVRVwiO1xufSkoS2V5Q29kZSB8fCAoS2V5Q29kZSA9IHt9KSk7XG5leHBvcnQgdmFyIE1hcmtlclNldmVyaXR5O1xuKGZ1bmN0aW9uIChNYXJrZXJTZXZlcml0eSkge1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiSGludFwiXSA9IDFdID0gXCJIaW50XCI7XG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIldhcm5pbmdcIl0gPSA0XSA9IFwiV2FybmluZ1wiO1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiRXJyb3JcIl0gPSA4XSA9IFwiRXJyb3JcIjtcbn0pKE1hcmtlclNldmVyaXR5IHx8IChNYXJrZXJTZXZlcml0eSA9IHt9KSk7XG5leHBvcnQgdmFyIE1hcmtlclRhZztcbihmdW5jdGlvbiAoTWFya2VyVGFnKSB7XG4gICAgTWFya2VyVGFnW01hcmtlclRhZ1tcIlVubmVjZXNzYXJ5XCJdID0gMV0gPSBcIlVubmVjZXNzYXJ5XCI7XG4gICAgTWFya2VyVGFnW01hcmtlclRhZ1tcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xufSkoTWFya2VyVGFnIHx8IChNYXJrZXJUYWcgPSB7fSkpO1xuLyoqXG4gKiBQb3NpdGlvbiBpbiB0aGUgbWluaW1hcCB0byByZW5kZXIgdGhlIGRlY29yYXRpb24uXG4gKi9cbmV4cG9ydCB2YXIgTWluaW1hcFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChNaW5pbWFwUG9zaXRpb24pIHtcbiAgICBNaW5pbWFwUG9zaXRpb25bTWluaW1hcFBvc2l0aW9uW1wiSW5saW5lXCJdID0gMV0gPSBcIklubGluZVwiO1xuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJHdXR0ZXJcIl0gPSAyXSA9IFwiR3V0dGVyXCI7XG59KShNaW5pbWFwUG9zaXRpb24gfHwgKE1pbmltYXBQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFR5cGUgb2YgaGl0IGVsZW1lbnQgd2l0aCB0aGUgbW91c2UgaW4gdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBNb3VzZVRhcmdldFR5cGU7XG4oZnVuY3Rpb24gKE1vdXNlVGFyZ2V0VHlwZSkge1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgdGV4dGFyZWEgdXNlZCBmb3IgaW5wdXQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlRFWFRBUkVBXCJdID0gMV0gPSBcIlRFWFRBUkVBXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBnbHlwaCBtYXJnaW5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0dMWVBIX01BUkdJTlwiXSA9IDJdID0gXCJHVVRURVJfR0xZUEhfTUFSR0lOXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBsaW5lIG51bWJlcnNcbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfTlVNQkVSU1wiXSA9IDNdID0gXCJHVVRURVJfTElORV9OVU1CRVJTXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBsaW5lIGRlY29yYXRpb25zXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9MSU5FX0RFQ09SQVRJT05TXCJdID0gNF0gPSBcIkdVVFRFUl9MSU5FX0RFQ09SQVRJT05TXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSB3aGl0ZXNwYWNlIGxlZnQgaW4gdGhlIGd1dHRlciBieSBhIHZpZXcgem9uZS5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX1ZJRVdfWk9ORVwiXSA9IDVdID0gXCJHVVRURVJfVklFV19aT05FXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRleHQgaW4gdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfVEVYVFwiXSA9IDZdID0gXCJDT05URU5UX1RFWFRcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgZW1wdHkgc3BhY2UgaW4gdGhlIGNvbnRlbnQgKGUuZy4gYWZ0ZXIgbGluZSB0ZXh0IG9yIGJlbG93IGxhc3QgbGluZSlcbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9FTVBUWVwiXSA9IDddID0gXCJDT05URU5UX0VNUFRZXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgdmlldyB6b25lIGluIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1ZJRVdfWk9ORVwiXSA9IDhdID0gXCJDT05URU5UX1ZJRVdfWk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIGNvbnRlbnQgd2lkZ2V0LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1dJREdFVFwiXSA9IDldID0gXCJDT05URU5UX1dJREdFVFwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgZGVjb3JhdGlvbnMgb3ZlcnZpZXcgcnVsZXIuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJWSUVXX1JVTEVSXCJdID0gMTBdID0gXCJPVkVSVklFV19SVUxFUlwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIHNjcm9sbGJhci5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiU0NST0xMQkFSXCJdID0gMTFdID0gXCJTQ1JPTExCQVJcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYW4gb3ZlcmxheSB3aWRnZXQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJMQVlfV0lER0VUXCJdID0gMTJdID0gXCJPVkVSTEFZX1dJREdFVFwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiT1VUU0lERV9FRElUT1JcIl0gPSAxM10gPSBcIk9VVFNJREVfRURJVE9SXCI7XG59KShNb3VzZVRhcmdldFR5cGUgfHwgKE1vdXNlVGFyZ2V0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgcG9zaXRpb25pbmcgcHJlZmVyZW5jZSBmb3IgcmVuZGVyaW5nIG92ZXJsYXkgd2lkZ2V0cy5cbiAqL1xuZXhwb3J0IHZhciBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlKSB7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyXG4gICAgICovXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiVE9QX1JJR0hUX0NPUk5FUlwiXSA9IDBdID0gXCJUT1BfUklHSFRfQ09STkVSXCI7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSBib3R0b20gcmlnaHQgY29ybmVyXG4gICAgICovXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiQk9UVE9NX1JJR0hUX0NPUk5FUlwiXSA9IDFdID0gXCJCT1RUT01fUklHSFRfQ09STkVSXCI7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSB0b3AgY2VudGVyXG4gICAgICovXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiVE9QX0NFTlRFUlwiXSA9IDJdID0gXCJUT1BfQ0VOVEVSXCI7XG59KShPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlIHx8IChPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlID0ge30pKTtcbi8qKlxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgb3ZlcnZpZXcgcnVsZXIgb2YgdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBPdmVydmlld1J1bGVyTGFuZTtcbihmdW5jdGlvbiAoT3ZlcnZpZXdSdWxlckxhbmUpIHtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkxlZnRcIl0gPSAxXSA9IFwiTGVmdFwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkZ1bGxcIl0gPSA3XSA9IFwiRnVsbFwiO1xufSkoT3ZlcnZpZXdSdWxlckxhbmUgfHwgKE92ZXJ2aWV3UnVsZXJMYW5lID0ge30pKTtcbmV4cG9ydCB2YXIgUG9zaXRpb25BZmZpbml0eTtcbihmdW5jdGlvbiAoUG9zaXRpb25BZmZpbml0eSkge1xuICAgIC8qKlxuICAgICAqIFByZWZlcnMgdGhlIGxlZnQgbW9zdCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIFBvc2l0aW9uQWZmaW5pdHlbUG9zaXRpb25BZmZpbml0eVtcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xuICAgIC8qKlxuICAgICAqIFByZWZlcnMgdGhlIHJpZ2h0IG1vc3QgcG9zaXRpb24uXG4gICAgKi9cbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xuICAgIC8qKlxuICAgICAqIE5vIHByZWZlcmVuY2UuXG4gICAgKi9cbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbn0pKFBvc2l0aW9uQWZmaW5pdHkgfHwgKFBvc2l0aW9uQWZmaW5pdHkgPSB7fSkpO1xuZXhwb3J0IHZhciBSZW5kZXJMaW5lTnVtYmVyc1R5cGU7XG4oZnVuY3Rpb24gKFJlbmRlckxpbmVOdW1iZXJzVHlwZSkge1xuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJPZmZcIl0gPSAwXSA9IFwiT2ZmXCI7XG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIk9uXCJdID0gMV0gPSBcIk9uXCI7XG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIlJlbGF0aXZlXCJdID0gMl0gPSBcIlJlbGF0aXZlXCI7XG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIkludGVydmFsXCJdID0gM10gPSBcIkludGVydmFsXCI7XG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIkN1c3RvbVwiXSA9IDRdID0gXCJDdXN0b21cIjtcbn0pKFJlbmRlckxpbmVOdW1iZXJzVHlwZSB8fCAoUmVuZGVyTGluZU51bWJlcnNUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgUmVuZGVyTWluaW1hcDtcbihmdW5jdGlvbiAoUmVuZGVyTWluaW1hcCkge1xuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIkJsb2Nrc1wiXSA9IDJdID0gXCJCbG9ja3NcIjtcbn0pKFJlbmRlck1pbmltYXAgfHwgKFJlbmRlck1pbmltYXAgPSB7fSkpO1xuZXhwb3J0IHZhciBTY3JvbGxUeXBlO1xuKGZ1bmN0aW9uIChTY3JvbGxUeXBlKSB7XG4gICAgU2Nyb2xsVHlwZVtTY3JvbGxUeXBlW1wiU21vb3RoXCJdID0gMF0gPSBcIlNtb290aFwiO1xuICAgIFNjcm9sbFR5cGVbU2Nyb2xsVHlwZVtcIkltbWVkaWF0ZVwiXSA9IDFdID0gXCJJbW1lZGlhdGVcIjtcbn0pKFNjcm9sbFR5cGUgfHwgKFNjcm9sbFR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBTY3JvbGxiYXJWaXNpYmlsaXR5O1xuKGZ1bmN0aW9uIChTY3JvbGxiYXJWaXNpYmlsaXR5KSB7XG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiQXV0b1wiXSA9IDFdID0gXCJBdXRvXCI7XG4gICAgU2Nyb2xsYmFyVmlzaWJpbGl0eVtTY3JvbGxiYXJWaXNpYmlsaXR5W1wiSGlkZGVuXCJdID0gMl0gPSBcIkhpZGRlblwiO1xuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIlZpc2libGVcIl0gPSAzXSA9IFwiVmlzaWJsZVwiO1xufSkoU2Nyb2xsYmFyVmlzaWJpbGl0eSB8fCAoU2Nyb2xsYmFyVmlzaWJpbGl0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaXJlY3Rpb24gb2YgYSBzZWxlY3Rpb24uXG4gKi9cbmV4cG9ydCB2YXIgU2VsZWN0aW9uRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25EaXJlY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIHN0YXJ0cyBhYm92ZSB3aGVyZSBpdCBlbmRzLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbkRpcmVjdGlvbltTZWxlY3Rpb25EaXJlY3Rpb25bXCJMVFJcIl0gPSAwXSA9IFwiTFRSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBzdGFydHMgYmVsb3cgd2hlcmUgaXQgZW5kcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25EaXJlY3Rpb25bU2VsZWN0aW9uRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xufSkoU2VsZWN0aW9uRGlyZWN0aW9uIHx8IChTZWxlY3Rpb25EaXJlY3Rpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAyXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJDb250ZW50Q2hhbmdlXCJdID0gM10gPSBcIkNvbnRlbnRDaGFuZ2VcIjtcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmlsZVwiXSA9IDBdID0gXCJGaWxlXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTW9kdWxlXCJdID0gMV0gPSBcIk1vZHVsZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk5hbWVzcGFjZVwiXSA9IDJdID0gXCJOYW1lc3BhY2VcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQYWNrYWdlXCJdID0gM10gPSBcIlBhY2thZ2VcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJDbGFzc1wiXSA9IDRdID0gXCJDbGFzc1wiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk1ldGhvZFwiXSA9IDVdID0gXCJNZXRob2RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQcm9wZXJ0eVwiXSA9IDZdID0gXCJQcm9wZXJ0eVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZpZWxkXCJdID0gN10gPSBcIkZpZWxkXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQ29uc3RydWN0b3JcIl0gPSA4XSA9IFwiQ29uc3RydWN0b3JcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtXCJdID0gOV0gPSBcIkVudW1cIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJJbnRlcmZhY2VcIl0gPSAxMF0gPSBcIkludGVyZmFjZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkZ1bmN0aW9uXCJdID0gMTFdID0gXCJGdW5jdGlvblwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlZhcmlhYmxlXCJdID0gMTJdID0gXCJWYXJpYWJsZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNvbnN0YW50XCJdID0gMTNdID0gXCJDb25zdGFudFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlN0cmluZ1wiXSA9IDE0XSA9IFwiU3RyaW5nXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVtYmVyXCJdID0gMTVdID0gXCJOdW1iZXJcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJCb29sZWFuXCJdID0gMTZdID0gXCJCb29sZWFuXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQXJyYXlcIl0gPSAxN10gPSBcIkFycmF5XCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiT2JqZWN0XCJdID0gMThdID0gXCJPYmplY3RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJLZXlcIl0gPSAxOV0gPSBcIktleVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk51bGxcIl0gPSAyMF0gPSBcIk51bGxcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMjFdID0gXCJFbnVtTWVtYmVyXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiU3RydWN0XCJdID0gMjJdID0gXCJTdHJ1Y3RcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFdmVudFwiXSA9IDIzXSA9IFwiRXZlbnRcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJPcGVyYXRvclwiXSA9IDI0XSA9IFwiT3BlcmF0b3JcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJUeXBlUGFyYW1ldGVyXCJdID0gMjVdID0gXCJUeXBlUGFyYW1ldGVyXCI7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICBTeW1ib2xUYWdbU3ltYm9sVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDFdID0gXCJEZXByZWNhdGVkXCI7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBraW5kIG9mIGFuaW1hdGlvbiBpbiB3aGljaCB0aGUgZWRpdG9yJ3MgY3Vyc29yIHNob3VsZCBiZSByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZTtcbihmdW5jdGlvbiAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBIaWRkZW5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkhpZGRlblwiXSA9IDBdID0gXCJIaWRkZW5cIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZ1xuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiQmxpbmtcIl0gPSAxXSA9IFwiQmxpbmtcIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZyB3aXRoIHNtb290aCBmYWRpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlNtb290aFwiXSA9IDJdID0gXCJTbW9vdGhcIjtcbiAgICAvKipcbiAgICAgKiBCbGlua2luZyB3aXRoIHByb2xvbmdlZCBmaWxsZWQgc3RhdGUgYW5kIHNtb290aCBmYWRpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlBoYXNlXCJdID0gM10gPSBcIlBoYXNlXCI7XG4gICAgLyoqXG4gICAgICogRXhwYW5kIGNvbGxhcHNlIGFuaW1hdGlvbiBvbiB0aGUgeSBheGlzXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJFeHBhbmRcIl0gPSA0XSA9IFwiRXhwYW5kXCI7XG4gICAgLyoqXG4gICAgICogTm8tQmxpbmtpbmdcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlNvbGlkXCJdID0gNV0gPSBcIlNvbGlkXCI7XG59KShUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSB8fCAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUgPSB7fSkpO1xuLyoqXG4gKiBUaGUgc3R5bGUgaW4gd2hpY2ggdGhlIGVkaXRvcidzIGN1cnNvciBzaG91bGQgYmUgcmVuZGVyZWQuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dEVkaXRvckN1cnNvclN0eWxlO1xuKGZ1bmN0aW9uIChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBBcyBhIHZlcnRpY2FsIGxpbmUgKHNpdHRpbmcgYmV0d2VlbiB0d28gY2hhcmFjdGVycykuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xuICAgIC8qKlxuICAgICAqIEFzIGEgYmxvY2sgKHNpdHRpbmcgb24gdG9wIG9mIGEgY2hhcmFjdGVyKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiQmxvY2tcIl0gPSAyXSA9IFwiQmxvY2tcIjtcbiAgICAvKipcbiAgICAgKiBBcyBhIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIlVuZGVybGluZVwiXSA9IDNdID0gXCJVbmRlcmxpbmVcIjtcbiAgICAvKipcbiAgICAgKiBBcyBhIHRoaW4gdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiTGluZVRoaW5cIl0gPSA0XSA9IFwiTGluZVRoaW5cIjtcbiAgICAvKipcbiAgICAgKiBBcyBhbiBvdXRsaW5lZCBibG9jayAoc2l0dGluZyBvbiB0b3Agb2YgYSBjaGFyYWN0ZXIpLlxuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja091dGxpbmVcIl0gPSA1XSA9IFwiQmxvY2tPdXRsaW5lXCI7XG4gICAgLyoqXG4gICAgICogQXMgYSB0aGluIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIlVuZGVybGluZVRoaW5cIl0gPSA2XSA9IFwiVW5kZXJsaW5lVGhpblwiO1xufSkoVGV4dEVkaXRvckN1cnNvclN0eWxlIHx8IChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGJlaGF2aW9yIG9mIGRlY29yYXRpb25zIHdoZW4gdHlwaW5nL2VkaXRpbmcgbmVhciB0aGVpciBlZGdlcy5cbiAqIE5vdGU6IFBsZWFzZSBkbyBub3QgZWRpdCB0aGUgdmFsdWVzLCBhcyB0aGV5IHZlcnkgY2FyZWZ1bGx5IG1hdGNoIGBEZWNvcmF0aW9uUmFuZ2VCZWhhdmlvcmBcbiAqL1xuZXhwb3J0IHZhciBUcmFja2VkUmFuZ2VTdGlja2luZXNzO1xuKGZ1bmN0aW9uIChUcmFja2VkUmFuZ2VTdGlja2luZXNzKSB7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiQWx3YXlzR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiXSA9IDBdID0gXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCI7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiTmV2ZXJHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCJdID0gMV0gPSBcIk5ldmVyR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiO1xuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdCZWZvcmVcIl0gPSAyXSA9IFwiR3Jvd3NPbmx5V2hlblR5cGluZ0JlZm9yZVwiO1xuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiXSA9IDNdID0gXCJHcm93c09ubHlXaGVuVHlwaW5nQWZ0ZXJcIjtcbn0pKFRyYWNrZWRSYW5nZVN0aWNraW5lc3MgfHwgKFRyYWNrZWRSYW5nZVN0aWNraW5lc3MgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IHRvIGluZGVudCB3cmFwcGVkIGxpbmVzLlxuICovXG5leHBvcnQgdmFyIFdyYXBwaW5nSW5kZW50O1xuKGZ1bmN0aW9uIChXcmFwcGluZ0luZGVudCkge1xuICAgIC8qKlxuICAgICAqIE5vIGluZGVudGF0aW9uID0+IHdyYXBwZWQgbGluZXMgYmVnaW4gYXQgY29sdW1uIDEuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBTYW1lID0+IHdyYXBwZWQgbGluZXMgZ2V0IHRoZSBzYW1lIGluZGVudGF0aW9uIGFzIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJTYW1lXCJdID0gMV0gPSBcIlNhbWVcIjtcbiAgICAvKipcbiAgICAgKiBJbmRlbnQgPT4gd3JhcHBlZCBsaW5lcyBnZXQgKzEgaW5kZW50YXRpb24gdG93YXJkIHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJJbmRlbnRcIl0gPSAyXSA9IFwiSW5kZW50XCI7XG4gICAgLyoqXG4gICAgICogRGVlcEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMiBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIkRlZXBJbmRlbnRcIl0gPSAzXSA9IFwiRGVlcEluZGVudFwiO1xufSkoV3JhcHBpbmdJbmRlbnQgfHwgKFdyYXBwaW5nSW5kZW50ID0ge30pKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSwgdG9EaXNwb3NhYmxlIH0gZnJvbSAnLi4vLi4vYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzJztcbmV4cG9ydCBjbGFzcyBUb2tlbml6YXRpb25SZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25EaWRDaGFuZ2UgPSB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcbiAgICAgICAgdGhpcy5fY29sb3JNYXAgPSBudWxsO1xuICAgIH1cbiAgICBmaXJlKGxhbmd1YWdlcykge1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZS5maXJlKHtcbiAgICAgICAgICAgIGNoYW5nZWRMYW5ndWFnZXM6IGxhbmd1YWdlcyxcbiAgICAgICAgICAgIGNoYW5nZWRDb2xvck1hcDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGxhbmd1YWdlLCBzdXBwb3J0KSB7XG4gICAgICAgIHRoaXMuX21hcC5zZXQobGFuZ3VhZ2UsIHN1cHBvcnQpO1xuICAgICAgICB0aGlzLmZpcmUoW2xhbmd1YWdlXSk7XG4gICAgICAgIHJldHVybiB0b0Rpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hcC5nZXQobGFuZ3VhZ2UpICE9PSBzdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShsYW5ndWFnZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoW2xhbmd1YWdlXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdpc3RlckZhY3RvcnkobGFuZ3VhZ2VJZCwgZmFjdG9yeSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQobGFuZ3VhZ2VJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIGNvbnN0IG15RGF0YSA9IG5ldyBUb2tlbml6YXRpb25TdXBwb3J0RmFjdG9yeURhdGEodGhpcywgbGFuZ3VhZ2VJZCwgZmFjdG9yeSk7XG4gICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQobGFuZ3VhZ2VJZCwgbXlEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5fZmFjdG9yaWVzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIGlmICghdiB8fCB2ICE9PSBteURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMuZGVsZXRlKGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgdi5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmaXJzdCBpZiB0aGUgc3VwcG9ydCBpcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgY29uc3QgdG9rZW5pemF0aW9uU3VwcG9ydCA9IHRoaXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuaXphdGlvblN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5pemF0aW9uU3VwcG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgaWYgKCFmYWN0b3J5IHx8IGZhY3RvcnkuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIGZhY3Rvcnkgb3IgZmFjdG9yeS5yZXNvbHZlIGFscmVhZHkgZmluaXNoZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGZhY3RvcnkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbWFwLmdldChsYW5ndWFnZSkgfHwgbnVsbCk7XG4gICAgfVxuICAgIGlzUmVzb2x2ZWQobGFuZ3VhZ2VJZCkge1xuICAgICAgICBjb25zdCB0b2tlbml6YXRpb25TdXBwb3J0ID0gdGhpcy5nZXQobGFuZ3VhZ2VJZCk7XG4gICAgICAgIGlmICh0b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5fZmFjdG9yaWVzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgaWYgKCFmYWN0b3J5IHx8IGZhY3RvcnkuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXRDb2xvck1hcChjb2xvck1hcCkge1xuICAgICAgICB0aGlzLl9jb2xvck1hcCA9IGNvbG9yTWFwO1xuICAgICAgICB0aGlzLl9vbkRpZENoYW5nZS5maXJlKHtcbiAgICAgICAgICAgIGNoYW5nZWRMYW5ndWFnZXM6IEFycmF5LmZyb20odGhpcy5fbWFwLmtleXMoKSksXG4gICAgICAgICAgICBjaGFuZ2VkQ29sb3JNYXA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbG9yTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JNYXA7XG4gICAgfVxuICAgIGdldERlZmF1bHRCYWNrZ3JvdW5kKCkge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JNYXAgJiYgdGhpcy5fY29sb3JNYXAubGVuZ3RoID4gMiAvKiBEZWZhdWx0QmFja2dyb3VuZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwWzIgLyogRGVmYXVsdEJhY2tncm91bmQgKi9dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuaXphdGlvblN1cHBvcnRGYWN0b3J5RGF0YSBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKF9yZWdpc3RyeSwgX2xhbmd1YWdlSWQsIF9mYWN0b3J5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gX3JlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gX2xhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBfZmFjdG9yeTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzUmVzb2x2ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1Jlc29sdmVkO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICByZXNvbHZlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlID0gdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB5aWVsZCBQcm9taXNlLnJlc29sdmUodGhpcy5fZmFjdG9yeS5jcmVhdGVUb2tlbml6YXRpb25TdXBwb3J0KCkpO1xuICAgICAgICAgICAgdGhpcy5faXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3Rlcih0aGlzLl9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLl9sYW5ndWFnZUlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBTaW1wbGVXb3JrZXJTZXJ2ZXIgfSBmcm9tICcuLi9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzJztcbmltcG9ydCB7IEVkaXRvclNpbXBsZVdvcmtlciB9IGZyb20gJy4vY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qcyc7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKGZvcmVpZ25Nb2R1bGUpIHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgY29uc3Qgc2ltcGxlV29ya2VyID0gbmV3IFNpbXBsZVdvcmtlclNlcnZlcigobXNnKSA9PiB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UobXNnKTtcbiAgICB9LCAoaG9zdCkgPT4gbmV3IEVkaXRvclNpbXBsZVdvcmtlcihob3N0LCBmb3JlaWduTW9kdWxlKSk7XG4gICAgc2VsZi5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICBzaW1wbGVXb3JrZXIub25tZXNzYWdlKGUuZGF0YSk7XG4gICAgfTtcbn1cbnNlbGYub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAvLyBJZ25vcmUgZmlyc3QgbWVzc2FnZSBpbiB0aGlzIGNhc2UgYW5kIGluaXRpYWxpemUgaWYgbm90IHlldCBpbml0aWFsaXplZFxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZShudWxsKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9